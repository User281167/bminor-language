Grammar:

Rule 0     S' -> prog
Rule 1     prog -> global_list
Rule 2     decl_list -> empty
Rule 3     decl_list -> decl decl_list
Rule 4     global_item -> stmt
Rule 5     global_item -> decl
Rule 6     global_list -> empty
Rule 7     global_list -> global_item global_list
Rule 8     decl -> decl_init
Rule 9     decl -> ID : type_func ;
Rule 10    decl -> ID : type_array_sized ;
Rule 11    decl -> ID : type_simple ;
Rule 12    decl_init -> ID : type_func = { opt_stmt_list }
Rule 13    decl_init -> ID : type_array_sized = { opt_expr_list } ;
Rule 14    decl_init -> ID : CONSTANT error
Rule 15    decl_init -> ID : CONSTANT = { opt_expr_list } ;
Rule 16    decl_init -> ID : CONSTANT = expr ;
Rule 17    decl_init -> ID : AUTO error
Rule 18    decl_init -> ID : AUTO = { opt_expr_list } ;
Rule 19    decl_init -> ID : AUTO = expr ;
Rule 20    decl_init -> ID : type_simple = expr ;
Rule 21    opt_stmt_list -> empty
Rule 22    opt_stmt_list -> stmt_list
Rule 23    stmt_list -> stmt
Rule 24    stmt_list -> stmt stmt_list
Rule 25    stmt -> closed_stmt
Rule 26    stmt -> open_stmt
Rule 27    closed_stmt -> do_while_stmt
Rule 28    closed_stmt -> while_stmt_closed
Rule 29    closed_stmt -> simple_stmt
Rule 30    closed_stmt -> for_stmt_closed
Rule 31    closed_stmt -> if_stmt_closed
Rule 32    open_stmt -> while_stmt_open
Rule 33    open_stmt -> for_stmt_open
Rule 34    open_stmt -> if_stmt_open
Rule 35    if_cond -> IF ( expr )
Rule 36    if_stmt_closed -> if_cond closed_stmt ELSE closed_stmt
Rule 37    if_stmt_open -> if_cond closed_stmt ELSE if_stmt_open
Rule 38    if_stmt_open -> if_cond stmt
Rule 39    for_header -> FOR ( opt_expr ; opt_expr ; opt_expr )
Rule 40    for_stmt_open -> for_header open_stmt
Rule 41    for_stmt_closed -> for_header closed_stmt
Rule 42    while_stmt_open -> WHILE ( opt_expr ) open_stmt
Rule 43    while_stmt_closed -> WHILE ( opt_expr ) closed_stmt
Rule 44    do_while_stmt -> DO closed_stmt WHILE ( expr ) ;
Rule 45    simple_stmt -> lval = expr ;
Rule 46    simple_stmt -> expr ;
Rule 47    simple_stmt -> decl
Rule 48    simple_stmt -> block_stmt
Rule 49    simple_stmt -> break_stmt
Rule 50    simple_stmt -> continue_stmt
Rule 51    simple_stmt -> return_stmt
Rule 52    simple_stmt -> print_stmt
Rule 53    print_stmt -> PRINT opt_expr_list ;
Rule 54    return_stmt -> RETURN opt_expr ;
Rule 55    continue_stmt -> CONTINUE ;
Rule 56    break_stmt -> BREAK ;
Rule 57    block_stmt -> { stmt_list }
Rule 58    opt_expr_list -> expr_list
Rule 59    opt_expr_list -> empty
Rule 60    expr_list -> expr
Rule 61    expr_list -> expr , expr_list
Rule 62    opt_expr -> expr
Rule 63    opt_expr -> empty
Rule 64    expr -> expr1
Rule 65    expr1 -> expr2
Rule 66    expr1 -> lval = expr1
Rule 67    lval -> ID index
Rule 68    lval -> ID
Rule 69    expr2 -> expr3
Rule 70    expr2 -> expr2 LOR expr3
Rule 71    expr3 -> expr4
Rule 72    expr3 -> expr3 LAND expr4
Rule 73    expr4 -> expr5
Rule 74    expr4 -> expr4 GE expr5
Rule 75    expr4 -> expr4 GT expr5
Rule 76    expr4 -> expr4 LE expr5
Rule 77    expr4 -> expr4 LT expr5
Rule 78    expr4 -> expr4 NE expr5
Rule 79    expr4 -> expr4 EQ expr5
Rule 80    expr5 -> expr6
Rule 81    expr5 -> expr5 - expr6
Rule 82    expr5 -> expr5 + expr6
Rule 83    expr6 -> expr7
Rule 84    expr6 -> expr6 % expr7
Rule 85    expr6 -> expr6 / expr7
Rule 86    expr6 -> expr6 * expr7
Rule 87    expr7 -> expr8
Rule 88    expr7 -> expr7 ^ expr8
Rule 89    expr8 -> expr9
Rule 90    expr8 -> ! expr8
Rule 91    expr8 -> + expr8
Rule 92    expr8 -> - expr8
Rule 93    expr9 -> group
Rule 94    expr9 -> DEC expr9
Rule 95    expr9 -> expr9 DEC
Rule 96    expr9 -> INC expr9
Rule 97    expr9 -> expr9 INC
Rule 98    group -> factor
Rule 99    group -> ID index
Rule 100   group -> ID ( opt_expr_list )
Rule 101   group -> ( expr )
Rule 102   index -> [ expr ]
Rule 103   factor -> FALSE
Rule 104   factor -> TRUE
Rule 105   factor -> STRING_LITERAL
Rule 106   factor -> CHAR_LITERAL
Rule 107   factor -> FLOAT_LITERAL
Rule 108   factor -> INTEGER_LITERAL
Rule 109   factor -> ID
Rule 110   type_simple -> VOID
Rule 111   type_simple -> STRING
Rule 112   type_simple -> CHAR
Rule 113   type_simple -> BOOLEAN
Rule 114   type_simple -> FLOAT
Rule 115   type_simple -> INTEGER
Rule 116   type_array_sized -> ARRAY index type_array_sized
Rule 117   type_array_sized -> ARRAY index type_simple
Rule 118   type_array -> ARRAY [ ] type_array
Rule 119   type_array -> ARRAY [ ] type_simple
Rule 120   type_func -> FUNCTION type_array_sized ( opt_param_list )
Rule 121   type_func -> FUNCTION type_array ( opt_param_list )
Rule 122   type_func -> FUNCTION type_simple ( opt_param_list )
Rule 123   opt_param_list -> param_list
Rule 124   opt_param_list -> empty
Rule 125   param_list -> param
Rule 126   param_list -> param_list , param
Rule 127   param -> ID : type_array_sized
Rule 128   param -> ID : type_array
Rule 129   param -> ID : type_simple
Rule 130   empty -> <empty>

Terminals, with rules where they appear:

!                    : 90
%                    : 84
(                    : 35 39 42 43 44 100 101 120 121 122
)                    : 35 39 42 43 44 100 101 120 121 122
*                    : 86
+                    : 82 91
,                    : 61 126
-                    : 81 92
/                    : 85
:                    : 9 10 11 12 13 14 15 16 17 18 19 20 127 128 129
;                    : 9 10 11 13 15 16 18 19 20 39 39 44 45 46 53 54 55 56
=                    : 12 13 15 16 18 19 20 45 66
ARRAY                : 116 117 118 119
AUTO                 : 17 18 19
BOOLEAN              : 113
BREAK                : 56
CHAR                 : 112
CHAR_LITERAL         : 106
CONSTANT             : 14 15 16
CONTINUE             : 55
DEC                  : 94 95
DO                   : 44
ELSE                 : 36 37
EQ                   : 79
FALSE                : 103
FLOAT                : 114
FLOAT_LITERAL        : 107
FOR                  : 39
FUNCTION             : 120 121 122
GE                   : 74
GT                   : 75
ID                   : 9 10 11 12 13 14 15 16 17 18 19 20 67 68 99 100 109 127 128 129
IF                   : 35
INC                  : 96 97
INTEGER              : 115
INTEGER_LITERAL      : 108
LAND                 : 72
LE                   : 76
LOR                  : 70
LT                   : 77
NE                   : 78
PRINT                : 53
RETURN               : 54
STRING               : 111
STRING_LITERAL       : 105
TRUE                 : 104
VOID                 : 110
WHILE                : 42 43 44
[                    : 102 118 119
]                    : 102 118 119
^                    : 88
error                : 14 17
{                    : 12 13 15 18 57
}                    : 12 13 15 18 57

Nonterminals, with rules where they appear:

block_stmt           : 48
break_stmt           : 49
closed_stmt          : 25 36 36 37 41 43 44
continue_stmt        : 50
decl                 : 3 5 47
decl_init            : 8
decl_list            : 3
do_while_stmt        : 27
empty                : 2 6 21 59 63 124
expr                 : 16 19 20 35 44 45 46 60 61 62 101 102
expr1                : 64 66
expr2                : 65 70
expr3                : 69 70 72
expr4                : 71 72 74 75 76 77 78 79
expr5                : 73 74 75 76 77 78 79 81 82
expr6                : 80 81 82 84 85 86
expr7                : 83 84 85 86 88
expr8                : 87 88 90 91 92
expr9                : 89 94 95 96 97
expr_list            : 58 61
factor               : 98
for_header           : 40 41
for_stmt_closed      : 30
for_stmt_open        : 33
global_item          : 7
global_list          : 1 7
group                : 93
if_cond              : 36 37 38
if_stmt_closed       : 31
if_stmt_open         : 34 37
index                : 67 99 116 117
lval                 : 45 66
open_stmt            : 26 40 42
opt_expr             : 39 39 39 42 43 54
opt_expr_list        : 13 15 18 53 100
opt_param_list       : 120 121 122
opt_stmt_list        : 12
param                : 125 126
param_list           : 123 126
print_stmt           : 52
prog                 : 0
return_stmt          : 51
simple_stmt          : 29
stmt                 : 4 23 24 38
stmt_list            : 22 24 57
type_array           : 118 121 128
type_array_sized     : 10 13 116 120 127
type_func            : 9 12
type_simple          : 11 20 117 119 122 129
while_stmt_closed    : 28
while_stmt_open      : 32


state 0

    (0) S' -> . prog
    (1) prog -> . global_list
    (6) global_list -> . empty
    (7) global_list -> . global_item global_list
    (130) empty -> .
    (4) global_item -> . stmt
    (5) global_item -> . decl
    (25) stmt -> . closed_stmt
    (26) stmt -> . open_stmt
    (8) decl -> . decl_init
    (9) decl -> . ID : type_func ;
    (10) decl -> . ID : type_array_sized ;
    (11) decl -> . ID : type_simple ;
    (27) closed_stmt -> . do_while_stmt
    (28) closed_stmt -> . while_stmt_closed
    (29) closed_stmt -> . simple_stmt
    (30) closed_stmt -> . for_stmt_closed
    (31) closed_stmt -> . if_stmt_closed
    (32) open_stmt -> . while_stmt_open
    (33) open_stmt -> . for_stmt_open
    (34) open_stmt -> . if_stmt_open
    (12) decl_init -> . ID : type_func = { opt_stmt_list }
    (13) decl_init -> . ID : type_array_sized = { opt_expr_list } ;
    (14) decl_init -> . ID : CONSTANT error
    (15) decl_init -> . ID : CONSTANT = { opt_expr_list } ;
    (16) decl_init -> . ID : CONSTANT = expr ;
    (17) decl_init -> . ID : AUTO error
    (18) decl_init -> . ID : AUTO = { opt_expr_list } ;
    (19) decl_init -> . ID : AUTO = expr ;
    (20) decl_init -> . ID : type_simple = expr ;
    (44) do_while_stmt -> . DO closed_stmt WHILE ( expr ) ;
    (43) while_stmt_closed -> . WHILE ( opt_expr ) closed_stmt
    (45) simple_stmt -> . lval = expr ;
    (46) simple_stmt -> . expr ;
    (47) simple_stmt -> . decl
    (48) simple_stmt -> . block_stmt
    (49) simple_stmt -> . break_stmt
    (50) simple_stmt -> . continue_stmt
    (51) simple_stmt -> . return_stmt
    (52) simple_stmt -> . print_stmt
    (41) for_stmt_closed -> . for_header closed_stmt
    (36) if_stmt_closed -> . if_cond closed_stmt ELSE closed_stmt
    (42) while_stmt_open -> . WHILE ( opt_expr ) open_stmt
    (40) for_stmt_open -> . for_header open_stmt
    (37) if_stmt_open -> . if_cond closed_stmt ELSE if_stmt_open
    (38) if_stmt_open -> . if_cond stmt
    (67) lval -> . ID index
    (68) lval -> . ID
    (64) expr -> . expr1
    (57) block_stmt -> . { stmt_list }
    (56) break_stmt -> . BREAK ;
    (55) continue_stmt -> . CONTINUE ;
    (54) return_stmt -> . RETURN opt_expr ;
    (53) print_stmt -> . PRINT opt_expr_list ;
    (39) for_header -> . FOR ( opt_expr ; opt_expr ; opt_expr )
    (35) if_cond -> . IF ( expr )
    (65) expr1 -> . expr2
    (66) expr1 -> . lval = expr1
    (69) expr2 -> . expr3
    (70) expr2 -> . expr2 LOR expr3
    (71) expr3 -> . expr4
    (72) expr3 -> . expr3 LAND expr4
    (73) expr4 -> . expr5
    (74) expr4 -> . expr4 GE expr5
    (75) expr4 -> . expr4 GT expr5
    (76) expr4 -> . expr4 LE expr5
    (77) expr4 -> . expr4 LT expr5
    (78) expr4 -> . expr4 NE expr5
    (79) expr4 -> . expr4 EQ expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    $end            reduce using rule 130 (empty -> .)
    ID              shift and go to state 10
    DO              shift and go to state 21
    WHILE           shift and go to state 22
    {               shift and go to state 19
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    RETURN          shift and go to state 35
    PRINT           shift and go to state 36
    FOR             shift and go to state 37
    IF              shift and go to state 38
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    prog                           shift and go to state 1
    global_list                    shift and go to state 2
    empty                          shift and go to state 3
    global_item                    shift and go to state 4
    stmt                           shift and go to state 5
    decl                           shift and go to state 6
    closed_stmt                    shift and go to state 7
    open_stmt                      shift and go to state 8
    decl_init                      shift and go to state 9
    do_while_stmt                  shift and go to state 11
    while_stmt_closed              shift and go to state 12
    simple_stmt                    shift and go to state 13
    for_stmt_closed                shift and go to state 14
    if_stmt_closed                 shift and go to state 15
    while_stmt_open                shift and go to state 16
    for_stmt_open                  shift and go to state 17
    if_stmt_open                   shift and go to state 18
    expr                           shift and go to state 20
    lval                           shift and go to state 24
    block_stmt                     shift and go to state 25
    break_stmt                     shift and go to state 26
    continue_stmt                  shift and go to state 27
    return_stmt                    shift and go to state 28
    print_stmt                     shift and go to state 29
    for_header                     shift and go to state 30
    if_cond                        shift and go to state 31
    expr1                          shift and go to state 32
    expr2                          shift and go to state 39
    expr3                          shift and go to state 40
    expr4                          shift and go to state 41
    expr5                          shift and go to state 42
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 1

    (0) S' -> prog .


state 2

    (1) prog -> global_list .
    $end            reduce using rule 1 (prog -> global_list .)


state 3

    (6) global_list -> empty .
    $end            reduce using rule 6 (global_list -> empty .)


state 4

    (7) global_list -> global_item . global_list
    (6) global_list -> . empty
    (7) global_list -> . global_item global_list
    (130) empty -> .
    (4) global_item -> . stmt
    (5) global_item -> . decl
    (25) stmt -> . closed_stmt
    (26) stmt -> . open_stmt
    (8) decl -> . decl_init
    (9) decl -> . ID : type_func ;
    (10) decl -> . ID : type_array_sized ;
    (11) decl -> . ID : type_simple ;
    (27) closed_stmt -> . do_while_stmt
    (28) closed_stmt -> . while_stmt_closed
    (29) closed_stmt -> . simple_stmt
    (30) closed_stmt -> . for_stmt_closed
    (31) closed_stmt -> . if_stmt_closed
    (32) open_stmt -> . while_stmt_open
    (33) open_stmt -> . for_stmt_open
    (34) open_stmt -> . if_stmt_open
    (12) decl_init -> . ID : type_func = { opt_stmt_list }
    (13) decl_init -> . ID : type_array_sized = { opt_expr_list } ;
    (14) decl_init -> . ID : CONSTANT error
    (15) decl_init -> . ID : CONSTANT = { opt_expr_list } ;
    (16) decl_init -> . ID : CONSTANT = expr ;
    (17) decl_init -> . ID : AUTO error
    (18) decl_init -> . ID : AUTO = { opt_expr_list } ;
    (19) decl_init -> . ID : AUTO = expr ;
    (20) decl_init -> . ID : type_simple = expr ;
    (44) do_while_stmt -> . DO closed_stmt WHILE ( expr ) ;
    (43) while_stmt_closed -> . WHILE ( opt_expr ) closed_stmt
    (45) simple_stmt -> . lval = expr ;
    (46) simple_stmt -> . expr ;
    (47) simple_stmt -> . decl
    (48) simple_stmt -> . block_stmt
    (49) simple_stmt -> . break_stmt
    (50) simple_stmt -> . continue_stmt
    (51) simple_stmt -> . return_stmt
    (52) simple_stmt -> . print_stmt
    (41) for_stmt_closed -> . for_header closed_stmt
    (36) if_stmt_closed -> . if_cond closed_stmt ELSE closed_stmt
    (42) while_stmt_open -> . WHILE ( opt_expr ) open_stmt
    (40) for_stmt_open -> . for_header open_stmt
    (37) if_stmt_open -> . if_cond closed_stmt ELSE if_stmt_open
    (38) if_stmt_open -> . if_cond stmt
    (67) lval -> . ID index
    (68) lval -> . ID
    (64) expr -> . expr1
    (57) block_stmt -> . { stmt_list }
    (56) break_stmt -> . BREAK ;
    (55) continue_stmt -> . CONTINUE ;
    (54) return_stmt -> . RETURN opt_expr ;
    (53) print_stmt -> . PRINT opt_expr_list ;
    (39) for_header -> . FOR ( opt_expr ; opt_expr ; opt_expr )
    (35) if_cond -> . IF ( expr )
    (65) expr1 -> . expr2
    (66) expr1 -> . lval = expr1
    (69) expr2 -> . expr3
    (70) expr2 -> . expr2 LOR expr3
    (71) expr3 -> . expr4
    (72) expr3 -> . expr3 LAND expr4
    (73) expr4 -> . expr5
    (74) expr4 -> . expr4 GE expr5
    (75) expr4 -> . expr4 GT expr5
    (76) expr4 -> . expr4 LE expr5
    (77) expr4 -> . expr4 LT expr5
    (78) expr4 -> . expr4 NE expr5
    (79) expr4 -> . expr4 EQ expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    $end            reduce using rule 130 (empty -> .)
    ID              shift and go to state 10
    DO              shift and go to state 21
    WHILE           shift and go to state 22
    {               shift and go to state 19
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    RETURN          shift and go to state 35
    PRINT           shift and go to state 36
    FOR             shift and go to state 37
    IF              shift and go to state 38
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    global_item                    shift and go to state 4
    global_list                    shift and go to state 60
    empty                          shift and go to state 3
    stmt                           shift and go to state 5
    decl                           shift and go to state 6
    closed_stmt                    shift and go to state 7
    open_stmt                      shift and go to state 8
    decl_init                      shift and go to state 9
    do_while_stmt                  shift and go to state 11
    while_stmt_closed              shift and go to state 12
    simple_stmt                    shift and go to state 13
    for_stmt_closed                shift and go to state 14
    if_stmt_closed                 shift and go to state 15
    while_stmt_open                shift and go to state 16
    for_stmt_open                  shift and go to state 17
    if_stmt_open                   shift and go to state 18
    expr                           shift and go to state 20
    lval                           shift and go to state 24
    block_stmt                     shift and go to state 25
    break_stmt                     shift and go to state 26
    continue_stmt                  shift and go to state 27
    return_stmt                    shift and go to state 28
    print_stmt                     shift and go to state 29
    for_header                     shift and go to state 30
    if_cond                        shift and go to state 31
    expr1                          shift and go to state 32
    expr2                          shift and go to state 39
    expr3                          shift and go to state 40
    expr4                          shift and go to state 41
    expr5                          shift and go to state 42
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 5

    (4) global_item -> stmt .
    ID              reduce using rule 4 (global_item -> stmt .)
    DO              reduce using rule 4 (global_item -> stmt .)
    WHILE           reduce using rule 4 (global_item -> stmt .)
    {               reduce using rule 4 (global_item -> stmt .)
    BREAK           reduce using rule 4 (global_item -> stmt .)
    CONTINUE        reduce using rule 4 (global_item -> stmt .)
    RETURN          reduce using rule 4 (global_item -> stmt .)
    PRINT           reduce using rule 4 (global_item -> stmt .)
    FOR             reduce using rule 4 (global_item -> stmt .)
    IF              reduce using rule 4 (global_item -> stmt .)
    !               reduce using rule 4 (global_item -> stmt .)
    +               reduce using rule 4 (global_item -> stmt .)
    -               reduce using rule 4 (global_item -> stmt .)
    DEC             reduce using rule 4 (global_item -> stmt .)
    INC             reduce using rule 4 (global_item -> stmt .)
    (               reduce using rule 4 (global_item -> stmt .)
    FALSE           reduce using rule 4 (global_item -> stmt .)
    TRUE            reduce using rule 4 (global_item -> stmt .)
    STRING_LITERAL  reduce using rule 4 (global_item -> stmt .)
    CHAR_LITERAL    reduce using rule 4 (global_item -> stmt .)
    FLOAT_LITERAL   reduce using rule 4 (global_item -> stmt .)
    INTEGER_LITERAL reduce using rule 4 (global_item -> stmt .)
    $end            reduce using rule 4 (global_item -> stmt .)


state 6

    (5) global_item -> decl .
    (47) simple_stmt -> decl .
  ! reduce/reduce conflict for ID resolved using rule 5 (global_item -> decl .)
  ! reduce/reduce conflict for DO resolved using rule 5 (global_item -> decl .)
  ! reduce/reduce conflict for WHILE resolved using rule 5 (global_item -> decl .)
  ! reduce/reduce conflict for { resolved using rule 5 (global_item -> decl .)
  ! reduce/reduce conflict for BREAK resolved using rule 5 (global_item -> decl .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 5 (global_item -> decl .)
  ! reduce/reduce conflict for RETURN resolved using rule 5 (global_item -> decl .)
  ! reduce/reduce conflict for PRINT resolved using rule 5 (global_item -> decl .)
  ! reduce/reduce conflict for FOR resolved using rule 5 (global_item -> decl .)
  ! reduce/reduce conflict for IF resolved using rule 5 (global_item -> decl .)
  ! reduce/reduce conflict for ! resolved using rule 5 (global_item -> decl .)
  ! reduce/reduce conflict for + resolved using rule 5 (global_item -> decl .)
  ! reduce/reduce conflict for - resolved using rule 5 (global_item -> decl .)
  ! reduce/reduce conflict for DEC resolved using rule 5 (global_item -> decl .)
  ! reduce/reduce conflict for INC resolved using rule 5 (global_item -> decl .)
  ! reduce/reduce conflict for ( resolved using rule 5 (global_item -> decl .)
  ! reduce/reduce conflict for FALSE resolved using rule 5 (global_item -> decl .)
  ! reduce/reduce conflict for TRUE resolved using rule 5 (global_item -> decl .)
  ! reduce/reduce conflict for STRING_LITERAL resolved using rule 5 (global_item -> decl .)
  ! reduce/reduce conflict for CHAR_LITERAL resolved using rule 5 (global_item -> decl .)
  ! reduce/reduce conflict for FLOAT_LITERAL resolved using rule 5 (global_item -> decl .)
  ! reduce/reduce conflict for INTEGER_LITERAL resolved using rule 5 (global_item -> decl .)
  ! reduce/reduce conflict for $end resolved using rule 5 (global_item -> decl .)
    ID              reduce using rule 5 (global_item -> decl .)
    DO              reduce using rule 5 (global_item -> decl .)
    WHILE           reduce using rule 5 (global_item -> decl .)
    {               reduce using rule 5 (global_item -> decl .)
    BREAK           reduce using rule 5 (global_item -> decl .)
    CONTINUE        reduce using rule 5 (global_item -> decl .)
    RETURN          reduce using rule 5 (global_item -> decl .)
    PRINT           reduce using rule 5 (global_item -> decl .)
    FOR             reduce using rule 5 (global_item -> decl .)
    IF              reduce using rule 5 (global_item -> decl .)
    !               reduce using rule 5 (global_item -> decl .)
    +               reduce using rule 5 (global_item -> decl .)
    -               reduce using rule 5 (global_item -> decl .)
    DEC             reduce using rule 5 (global_item -> decl .)
    INC             reduce using rule 5 (global_item -> decl .)
    (               reduce using rule 5 (global_item -> decl .)
    FALSE           reduce using rule 5 (global_item -> decl .)
    TRUE            reduce using rule 5 (global_item -> decl .)
    STRING_LITERAL  reduce using rule 5 (global_item -> decl .)
    CHAR_LITERAL    reduce using rule 5 (global_item -> decl .)
    FLOAT_LITERAL   reduce using rule 5 (global_item -> decl .)
    INTEGER_LITERAL reduce using rule 5 (global_item -> decl .)
    $end            reduce using rule 5 (global_item -> decl .)


state 7

    (25) stmt -> closed_stmt .
    ID              reduce using rule 25 (stmt -> closed_stmt .)
    DO              reduce using rule 25 (stmt -> closed_stmt .)
    WHILE           reduce using rule 25 (stmt -> closed_stmt .)
    {               reduce using rule 25 (stmt -> closed_stmt .)
    BREAK           reduce using rule 25 (stmt -> closed_stmt .)
    CONTINUE        reduce using rule 25 (stmt -> closed_stmt .)
    RETURN          reduce using rule 25 (stmt -> closed_stmt .)
    PRINT           reduce using rule 25 (stmt -> closed_stmt .)
    FOR             reduce using rule 25 (stmt -> closed_stmt .)
    IF              reduce using rule 25 (stmt -> closed_stmt .)
    !               reduce using rule 25 (stmt -> closed_stmt .)
    +               reduce using rule 25 (stmt -> closed_stmt .)
    -               reduce using rule 25 (stmt -> closed_stmt .)
    DEC             reduce using rule 25 (stmt -> closed_stmt .)
    INC             reduce using rule 25 (stmt -> closed_stmt .)
    (               reduce using rule 25 (stmt -> closed_stmt .)
    FALSE           reduce using rule 25 (stmt -> closed_stmt .)
    TRUE            reduce using rule 25 (stmt -> closed_stmt .)
    STRING_LITERAL  reduce using rule 25 (stmt -> closed_stmt .)
    CHAR_LITERAL    reduce using rule 25 (stmt -> closed_stmt .)
    FLOAT_LITERAL   reduce using rule 25 (stmt -> closed_stmt .)
    INTEGER_LITERAL reduce using rule 25 (stmt -> closed_stmt .)
    $end            reduce using rule 25 (stmt -> closed_stmt .)
    }               reduce using rule 25 (stmt -> closed_stmt .)


state 8

    (26) stmt -> open_stmt .
    ID              reduce using rule 26 (stmt -> open_stmt .)
    DO              reduce using rule 26 (stmt -> open_stmt .)
    WHILE           reduce using rule 26 (stmt -> open_stmt .)
    {               reduce using rule 26 (stmt -> open_stmt .)
    BREAK           reduce using rule 26 (stmt -> open_stmt .)
    CONTINUE        reduce using rule 26 (stmt -> open_stmt .)
    RETURN          reduce using rule 26 (stmt -> open_stmt .)
    PRINT           reduce using rule 26 (stmt -> open_stmt .)
    FOR             reduce using rule 26 (stmt -> open_stmt .)
    IF              reduce using rule 26 (stmt -> open_stmt .)
    !               reduce using rule 26 (stmt -> open_stmt .)
    +               reduce using rule 26 (stmt -> open_stmt .)
    -               reduce using rule 26 (stmt -> open_stmt .)
    DEC             reduce using rule 26 (stmt -> open_stmt .)
    INC             reduce using rule 26 (stmt -> open_stmt .)
    (               reduce using rule 26 (stmt -> open_stmt .)
    FALSE           reduce using rule 26 (stmt -> open_stmt .)
    TRUE            reduce using rule 26 (stmt -> open_stmt .)
    STRING_LITERAL  reduce using rule 26 (stmt -> open_stmt .)
    CHAR_LITERAL    reduce using rule 26 (stmt -> open_stmt .)
    FLOAT_LITERAL   reduce using rule 26 (stmt -> open_stmt .)
    INTEGER_LITERAL reduce using rule 26 (stmt -> open_stmt .)
    $end            reduce using rule 26 (stmt -> open_stmt .)
    }               reduce using rule 26 (stmt -> open_stmt .)


state 9

    (8) decl -> decl_init .
    ID              reduce using rule 8 (decl -> decl_init .)
    DO              reduce using rule 8 (decl -> decl_init .)
    WHILE           reduce using rule 8 (decl -> decl_init .)
    {               reduce using rule 8 (decl -> decl_init .)
    BREAK           reduce using rule 8 (decl -> decl_init .)
    CONTINUE        reduce using rule 8 (decl -> decl_init .)
    RETURN          reduce using rule 8 (decl -> decl_init .)
    PRINT           reduce using rule 8 (decl -> decl_init .)
    FOR             reduce using rule 8 (decl -> decl_init .)
    IF              reduce using rule 8 (decl -> decl_init .)
    !               reduce using rule 8 (decl -> decl_init .)
    +               reduce using rule 8 (decl -> decl_init .)
    -               reduce using rule 8 (decl -> decl_init .)
    DEC             reduce using rule 8 (decl -> decl_init .)
    INC             reduce using rule 8 (decl -> decl_init .)
    (               reduce using rule 8 (decl -> decl_init .)
    FALSE           reduce using rule 8 (decl -> decl_init .)
    TRUE            reduce using rule 8 (decl -> decl_init .)
    STRING_LITERAL  reduce using rule 8 (decl -> decl_init .)
    CHAR_LITERAL    reduce using rule 8 (decl -> decl_init .)
    FLOAT_LITERAL   reduce using rule 8 (decl -> decl_init .)
    INTEGER_LITERAL reduce using rule 8 (decl -> decl_init .)
    $end            reduce using rule 8 (decl -> decl_init .)
    }               reduce using rule 8 (decl -> decl_init .)
    ELSE            reduce using rule 8 (decl -> decl_init .)


state 10

    (9) decl -> ID . : type_func ;
    (10) decl -> ID . : type_array_sized ;
    (11) decl -> ID . : type_simple ;
    (12) decl_init -> ID . : type_func = { opt_stmt_list }
    (13) decl_init -> ID . : type_array_sized = { opt_expr_list } ;
    (14) decl_init -> ID . : CONSTANT error
    (15) decl_init -> ID . : CONSTANT = { opt_expr_list } ;
    (16) decl_init -> ID . : CONSTANT = expr ;
    (17) decl_init -> ID . : AUTO error
    (18) decl_init -> ID . : AUTO = { opt_expr_list } ;
    (19) decl_init -> ID . : AUTO = expr ;
    (20) decl_init -> ID . : type_simple = expr ;
    (67) lval -> ID . index
    (68) lval -> ID .
    (99) group -> ID . index
    (100) group -> ID . ( opt_expr_list )
    (109) factor -> ID .
    (102) index -> . [ expr ]
    :               shift and go to state 61
    =               reduce using rule 68 (lval -> ID .)
    (               shift and go to state 63
    DEC             reduce using rule 109 (factor -> ID .)
    INC             reduce using rule 109 (factor -> ID .)
    ^               reduce using rule 109 (factor -> ID .)
    %               reduce using rule 109 (factor -> ID .)
    /               reduce using rule 109 (factor -> ID .)
    *               reduce using rule 109 (factor -> ID .)
    -               reduce using rule 109 (factor -> ID .)
    +               reduce using rule 109 (factor -> ID .)
    GE              reduce using rule 109 (factor -> ID .)
    GT              reduce using rule 109 (factor -> ID .)
    LE              reduce using rule 109 (factor -> ID .)
    LT              reduce using rule 109 (factor -> ID .)
    NE              reduce using rule 109 (factor -> ID .)
    EQ              reduce using rule 109 (factor -> ID .)
    LAND            reduce using rule 109 (factor -> ID .)
    LOR             reduce using rule 109 (factor -> ID .)
    ;               reduce using rule 109 (factor -> ID .)
    [               shift and go to state 64

    index                          shift and go to state 62

state 11

    (27) closed_stmt -> do_while_stmt .
    ID              reduce using rule 27 (closed_stmt -> do_while_stmt .)
    DO              reduce using rule 27 (closed_stmt -> do_while_stmt .)
    WHILE           reduce using rule 27 (closed_stmt -> do_while_stmt .)
    {               reduce using rule 27 (closed_stmt -> do_while_stmt .)
    BREAK           reduce using rule 27 (closed_stmt -> do_while_stmt .)
    CONTINUE        reduce using rule 27 (closed_stmt -> do_while_stmt .)
    RETURN          reduce using rule 27 (closed_stmt -> do_while_stmt .)
    PRINT           reduce using rule 27 (closed_stmt -> do_while_stmt .)
    FOR             reduce using rule 27 (closed_stmt -> do_while_stmt .)
    IF              reduce using rule 27 (closed_stmt -> do_while_stmt .)
    !               reduce using rule 27 (closed_stmt -> do_while_stmt .)
    +               reduce using rule 27 (closed_stmt -> do_while_stmt .)
    -               reduce using rule 27 (closed_stmt -> do_while_stmt .)
    DEC             reduce using rule 27 (closed_stmt -> do_while_stmt .)
    INC             reduce using rule 27 (closed_stmt -> do_while_stmt .)
    (               reduce using rule 27 (closed_stmt -> do_while_stmt .)
    FALSE           reduce using rule 27 (closed_stmt -> do_while_stmt .)
    TRUE            reduce using rule 27 (closed_stmt -> do_while_stmt .)
    STRING_LITERAL  reduce using rule 27 (closed_stmt -> do_while_stmt .)
    CHAR_LITERAL    reduce using rule 27 (closed_stmt -> do_while_stmt .)
    FLOAT_LITERAL   reduce using rule 27 (closed_stmt -> do_while_stmt .)
    INTEGER_LITERAL reduce using rule 27 (closed_stmt -> do_while_stmt .)
    $end            reduce using rule 27 (closed_stmt -> do_while_stmt .)
    }               reduce using rule 27 (closed_stmt -> do_while_stmt .)
    ELSE            reduce using rule 27 (closed_stmt -> do_while_stmt .)


state 12

    (28) closed_stmt -> while_stmt_closed .
    ID              reduce using rule 28 (closed_stmt -> while_stmt_closed .)
    DO              reduce using rule 28 (closed_stmt -> while_stmt_closed .)
    WHILE           reduce using rule 28 (closed_stmt -> while_stmt_closed .)
    {               reduce using rule 28 (closed_stmt -> while_stmt_closed .)
    BREAK           reduce using rule 28 (closed_stmt -> while_stmt_closed .)
    CONTINUE        reduce using rule 28 (closed_stmt -> while_stmt_closed .)
    RETURN          reduce using rule 28 (closed_stmt -> while_stmt_closed .)
    PRINT           reduce using rule 28 (closed_stmt -> while_stmt_closed .)
    FOR             reduce using rule 28 (closed_stmt -> while_stmt_closed .)
    IF              reduce using rule 28 (closed_stmt -> while_stmt_closed .)
    !               reduce using rule 28 (closed_stmt -> while_stmt_closed .)
    +               reduce using rule 28 (closed_stmt -> while_stmt_closed .)
    -               reduce using rule 28 (closed_stmt -> while_stmt_closed .)
    DEC             reduce using rule 28 (closed_stmt -> while_stmt_closed .)
    INC             reduce using rule 28 (closed_stmt -> while_stmt_closed .)
    (               reduce using rule 28 (closed_stmt -> while_stmt_closed .)
    FALSE           reduce using rule 28 (closed_stmt -> while_stmt_closed .)
    TRUE            reduce using rule 28 (closed_stmt -> while_stmt_closed .)
    STRING_LITERAL  reduce using rule 28 (closed_stmt -> while_stmt_closed .)
    CHAR_LITERAL    reduce using rule 28 (closed_stmt -> while_stmt_closed .)
    FLOAT_LITERAL   reduce using rule 28 (closed_stmt -> while_stmt_closed .)
    INTEGER_LITERAL reduce using rule 28 (closed_stmt -> while_stmt_closed .)
    $end            reduce using rule 28 (closed_stmt -> while_stmt_closed .)
    }               reduce using rule 28 (closed_stmt -> while_stmt_closed .)
    ELSE            reduce using rule 28 (closed_stmt -> while_stmt_closed .)


state 13

    (29) closed_stmt -> simple_stmt .
    ID              reduce using rule 29 (closed_stmt -> simple_stmt .)
    DO              reduce using rule 29 (closed_stmt -> simple_stmt .)
    WHILE           reduce using rule 29 (closed_stmt -> simple_stmt .)
    {               reduce using rule 29 (closed_stmt -> simple_stmt .)
    BREAK           reduce using rule 29 (closed_stmt -> simple_stmt .)
    CONTINUE        reduce using rule 29 (closed_stmt -> simple_stmt .)
    RETURN          reduce using rule 29 (closed_stmt -> simple_stmt .)
    PRINT           reduce using rule 29 (closed_stmt -> simple_stmt .)
    FOR             reduce using rule 29 (closed_stmt -> simple_stmt .)
    IF              reduce using rule 29 (closed_stmt -> simple_stmt .)
    !               reduce using rule 29 (closed_stmt -> simple_stmt .)
    +               reduce using rule 29 (closed_stmt -> simple_stmt .)
    -               reduce using rule 29 (closed_stmt -> simple_stmt .)
    DEC             reduce using rule 29 (closed_stmt -> simple_stmt .)
    INC             reduce using rule 29 (closed_stmt -> simple_stmt .)
    (               reduce using rule 29 (closed_stmt -> simple_stmt .)
    FALSE           reduce using rule 29 (closed_stmt -> simple_stmt .)
    TRUE            reduce using rule 29 (closed_stmt -> simple_stmt .)
    STRING_LITERAL  reduce using rule 29 (closed_stmt -> simple_stmt .)
    CHAR_LITERAL    reduce using rule 29 (closed_stmt -> simple_stmt .)
    FLOAT_LITERAL   reduce using rule 29 (closed_stmt -> simple_stmt .)
    INTEGER_LITERAL reduce using rule 29 (closed_stmt -> simple_stmt .)
    $end            reduce using rule 29 (closed_stmt -> simple_stmt .)
    }               reduce using rule 29 (closed_stmt -> simple_stmt .)
    ELSE            reduce using rule 29 (closed_stmt -> simple_stmt .)


state 14

    (30) closed_stmt -> for_stmt_closed .
    ID              reduce using rule 30 (closed_stmt -> for_stmt_closed .)
    DO              reduce using rule 30 (closed_stmt -> for_stmt_closed .)
    WHILE           reduce using rule 30 (closed_stmt -> for_stmt_closed .)
    {               reduce using rule 30 (closed_stmt -> for_stmt_closed .)
    BREAK           reduce using rule 30 (closed_stmt -> for_stmt_closed .)
    CONTINUE        reduce using rule 30 (closed_stmt -> for_stmt_closed .)
    RETURN          reduce using rule 30 (closed_stmt -> for_stmt_closed .)
    PRINT           reduce using rule 30 (closed_stmt -> for_stmt_closed .)
    FOR             reduce using rule 30 (closed_stmt -> for_stmt_closed .)
    IF              reduce using rule 30 (closed_stmt -> for_stmt_closed .)
    !               reduce using rule 30 (closed_stmt -> for_stmt_closed .)
    +               reduce using rule 30 (closed_stmt -> for_stmt_closed .)
    -               reduce using rule 30 (closed_stmt -> for_stmt_closed .)
    DEC             reduce using rule 30 (closed_stmt -> for_stmt_closed .)
    INC             reduce using rule 30 (closed_stmt -> for_stmt_closed .)
    (               reduce using rule 30 (closed_stmt -> for_stmt_closed .)
    FALSE           reduce using rule 30 (closed_stmt -> for_stmt_closed .)
    TRUE            reduce using rule 30 (closed_stmt -> for_stmt_closed .)
    STRING_LITERAL  reduce using rule 30 (closed_stmt -> for_stmt_closed .)
    CHAR_LITERAL    reduce using rule 30 (closed_stmt -> for_stmt_closed .)
    FLOAT_LITERAL   reduce using rule 30 (closed_stmt -> for_stmt_closed .)
    INTEGER_LITERAL reduce using rule 30 (closed_stmt -> for_stmt_closed .)
    $end            reduce using rule 30 (closed_stmt -> for_stmt_closed .)
    }               reduce using rule 30 (closed_stmt -> for_stmt_closed .)
    ELSE            reduce using rule 30 (closed_stmt -> for_stmt_closed .)


state 15

    (31) closed_stmt -> if_stmt_closed .
    ID              reduce using rule 31 (closed_stmt -> if_stmt_closed .)
    DO              reduce using rule 31 (closed_stmt -> if_stmt_closed .)
    WHILE           reduce using rule 31 (closed_stmt -> if_stmt_closed .)
    {               reduce using rule 31 (closed_stmt -> if_stmt_closed .)
    BREAK           reduce using rule 31 (closed_stmt -> if_stmt_closed .)
    CONTINUE        reduce using rule 31 (closed_stmt -> if_stmt_closed .)
    RETURN          reduce using rule 31 (closed_stmt -> if_stmt_closed .)
    PRINT           reduce using rule 31 (closed_stmt -> if_stmt_closed .)
    FOR             reduce using rule 31 (closed_stmt -> if_stmt_closed .)
    IF              reduce using rule 31 (closed_stmt -> if_stmt_closed .)
    !               reduce using rule 31 (closed_stmt -> if_stmt_closed .)
    +               reduce using rule 31 (closed_stmt -> if_stmt_closed .)
    -               reduce using rule 31 (closed_stmt -> if_stmt_closed .)
    DEC             reduce using rule 31 (closed_stmt -> if_stmt_closed .)
    INC             reduce using rule 31 (closed_stmt -> if_stmt_closed .)
    (               reduce using rule 31 (closed_stmt -> if_stmt_closed .)
    FALSE           reduce using rule 31 (closed_stmt -> if_stmt_closed .)
    TRUE            reduce using rule 31 (closed_stmt -> if_stmt_closed .)
    STRING_LITERAL  reduce using rule 31 (closed_stmt -> if_stmt_closed .)
    CHAR_LITERAL    reduce using rule 31 (closed_stmt -> if_stmt_closed .)
    FLOAT_LITERAL   reduce using rule 31 (closed_stmt -> if_stmt_closed .)
    INTEGER_LITERAL reduce using rule 31 (closed_stmt -> if_stmt_closed .)
    $end            reduce using rule 31 (closed_stmt -> if_stmt_closed .)
    }               reduce using rule 31 (closed_stmt -> if_stmt_closed .)
    ELSE            reduce using rule 31 (closed_stmt -> if_stmt_closed .)


state 16

    (32) open_stmt -> while_stmt_open .
    ID              reduce using rule 32 (open_stmt -> while_stmt_open .)
    DO              reduce using rule 32 (open_stmt -> while_stmt_open .)
    WHILE           reduce using rule 32 (open_stmt -> while_stmt_open .)
    {               reduce using rule 32 (open_stmt -> while_stmt_open .)
    BREAK           reduce using rule 32 (open_stmt -> while_stmt_open .)
    CONTINUE        reduce using rule 32 (open_stmt -> while_stmt_open .)
    RETURN          reduce using rule 32 (open_stmt -> while_stmt_open .)
    PRINT           reduce using rule 32 (open_stmt -> while_stmt_open .)
    FOR             reduce using rule 32 (open_stmt -> while_stmt_open .)
    IF              reduce using rule 32 (open_stmt -> while_stmt_open .)
    !               reduce using rule 32 (open_stmt -> while_stmt_open .)
    +               reduce using rule 32 (open_stmt -> while_stmt_open .)
    -               reduce using rule 32 (open_stmt -> while_stmt_open .)
    DEC             reduce using rule 32 (open_stmt -> while_stmt_open .)
    INC             reduce using rule 32 (open_stmt -> while_stmt_open .)
    (               reduce using rule 32 (open_stmt -> while_stmt_open .)
    FALSE           reduce using rule 32 (open_stmt -> while_stmt_open .)
    TRUE            reduce using rule 32 (open_stmt -> while_stmt_open .)
    STRING_LITERAL  reduce using rule 32 (open_stmt -> while_stmt_open .)
    CHAR_LITERAL    reduce using rule 32 (open_stmt -> while_stmt_open .)
    FLOAT_LITERAL   reduce using rule 32 (open_stmt -> while_stmt_open .)
    INTEGER_LITERAL reduce using rule 32 (open_stmt -> while_stmt_open .)
    $end            reduce using rule 32 (open_stmt -> while_stmt_open .)
    }               reduce using rule 32 (open_stmt -> while_stmt_open .)


state 17

    (33) open_stmt -> for_stmt_open .
    ID              reduce using rule 33 (open_stmt -> for_stmt_open .)
    DO              reduce using rule 33 (open_stmt -> for_stmt_open .)
    WHILE           reduce using rule 33 (open_stmt -> for_stmt_open .)
    {               reduce using rule 33 (open_stmt -> for_stmt_open .)
    BREAK           reduce using rule 33 (open_stmt -> for_stmt_open .)
    CONTINUE        reduce using rule 33 (open_stmt -> for_stmt_open .)
    RETURN          reduce using rule 33 (open_stmt -> for_stmt_open .)
    PRINT           reduce using rule 33 (open_stmt -> for_stmt_open .)
    FOR             reduce using rule 33 (open_stmt -> for_stmt_open .)
    IF              reduce using rule 33 (open_stmt -> for_stmt_open .)
    !               reduce using rule 33 (open_stmt -> for_stmt_open .)
    +               reduce using rule 33 (open_stmt -> for_stmt_open .)
    -               reduce using rule 33 (open_stmt -> for_stmt_open .)
    DEC             reduce using rule 33 (open_stmt -> for_stmt_open .)
    INC             reduce using rule 33 (open_stmt -> for_stmt_open .)
    (               reduce using rule 33 (open_stmt -> for_stmt_open .)
    FALSE           reduce using rule 33 (open_stmt -> for_stmt_open .)
    TRUE            reduce using rule 33 (open_stmt -> for_stmt_open .)
    STRING_LITERAL  reduce using rule 33 (open_stmt -> for_stmt_open .)
    CHAR_LITERAL    reduce using rule 33 (open_stmt -> for_stmt_open .)
    FLOAT_LITERAL   reduce using rule 33 (open_stmt -> for_stmt_open .)
    INTEGER_LITERAL reduce using rule 33 (open_stmt -> for_stmt_open .)
    $end            reduce using rule 33 (open_stmt -> for_stmt_open .)
    }               reduce using rule 33 (open_stmt -> for_stmt_open .)


state 18

    (34) open_stmt -> if_stmt_open .
    ID              reduce using rule 34 (open_stmt -> if_stmt_open .)
    DO              reduce using rule 34 (open_stmt -> if_stmt_open .)
    WHILE           reduce using rule 34 (open_stmt -> if_stmt_open .)
    {               reduce using rule 34 (open_stmt -> if_stmt_open .)
    BREAK           reduce using rule 34 (open_stmt -> if_stmt_open .)
    CONTINUE        reduce using rule 34 (open_stmt -> if_stmt_open .)
    RETURN          reduce using rule 34 (open_stmt -> if_stmt_open .)
    PRINT           reduce using rule 34 (open_stmt -> if_stmt_open .)
    FOR             reduce using rule 34 (open_stmt -> if_stmt_open .)
    IF              reduce using rule 34 (open_stmt -> if_stmt_open .)
    !               reduce using rule 34 (open_stmt -> if_stmt_open .)
    +               reduce using rule 34 (open_stmt -> if_stmt_open .)
    -               reduce using rule 34 (open_stmt -> if_stmt_open .)
    DEC             reduce using rule 34 (open_stmt -> if_stmt_open .)
    INC             reduce using rule 34 (open_stmt -> if_stmt_open .)
    (               reduce using rule 34 (open_stmt -> if_stmt_open .)
    FALSE           reduce using rule 34 (open_stmt -> if_stmt_open .)
    TRUE            reduce using rule 34 (open_stmt -> if_stmt_open .)
    STRING_LITERAL  reduce using rule 34 (open_stmt -> if_stmt_open .)
    CHAR_LITERAL    reduce using rule 34 (open_stmt -> if_stmt_open .)
    FLOAT_LITERAL   reduce using rule 34 (open_stmt -> if_stmt_open .)
    INTEGER_LITERAL reduce using rule 34 (open_stmt -> if_stmt_open .)
    $end            reduce using rule 34 (open_stmt -> if_stmt_open .)
    }               reduce using rule 34 (open_stmt -> if_stmt_open .)


state 19

    (57) block_stmt -> { . stmt_list }
    (23) stmt_list -> . stmt
    (24) stmt_list -> . stmt stmt_list
    (25) stmt -> . closed_stmt
    (26) stmt -> . open_stmt
    (27) closed_stmt -> . do_while_stmt
    (28) closed_stmt -> . while_stmt_closed
    (29) closed_stmt -> . simple_stmt
    (30) closed_stmt -> . for_stmt_closed
    (31) closed_stmt -> . if_stmt_closed
    (32) open_stmt -> . while_stmt_open
    (33) open_stmt -> . for_stmt_open
    (34) open_stmt -> . if_stmt_open
    (44) do_while_stmt -> . DO closed_stmt WHILE ( expr ) ;
    (43) while_stmt_closed -> . WHILE ( opt_expr ) closed_stmt
    (45) simple_stmt -> . lval = expr ;
    (46) simple_stmt -> . expr ;
    (47) simple_stmt -> . decl
    (48) simple_stmt -> . block_stmt
    (49) simple_stmt -> . break_stmt
    (50) simple_stmt -> . continue_stmt
    (51) simple_stmt -> . return_stmt
    (52) simple_stmt -> . print_stmt
    (41) for_stmt_closed -> . for_header closed_stmt
    (36) if_stmt_closed -> . if_cond closed_stmt ELSE closed_stmt
    (42) while_stmt_open -> . WHILE ( opt_expr ) open_stmt
    (40) for_stmt_open -> . for_header open_stmt
    (37) if_stmt_open -> . if_cond closed_stmt ELSE if_stmt_open
    (38) if_stmt_open -> . if_cond stmt
    (67) lval -> . ID index
    (68) lval -> . ID
    (64) expr -> . expr1
    (8) decl -> . decl_init
    (9) decl -> . ID : type_func ;
    (10) decl -> . ID : type_array_sized ;
    (11) decl -> . ID : type_simple ;
    (57) block_stmt -> . { stmt_list }
    (56) break_stmt -> . BREAK ;
    (55) continue_stmt -> . CONTINUE ;
    (54) return_stmt -> . RETURN opt_expr ;
    (53) print_stmt -> . PRINT opt_expr_list ;
    (39) for_header -> . FOR ( opt_expr ; opt_expr ; opt_expr )
    (35) if_cond -> . IF ( expr )
    (65) expr1 -> . expr2
    (66) expr1 -> . lval = expr1
    (12) decl_init -> . ID : type_func = { opt_stmt_list }
    (13) decl_init -> . ID : type_array_sized = { opt_expr_list } ;
    (14) decl_init -> . ID : CONSTANT error
    (15) decl_init -> . ID : CONSTANT = { opt_expr_list } ;
    (16) decl_init -> . ID : CONSTANT = expr ;
    (17) decl_init -> . ID : AUTO error
    (18) decl_init -> . ID : AUTO = { opt_expr_list } ;
    (19) decl_init -> . ID : AUTO = expr ;
    (20) decl_init -> . ID : type_simple = expr ;
    (69) expr2 -> . expr3
    (70) expr2 -> . expr2 LOR expr3
    (71) expr3 -> . expr4
    (72) expr3 -> . expr3 LAND expr4
    (73) expr4 -> . expr5
    (74) expr4 -> . expr4 GE expr5
    (75) expr4 -> . expr4 GT expr5
    (76) expr4 -> . expr4 LE expr5
    (77) expr4 -> . expr4 LT expr5
    (78) expr4 -> . expr4 NE expr5
    (79) expr4 -> . expr4 EQ expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    DO              shift and go to state 21
    WHILE           shift and go to state 22
    ID              shift and go to state 68
    {               shift and go to state 19
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    RETURN          shift and go to state 35
    PRINT           shift and go to state 36
    FOR             shift and go to state 37
    IF              shift and go to state 38
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    stmt_list                      shift and go to state 65
    stmt                           shift and go to state 66
    closed_stmt                    shift and go to state 7
    open_stmt                      shift and go to state 8
    do_while_stmt                  shift and go to state 11
    while_stmt_closed              shift and go to state 12
    simple_stmt                    shift and go to state 13
    for_stmt_closed                shift and go to state 14
    if_stmt_closed                 shift and go to state 15
    while_stmt_open                shift and go to state 16
    for_stmt_open                  shift and go to state 17
    if_stmt_open                   shift and go to state 18
    expr                           shift and go to state 20
    lval                           shift and go to state 24
    decl                           shift and go to state 67
    block_stmt                     shift and go to state 25
    break_stmt                     shift and go to state 26
    continue_stmt                  shift and go to state 27
    return_stmt                    shift and go to state 28
    print_stmt                     shift and go to state 29
    for_header                     shift and go to state 30
    if_cond                        shift and go to state 31
    expr1                          shift and go to state 32
    decl_init                      shift and go to state 9
    expr2                          shift and go to state 39
    expr3                          shift and go to state 40
    expr4                          shift and go to state 41
    expr5                          shift and go to state 42
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 20

    (46) simple_stmt -> expr . ;
    ;               shift and go to state 69


state 21

    (44) do_while_stmt -> DO . closed_stmt WHILE ( expr ) ;
    (27) closed_stmt -> . do_while_stmt
    (28) closed_stmt -> . while_stmt_closed
    (29) closed_stmt -> . simple_stmt
    (30) closed_stmt -> . for_stmt_closed
    (31) closed_stmt -> . if_stmt_closed
    (44) do_while_stmt -> . DO closed_stmt WHILE ( expr ) ;
    (43) while_stmt_closed -> . WHILE ( opt_expr ) closed_stmt
    (45) simple_stmt -> . lval = expr ;
    (46) simple_stmt -> . expr ;
    (47) simple_stmt -> . decl
    (48) simple_stmt -> . block_stmt
    (49) simple_stmt -> . break_stmt
    (50) simple_stmt -> . continue_stmt
    (51) simple_stmt -> . return_stmt
    (52) simple_stmt -> . print_stmt
    (41) for_stmt_closed -> . for_header closed_stmt
    (36) if_stmt_closed -> . if_cond closed_stmt ELSE closed_stmt
    (67) lval -> . ID index
    (68) lval -> . ID
    (64) expr -> . expr1
    (8) decl -> . decl_init
    (9) decl -> . ID : type_func ;
    (10) decl -> . ID : type_array_sized ;
    (11) decl -> . ID : type_simple ;
    (57) block_stmt -> . { stmt_list }
    (56) break_stmt -> . BREAK ;
    (55) continue_stmt -> . CONTINUE ;
    (54) return_stmt -> . RETURN opt_expr ;
    (53) print_stmt -> . PRINT opt_expr_list ;
    (39) for_header -> . FOR ( opt_expr ; opt_expr ; opt_expr )
    (35) if_cond -> . IF ( expr )
    (65) expr1 -> . expr2
    (66) expr1 -> . lval = expr1
    (12) decl_init -> . ID : type_func = { opt_stmt_list }
    (13) decl_init -> . ID : type_array_sized = { opt_expr_list } ;
    (14) decl_init -> . ID : CONSTANT error
    (15) decl_init -> . ID : CONSTANT = { opt_expr_list } ;
    (16) decl_init -> . ID : CONSTANT = expr ;
    (17) decl_init -> . ID : AUTO error
    (18) decl_init -> . ID : AUTO = { opt_expr_list } ;
    (19) decl_init -> . ID : AUTO = expr ;
    (20) decl_init -> . ID : type_simple = expr ;
    (69) expr2 -> . expr3
    (70) expr2 -> . expr2 LOR expr3
    (71) expr3 -> . expr4
    (72) expr3 -> . expr3 LAND expr4
    (73) expr4 -> . expr5
    (74) expr4 -> . expr4 GE expr5
    (75) expr4 -> . expr4 GT expr5
    (76) expr4 -> . expr4 LE expr5
    (77) expr4 -> . expr4 LT expr5
    (78) expr4 -> . expr4 NE expr5
    (79) expr4 -> . expr4 EQ expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    DO              shift and go to state 21
    WHILE           shift and go to state 71
    ID              shift and go to state 68
    {               shift and go to state 19
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    RETURN          shift and go to state 35
    PRINT           shift and go to state 36
    FOR             shift and go to state 37
    IF              shift and go to state 38
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    closed_stmt                    shift and go to state 70
    expr                           shift and go to state 20
    do_while_stmt                  shift and go to state 11
    while_stmt_closed              shift and go to state 12
    simple_stmt                    shift and go to state 13
    for_stmt_closed                shift and go to state 14
    if_stmt_closed                 shift and go to state 15
    lval                           shift and go to state 24
    decl                           shift and go to state 67
    block_stmt                     shift and go to state 25
    break_stmt                     shift and go to state 26
    continue_stmt                  shift and go to state 27
    return_stmt                    shift and go to state 28
    print_stmt                     shift and go to state 29
    for_header                     shift and go to state 72
    if_cond                        shift and go to state 73
    expr1                          shift and go to state 32
    decl_init                      shift and go to state 9
    expr2                          shift and go to state 39
    expr3                          shift and go to state 40
    expr4                          shift and go to state 41
    expr5                          shift and go to state 42
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 22

    (43) while_stmt_closed -> WHILE . ( opt_expr ) closed_stmt
    (42) while_stmt_open -> WHILE . ( opt_expr ) open_stmt
    (               shift and go to state 74


state 23

    (101) group -> ( . expr )
    (64) expr -> . expr1
    (65) expr1 -> . expr2
    (66) expr1 -> . lval = expr1
    (69) expr2 -> . expr3
    (70) expr2 -> . expr2 LOR expr3
    (67) lval -> . ID index
    (68) lval -> . ID
    (71) expr3 -> . expr4
    (72) expr3 -> . expr3 LAND expr4
    (73) expr4 -> . expr5
    (74) expr4 -> . expr4 GE expr5
    (75) expr4 -> . expr4 GT expr5
    (76) expr4 -> . expr4 LE expr5
    (77) expr4 -> . expr4 LT expr5
    (78) expr4 -> . expr4 NE expr5
    (79) expr4 -> . expr4 EQ expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    ID              shift and go to state 77
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    expr                           shift and go to state 75
    expr1                          shift and go to state 32
    expr2                          shift and go to state 39
    lval                           shift and go to state 76
    expr3                          shift and go to state 40
    expr4                          shift and go to state 41
    expr5                          shift and go to state 42
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 24

    (45) simple_stmt -> lval . = expr ;
    (66) expr1 -> lval . = expr1
    =               shift and go to state 78


state 25

    (48) simple_stmt -> block_stmt .
    ID              reduce using rule 48 (simple_stmt -> block_stmt .)
    DO              reduce using rule 48 (simple_stmt -> block_stmt .)
    WHILE           reduce using rule 48 (simple_stmt -> block_stmt .)
    {               reduce using rule 48 (simple_stmt -> block_stmt .)
    BREAK           reduce using rule 48 (simple_stmt -> block_stmt .)
    CONTINUE        reduce using rule 48 (simple_stmt -> block_stmt .)
    RETURN          reduce using rule 48 (simple_stmt -> block_stmt .)
    PRINT           reduce using rule 48 (simple_stmt -> block_stmt .)
    FOR             reduce using rule 48 (simple_stmt -> block_stmt .)
    IF              reduce using rule 48 (simple_stmt -> block_stmt .)
    !               reduce using rule 48 (simple_stmt -> block_stmt .)
    +               reduce using rule 48 (simple_stmt -> block_stmt .)
    -               reduce using rule 48 (simple_stmt -> block_stmt .)
    DEC             reduce using rule 48 (simple_stmt -> block_stmt .)
    INC             reduce using rule 48 (simple_stmt -> block_stmt .)
    (               reduce using rule 48 (simple_stmt -> block_stmt .)
    FALSE           reduce using rule 48 (simple_stmt -> block_stmt .)
    TRUE            reduce using rule 48 (simple_stmt -> block_stmt .)
    STRING_LITERAL  reduce using rule 48 (simple_stmt -> block_stmt .)
    CHAR_LITERAL    reduce using rule 48 (simple_stmt -> block_stmt .)
    FLOAT_LITERAL   reduce using rule 48 (simple_stmt -> block_stmt .)
    INTEGER_LITERAL reduce using rule 48 (simple_stmt -> block_stmt .)
    $end            reduce using rule 48 (simple_stmt -> block_stmt .)
    }               reduce using rule 48 (simple_stmt -> block_stmt .)
    ELSE            reduce using rule 48 (simple_stmt -> block_stmt .)


state 26

    (49) simple_stmt -> break_stmt .
    ID              reduce using rule 49 (simple_stmt -> break_stmt .)
    DO              reduce using rule 49 (simple_stmt -> break_stmt .)
    WHILE           reduce using rule 49 (simple_stmt -> break_stmt .)
    {               reduce using rule 49 (simple_stmt -> break_stmt .)
    BREAK           reduce using rule 49 (simple_stmt -> break_stmt .)
    CONTINUE        reduce using rule 49 (simple_stmt -> break_stmt .)
    RETURN          reduce using rule 49 (simple_stmt -> break_stmt .)
    PRINT           reduce using rule 49 (simple_stmt -> break_stmt .)
    FOR             reduce using rule 49 (simple_stmt -> break_stmt .)
    IF              reduce using rule 49 (simple_stmt -> break_stmt .)
    !               reduce using rule 49 (simple_stmt -> break_stmt .)
    +               reduce using rule 49 (simple_stmt -> break_stmt .)
    -               reduce using rule 49 (simple_stmt -> break_stmt .)
    DEC             reduce using rule 49 (simple_stmt -> break_stmt .)
    INC             reduce using rule 49 (simple_stmt -> break_stmt .)
    (               reduce using rule 49 (simple_stmt -> break_stmt .)
    FALSE           reduce using rule 49 (simple_stmt -> break_stmt .)
    TRUE            reduce using rule 49 (simple_stmt -> break_stmt .)
    STRING_LITERAL  reduce using rule 49 (simple_stmt -> break_stmt .)
    CHAR_LITERAL    reduce using rule 49 (simple_stmt -> break_stmt .)
    FLOAT_LITERAL   reduce using rule 49 (simple_stmt -> break_stmt .)
    INTEGER_LITERAL reduce using rule 49 (simple_stmt -> break_stmt .)
    $end            reduce using rule 49 (simple_stmt -> break_stmt .)
    }               reduce using rule 49 (simple_stmt -> break_stmt .)
    ELSE            reduce using rule 49 (simple_stmt -> break_stmt .)


state 27

    (50) simple_stmt -> continue_stmt .
    ID              reduce using rule 50 (simple_stmt -> continue_stmt .)
    DO              reduce using rule 50 (simple_stmt -> continue_stmt .)
    WHILE           reduce using rule 50 (simple_stmt -> continue_stmt .)
    {               reduce using rule 50 (simple_stmt -> continue_stmt .)
    BREAK           reduce using rule 50 (simple_stmt -> continue_stmt .)
    CONTINUE        reduce using rule 50 (simple_stmt -> continue_stmt .)
    RETURN          reduce using rule 50 (simple_stmt -> continue_stmt .)
    PRINT           reduce using rule 50 (simple_stmt -> continue_stmt .)
    FOR             reduce using rule 50 (simple_stmt -> continue_stmt .)
    IF              reduce using rule 50 (simple_stmt -> continue_stmt .)
    !               reduce using rule 50 (simple_stmt -> continue_stmt .)
    +               reduce using rule 50 (simple_stmt -> continue_stmt .)
    -               reduce using rule 50 (simple_stmt -> continue_stmt .)
    DEC             reduce using rule 50 (simple_stmt -> continue_stmt .)
    INC             reduce using rule 50 (simple_stmt -> continue_stmt .)
    (               reduce using rule 50 (simple_stmt -> continue_stmt .)
    FALSE           reduce using rule 50 (simple_stmt -> continue_stmt .)
    TRUE            reduce using rule 50 (simple_stmt -> continue_stmt .)
    STRING_LITERAL  reduce using rule 50 (simple_stmt -> continue_stmt .)
    CHAR_LITERAL    reduce using rule 50 (simple_stmt -> continue_stmt .)
    FLOAT_LITERAL   reduce using rule 50 (simple_stmt -> continue_stmt .)
    INTEGER_LITERAL reduce using rule 50 (simple_stmt -> continue_stmt .)
    $end            reduce using rule 50 (simple_stmt -> continue_stmt .)
    }               reduce using rule 50 (simple_stmt -> continue_stmt .)
    ELSE            reduce using rule 50 (simple_stmt -> continue_stmt .)


state 28

    (51) simple_stmt -> return_stmt .
    ID              reduce using rule 51 (simple_stmt -> return_stmt .)
    DO              reduce using rule 51 (simple_stmt -> return_stmt .)
    WHILE           reduce using rule 51 (simple_stmt -> return_stmt .)
    {               reduce using rule 51 (simple_stmt -> return_stmt .)
    BREAK           reduce using rule 51 (simple_stmt -> return_stmt .)
    CONTINUE        reduce using rule 51 (simple_stmt -> return_stmt .)
    RETURN          reduce using rule 51 (simple_stmt -> return_stmt .)
    PRINT           reduce using rule 51 (simple_stmt -> return_stmt .)
    FOR             reduce using rule 51 (simple_stmt -> return_stmt .)
    IF              reduce using rule 51 (simple_stmt -> return_stmt .)
    !               reduce using rule 51 (simple_stmt -> return_stmt .)
    +               reduce using rule 51 (simple_stmt -> return_stmt .)
    -               reduce using rule 51 (simple_stmt -> return_stmt .)
    DEC             reduce using rule 51 (simple_stmt -> return_stmt .)
    INC             reduce using rule 51 (simple_stmt -> return_stmt .)
    (               reduce using rule 51 (simple_stmt -> return_stmt .)
    FALSE           reduce using rule 51 (simple_stmt -> return_stmt .)
    TRUE            reduce using rule 51 (simple_stmt -> return_stmt .)
    STRING_LITERAL  reduce using rule 51 (simple_stmt -> return_stmt .)
    CHAR_LITERAL    reduce using rule 51 (simple_stmt -> return_stmt .)
    FLOAT_LITERAL   reduce using rule 51 (simple_stmt -> return_stmt .)
    INTEGER_LITERAL reduce using rule 51 (simple_stmt -> return_stmt .)
    $end            reduce using rule 51 (simple_stmt -> return_stmt .)
    }               reduce using rule 51 (simple_stmt -> return_stmt .)
    ELSE            reduce using rule 51 (simple_stmt -> return_stmt .)


state 29

    (52) simple_stmt -> print_stmt .
    ID              reduce using rule 52 (simple_stmt -> print_stmt .)
    DO              reduce using rule 52 (simple_stmt -> print_stmt .)
    WHILE           reduce using rule 52 (simple_stmt -> print_stmt .)
    {               reduce using rule 52 (simple_stmt -> print_stmt .)
    BREAK           reduce using rule 52 (simple_stmt -> print_stmt .)
    CONTINUE        reduce using rule 52 (simple_stmt -> print_stmt .)
    RETURN          reduce using rule 52 (simple_stmt -> print_stmt .)
    PRINT           reduce using rule 52 (simple_stmt -> print_stmt .)
    FOR             reduce using rule 52 (simple_stmt -> print_stmt .)
    IF              reduce using rule 52 (simple_stmt -> print_stmt .)
    !               reduce using rule 52 (simple_stmt -> print_stmt .)
    +               reduce using rule 52 (simple_stmt -> print_stmt .)
    -               reduce using rule 52 (simple_stmt -> print_stmt .)
    DEC             reduce using rule 52 (simple_stmt -> print_stmt .)
    INC             reduce using rule 52 (simple_stmt -> print_stmt .)
    (               reduce using rule 52 (simple_stmt -> print_stmt .)
    FALSE           reduce using rule 52 (simple_stmt -> print_stmt .)
    TRUE            reduce using rule 52 (simple_stmt -> print_stmt .)
    STRING_LITERAL  reduce using rule 52 (simple_stmt -> print_stmt .)
    CHAR_LITERAL    reduce using rule 52 (simple_stmt -> print_stmt .)
    FLOAT_LITERAL   reduce using rule 52 (simple_stmt -> print_stmt .)
    INTEGER_LITERAL reduce using rule 52 (simple_stmt -> print_stmt .)
    $end            reduce using rule 52 (simple_stmt -> print_stmt .)
    }               reduce using rule 52 (simple_stmt -> print_stmt .)
    ELSE            reduce using rule 52 (simple_stmt -> print_stmt .)


state 30

    (41) for_stmt_closed -> for_header . closed_stmt
    (40) for_stmt_open -> for_header . open_stmt
    (27) closed_stmt -> . do_while_stmt
    (28) closed_stmt -> . while_stmt_closed
    (29) closed_stmt -> . simple_stmt
    (30) closed_stmt -> . for_stmt_closed
    (31) closed_stmt -> . if_stmt_closed
    (32) open_stmt -> . while_stmt_open
    (33) open_stmt -> . for_stmt_open
    (34) open_stmt -> . if_stmt_open
    (44) do_while_stmt -> . DO closed_stmt WHILE ( expr ) ;
    (43) while_stmt_closed -> . WHILE ( opt_expr ) closed_stmt
    (45) simple_stmt -> . lval = expr ;
    (46) simple_stmt -> . expr ;
    (47) simple_stmt -> . decl
    (48) simple_stmt -> . block_stmt
    (49) simple_stmt -> . break_stmt
    (50) simple_stmt -> . continue_stmt
    (51) simple_stmt -> . return_stmt
    (52) simple_stmt -> . print_stmt
    (41) for_stmt_closed -> . for_header closed_stmt
    (36) if_stmt_closed -> . if_cond closed_stmt ELSE closed_stmt
    (42) while_stmt_open -> . WHILE ( opt_expr ) open_stmt
    (40) for_stmt_open -> . for_header open_stmt
    (37) if_stmt_open -> . if_cond closed_stmt ELSE if_stmt_open
    (38) if_stmt_open -> . if_cond stmt
    (67) lval -> . ID index
    (68) lval -> . ID
    (64) expr -> . expr1
    (8) decl -> . decl_init
    (9) decl -> . ID : type_func ;
    (10) decl -> . ID : type_array_sized ;
    (11) decl -> . ID : type_simple ;
    (57) block_stmt -> . { stmt_list }
    (56) break_stmt -> . BREAK ;
    (55) continue_stmt -> . CONTINUE ;
    (54) return_stmt -> . RETURN opt_expr ;
    (53) print_stmt -> . PRINT opt_expr_list ;
    (39) for_header -> . FOR ( opt_expr ; opt_expr ; opt_expr )
    (35) if_cond -> . IF ( expr )
    (65) expr1 -> . expr2
    (66) expr1 -> . lval = expr1
    (12) decl_init -> . ID : type_func = { opt_stmt_list }
    (13) decl_init -> . ID : type_array_sized = { opt_expr_list } ;
    (14) decl_init -> . ID : CONSTANT error
    (15) decl_init -> . ID : CONSTANT = { opt_expr_list } ;
    (16) decl_init -> . ID : CONSTANT = expr ;
    (17) decl_init -> . ID : AUTO error
    (18) decl_init -> . ID : AUTO = { opt_expr_list } ;
    (19) decl_init -> . ID : AUTO = expr ;
    (20) decl_init -> . ID : type_simple = expr ;
    (69) expr2 -> . expr3
    (70) expr2 -> . expr2 LOR expr3
    (71) expr3 -> . expr4
    (72) expr3 -> . expr3 LAND expr4
    (73) expr4 -> . expr5
    (74) expr4 -> . expr4 GE expr5
    (75) expr4 -> . expr4 GT expr5
    (76) expr4 -> . expr4 LE expr5
    (77) expr4 -> . expr4 LT expr5
    (78) expr4 -> . expr4 NE expr5
    (79) expr4 -> . expr4 EQ expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    DO              shift and go to state 21
    WHILE           shift and go to state 22
    ID              shift and go to state 68
    {               shift and go to state 19
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    RETURN          shift and go to state 35
    PRINT           shift and go to state 36
    FOR             shift and go to state 37
    IF              shift and go to state 38
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    for_header                     shift and go to state 30
    closed_stmt                    shift and go to state 79
    open_stmt                      shift and go to state 80
    do_while_stmt                  shift and go to state 11
    while_stmt_closed              shift and go to state 12
    simple_stmt                    shift and go to state 13
    for_stmt_closed                shift and go to state 14
    if_stmt_closed                 shift and go to state 15
    while_stmt_open                shift and go to state 16
    for_stmt_open                  shift and go to state 17
    if_stmt_open                   shift and go to state 18
    expr                           shift and go to state 20
    lval                           shift and go to state 24
    decl                           shift and go to state 67
    block_stmt                     shift and go to state 25
    break_stmt                     shift and go to state 26
    continue_stmt                  shift and go to state 27
    return_stmt                    shift and go to state 28
    print_stmt                     shift and go to state 29
    if_cond                        shift and go to state 31
    expr1                          shift and go to state 32
    decl_init                      shift and go to state 9
    expr2                          shift and go to state 39
    expr3                          shift and go to state 40
    expr4                          shift and go to state 41
    expr5                          shift and go to state 42
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 31

    (36) if_stmt_closed -> if_cond . closed_stmt ELSE closed_stmt
    (37) if_stmt_open -> if_cond . closed_stmt ELSE if_stmt_open
    (38) if_stmt_open -> if_cond . stmt
    (27) closed_stmt -> . do_while_stmt
    (28) closed_stmt -> . while_stmt_closed
    (29) closed_stmt -> . simple_stmt
    (30) closed_stmt -> . for_stmt_closed
    (31) closed_stmt -> . if_stmt_closed
    (25) stmt -> . closed_stmt
    (26) stmt -> . open_stmt
    (44) do_while_stmt -> . DO closed_stmt WHILE ( expr ) ;
    (43) while_stmt_closed -> . WHILE ( opt_expr ) closed_stmt
    (45) simple_stmt -> . lval = expr ;
    (46) simple_stmt -> . expr ;
    (47) simple_stmt -> . decl
    (48) simple_stmt -> . block_stmt
    (49) simple_stmt -> . break_stmt
    (50) simple_stmt -> . continue_stmt
    (51) simple_stmt -> . return_stmt
    (52) simple_stmt -> . print_stmt
    (41) for_stmt_closed -> . for_header closed_stmt
    (36) if_stmt_closed -> . if_cond closed_stmt ELSE closed_stmt
    (32) open_stmt -> . while_stmt_open
    (33) open_stmt -> . for_stmt_open
    (34) open_stmt -> . if_stmt_open
    (67) lval -> . ID index
    (68) lval -> . ID
    (64) expr -> . expr1
    (8) decl -> . decl_init
    (9) decl -> . ID : type_func ;
    (10) decl -> . ID : type_array_sized ;
    (11) decl -> . ID : type_simple ;
    (57) block_stmt -> . { stmt_list }
    (56) break_stmt -> . BREAK ;
    (55) continue_stmt -> . CONTINUE ;
    (54) return_stmt -> . RETURN opt_expr ;
    (53) print_stmt -> . PRINT opt_expr_list ;
    (39) for_header -> . FOR ( opt_expr ; opt_expr ; opt_expr )
    (35) if_cond -> . IF ( expr )
    (42) while_stmt_open -> . WHILE ( opt_expr ) open_stmt
    (40) for_stmt_open -> . for_header open_stmt
    (37) if_stmt_open -> . if_cond closed_stmt ELSE if_stmt_open
    (38) if_stmt_open -> . if_cond stmt
    (65) expr1 -> . expr2
    (66) expr1 -> . lval = expr1
    (12) decl_init -> . ID : type_func = { opt_stmt_list }
    (13) decl_init -> . ID : type_array_sized = { opt_expr_list } ;
    (14) decl_init -> . ID : CONSTANT error
    (15) decl_init -> . ID : CONSTANT = { opt_expr_list } ;
    (16) decl_init -> . ID : CONSTANT = expr ;
    (17) decl_init -> . ID : AUTO error
    (18) decl_init -> . ID : AUTO = { opt_expr_list } ;
    (19) decl_init -> . ID : AUTO = expr ;
    (20) decl_init -> . ID : type_simple = expr ;
    (69) expr2 -> . expr3
    (70) expr2 -> . expr2 LOR expr3
    (71) expr3 -> . expr4
    (72) expr3 -> . expr3 LAND expr4
    (73) expr4 -> . expr5
    (74) expr4 -> . expr4 GE expr5
    (75) expr4 -> . expr4 GT expr5
    (76) expr4 -> . expr4 LE expr5
    (77) expr4 -> . expr4 LT expr5
    (78) expr4 -> . expr4 NE expr5
    (79) expr4 -> . expr4 EQ expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    DO              shift and go to state 21
    WHILE           shift and go to state 22
    ID              shift and go to state 68
    {               shift and go to state 19
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    RETURN          shift and go to state 35
    PRINT           shift and go to state 36
    FOR             shift and go to state 37
    IF              shift and go to state 38
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    if_cond                        shift and go to state 31
    closed_stmt                    shift and go to state 81
    if_stmt_open                   shift and go to state 18
    stmt                           shift and go to state 82
    do_while_stmt                  shift and go to state 11
    while_stmt_closed              shift and go to state 12
    simple_stmt                    shift and go to state 13
    for_stmt_closed                shift and go to state 14
    if_stmt_closed                 shift and go to state 15
    open_stmt                      shift and go to state 8
    expr                           shift and go to state 20
    lval                           shift and go to state 24
    decl                           shift and go to state 67
    block_stmt                     shift and go to state 25
    break_stmt                     shift and go to state 26
    continue_stmt                  shift and go to state 27
    return_stmt                    shift and go to state 28
    print_stmt                     shift and go to state 29
    for_header                     shift and go to state 30
    while_stmt_open                shift and go to state 16
    for_stmt_open                  shift and go to state 17
    expr1                          shift and go to state 32
    decl_init                      shift and go to state 9
    expr2                          shift and go to state 39
    expr3                          shift and go to state 40
    expr4                          shift and go to state 41
    expr5                          shift and go to state 42
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 32

    (64) expr -> expr1 .
    ;               reduce using rule 64 (expr -> expr1 .)
    )               reduce using rule 64 (expr -> expr1 .)
    ,               reduce using rule 64 (expr -> expr1 .)
    ]               reduce using rule 64 (expr -> expr1 .)
    }               reduce using rule 64 (expr -> expr1 .)


state 33

    (56) break_stmt -> BREAK . ;
    ;               shift and go to state 83


state 34

    (55) continue_stmt -> CONTINUE . ;
    ;               shift and go to state 84


state 35

    (54) return_stmt -> RETURN . opt_expr ;
    (62) opt_expr -> . expr
    (63) opt_expr -> . empty
    (64) expr -> . expr1
    (130) empty -> .
    (65) expr1 -> . expr2
    (66) expr1 -> . lval = expr1
    (69) expr2 -> . expr3
    (70) expr2 -> . expr2 LOR expr3
    (67) lval -> . ID index
    (68) lval -> . ID
    (71) expr3 -> . expr4
    (72) expr3 -> . expr3 LAND expr4
    (73) expr4 -> . expr5
    (74) expr4 -> . expr4 GE expr5
    (75) expr4 -> . expr4 GT expr5
    (76) expr4 -> . expr4 LE expr5
    (77) expr4 -> . expr4 LT expr5
    (78) expr4 -> . expr4 NE expr5
    (79) expr4 -> . expr4 EQ expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    ;               reduce using rule 130 (empty -> .)
    ID              shift and go to state 77
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    opt_expr                       shift and go to state 85
    expr                           shift and go to state 86
    empty                          shift and go to state 87
    expr1                          shift and go to state 32
    expr2                          shift and go to state 39
    lval                           shift and go to state 76
    expr3                          shift and go to state 40
    expr4                          shift and go to state 41
    expr5                          shift and go to state 42
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 36

    (53) print_stmt -> PRINT . opt_expr_list ;
    (58) opt_expr_list -> . expr_list
    (59) opt_expr_list -> . empty
    (60) expr_list -> . expr
    (61) expr_list -> . expr , expr_list
    (130) empty -> .
    (64) expr -> . expr1
    (65) expr1 -> . expr2
    (66) expr1 -> . lval = expr1
    (69) expr2 -> . expr3
    (70) expr2 -> . expr2 LOR expr3
    (67) lval -> . ID index
    (68) lval -> . ID
    (71) expr3 -> . expr4
    (72) expr3 -> . expr3 LAND expr4
    (73) expr4 -> . expr5
    (74) expr4 -> . expr4 GE expr5
    (75) expr4 -> . expr4 GT expr5
    (76) expr4 -> . expr4 LE expr5
    (77) expr4 -> . expr4 LT expr5
    (78) expr4 -> . expr4 NE expr5
    (79) expr4 -> . expr4 EQ expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    ;               reduce using rule 130 (empty -> .)
    ID              shift and go to state 77
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    opt_expr_list                  shift and go to state 88
    expr_list                      shift and go to state 89
    empty                          shift and go to state 90
    expr                           shift and go to state 91
    expr1                          shift and go to state 32
    expr2                          shift and go to state 39
    lval                           shift and go to state 76
    expr3                          shift and go to state 40
    expr4                          shift and go to state 41
    expr5                          shift and go to state 42
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 37

    (39) for_header -> FOR . ( opt_expr ; opt_expr ; opt_expr )
    (               shift and go to state 92


state 38

    (35) if_cond -> IF . ( expr )
    (               shift and go to state 93


state 39

    (65) expr1 -> expr2 .
    (70) expr2 -> expr2 . LOR expr3
    ;               reduce using rule 65 (expr1 -> expr2 .)
    )               reduce using rule 65 (expr1 -> expr2 .)
    ,               reduce using rule 65 (expr1 -> expr2 .)
    ]               reduce using rule 65 (expr1 -> expr2 .)
    }               reduce using rule 65 (expr1 -> expr2 .)
    LOR             shift and go to state 94


state 40

    (69) expr2 -> expr3 .
    (72) expr3 -> expr3 . LAND expr4
    LOR             reduce using rule 69 (expr2 -> expr3 .)
    ;               reduce using rule 69 (expr2 -> expr3 .)
    )               reduce using rule 69 (expr2 -> expr3 .)
    ,               reduce using rule 69 (expr2 -> expr3 .)
    ]               reduce using rule 69 (expr2 -> expr3 .)
    }               reduce using rule 69 (expr2 -> expr3 .)
    LAND            shift and go to state 95


state 41

    (71) expr3 -> expr4 .
    (74) expr4 -> expr4 . GE expr5
    (75) expr4 -> expr4 . GT expr5
    (76) expr4 -> expr4 . LE expr5
    (77) expr4 -> expr4 . LT expr5
    (78) expr4 -> expr4 . NE expr5
    (79) expr4 -> expr4 . EQ expr5
    LAND            reduce using rule 71 (expr3 -> expr4 .)
    LOR             reduce using rule 71 (expr3 -> expr4 .)
    ;               reduce using rule 71 (expr3 -> expr4 .)
    )               reduce using rule 71 (expr3 -> expr4 .)
    ,               reduce using rule 71 (expr3 -> expr4 .)
    ]               reduce using rule 71 (expr3 -> expr4 .)
    }               reduce using rule 71 (expr3 -> expr4 .)
    GE              shift and go to state 96
    GT              shift and go to state 97
    LE              shift and go to state 98
    LT              shift and go to state 99
    NE              shift and go to state 100
    EQ              shift and go to state 101


state 42

    (73) expr4 -> expr5 .
    (81) expr5 -> expr5 . - expr6
    (82) expr5 -> expr5 . + expr6
    GE              reduce using rule 73 (expr4 -> expr5 .)
    GT              reduce using rule 73 (expr4 -> expr5 .)
    LE              reduce using rule 73 (expr4 -> expr5 .)
    LT              reduce using rule 73 (expr4 -> expr5 .)
    NE              reduce using rule 73 (expr4 -> expr5 .)
    EQ              reduce using rule 73 (expr4 -> expr5 .)
    LAND            reduce using rule 73 (expr4 -> expr5 .)
    LOR             reduce using rule 73 (expr4 -> expr5 .)
    ;               reduce using rule 73 (expr4 -> expr5 .)
    )               reduce using rule 73 (expr4 -> expr5 .)
    ,               reduce using rule 73 (expr4 -> expr5 .)
    ]               reduce using rule 73 (expr4 -> expr5 .)
    }               reduce using rule 73 (expr4 -> expr5 .)
    -               shift and go to state 102
    +               shift and go to state 103


state 43

    (80) expr5 -> expr6 .
    (84) expr6 -> expr6 . % expr7
    (85) expr6 -> expr6 . / expr7
    (86) expr6 -> expr6 . * expr7
    -               reduce using rule 80 (expr5 -> expr6 .)
    +               reduce using rule 80 (expr5 -> expr6 .)
    GE              reduce using rule 80 (expr5 -> expr6 .)
    GT              reduce using rule 80 (expr5 -> expr6 .)
    LE              reduce using rule 80 (expr5 -> expr6 .)
    LT              reduce using rule 80 (expr5 -> expr6 .)
    NE              reduce using rule 80 (expr5 -> expr6 .)
    EQ              reduce using rule 80 (expr5 -> expr6 .)
    LAND            reduce using rule 80 (expr5 -> expr6 .)
    LOR             reduce using rule 80 (expr5 -> expr6 .)
    ;               reduce using rule 80 (expr5 -> expr6 .)
    )               reduce using rule 80 (expr5 -> expr6 .)
    ,               reduce using rule 80 (expr5 -> expr6 .)
    ]               reduce using rule 80 (expr5 -> expr6 .)
    }               reduce using rule 80 (expr5 -> expr6 .)
    %               shift and go to state 104
    /               shift and go to state 105
    *               shift and go to state 106


state 44

    (92) expr8 -> - . expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    ID              shift and go to state 108
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    expr8                          shift and go to state 107
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 45

    (91) expr8 -> + . expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    ID              shift and go to state 108
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    expr8                          shift and go to state 109
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 46

    (83) expr6 -> expr7 .
    (88) expr7 -> expr7 . ^ expr8
    %               reduce using rule 83 (expr6 -> expr7 .)
    /               reduce using rule 83 (expr6 -> expr7 .)
    *               reduce using rule 83 (expr6 -> expr7 .)
    -               reduce using rule 83 (expr6 -> expr7 .)
    +               reduce using rule 83 (expr6 -> expr7 .)
    GE              reduce using rule 83 (expr6 -> expr7 .)
    GT              reduce using rule 83 (expr6 -> expr7 .)
    LE              reduce using rule 83 (expr6 -> expr7 .)
    LT              reduce using rule 83 (expr6 -> expr7 .)
    NE              reduce using rule 83 (expr6 -> expr7 .)
    EQ              reduce using rule 83 (expr6 -> expr7 .)
    LAND            reduce using rule 83 (expr6 -> expr7 .)
    LOR             reduce using rule 83 (expr6 -> expr7 .)
    ;               reduce using rule 83 (expr6 -> expr7 .)
    )               reduce using rule 83 (expr6 -> expr7 .)
    ,               reduce using rule 83 (expr6 -> expr7 .)
    ]               reduce using rule 83 (expr6 -> expr7 .)
    }               reduce using rule 83 (expr6 -> expr7 .)
    ^               shift and go to state 110


state 47

    (87) expr7 -> expr8 .
    ^               reduce using rule 87 (expr7 -> expr8 .)
    %               reduce using rule 87 (expr7 -> expr8 .)
    /               reduce using rule 87 (expr7 -> expr8 .)
    *               reduce using rule 87 (expr7 -> expr8 .)
    -               reduce using rule 87 (expr7 -> expr8 .)
    +               reduce using rule 87 (expr7 -> expr8 .)
    GE              reduce using rule 87 (expr7 -> expr8 .)
    GT              reduce using rule 87 (expr7 -> expr8 .)
    LE              reduce using rule 87 (expr7 -> expr8 .)
    LT              reduce using rule 87 (expr7 -> expr8 .)
    NE              reduce using rule 87 (expr7 -> expr8 .)
    EQ              reduce using rule 87 (expr7 -> expr8 .)
    LAND            reduce using rule 87 (expr7 -> expr8 .)
    LOR             reduce using rule 87 (expr7 -> expr8 .)
    ;               reduce using rule 87 (expr7 -> expr8 .)
    )               reduce using rule 87 (expr7 -> expr8 .)
    ,               reduce using rule 87 (expr7 -> expr8 .)
    ]               reduce using rule 87 (expr7 -> expr8 .)
    }               reduce using rule 87 (expr7 -> expr8 .)


state 48

    (89) expr8 -> expr9 .
    (95) expr9 -> expr9 . DEC
    (97) expr9 -> expr9 . INC
    ^               reduce using rule 89 (expr8 -> expr9 .)
    %               reduce using rule 89 (expr8 -> expr9 .)
    /               reduce using rule 89 (expr8 -> expr9 .)
    *               reduce using rule 89 (expr8 -> expr9 .)
    -               reduce using rule 89 (expr8 -> expr9 .)
    +               reduce using rule 89 (expr8 -> expr9 .)
    GE              reduce using rule 89 (expr8 -> expr9 .)
    GT              reduce using rule 89 (expr8 -> expr9 .)
    LE              reduce using rule 89 (expr8 -> expr9 .)
    LT              reduce using rule 89 (expr8 -> expr9 .)
    NE              reduce using rule 89 (expr8 -> expr9 .)
    EQ              reduce using rule 89 (expr8 -> expr9 .)
    LAND            reduce using rule 89 (expr8 -> expr9 .)
    LOR             reduce using rule 89 (expr8 -> expr9 .)
    ;               reduce using rule 89 (expr8 -> expr9 .)
    )               reduce using rule 89 (expr8 -> expr9 .)
    ,               reduce using rule 89 (expr8 -> expr9 .)
    ]               reduce using rule 89 (expr8 -> expr9 .)
    }               reduce using rule 89 (expr8 -> expr9 .)
    DEC             shift and go to state 111
    INC             shift and go to state 112


state 49

    (90) expr8 -> ! . expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    ID              shift and go to state 108
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    expr8                          shift and go to state 113
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 50

    (93) expr9 -> group .
    DEC             reduce using rule 93 (expr9 -> group .)
    INC             reduce using rule 93 (expr9 -> group .)
    ^               reduce using rule 93 (expr9 -> group .)
    %               reduce using rule 93 (expr9 -> group .)
    /               reduce using rule 93 (expr9 -> group .)
    *               reduce using rule 93 (expr9 -> group .)
    -               reduce using rule 93 (expr9 -> group .)
    +               reduce using rule 93 (expr9 -> group .)
    GE              reduce using rule 93 (expr9 -> group .)
    GT              reduce using rule 93 (expr9 -> group .)
    LE              reduce using rule 93 (expr9 -> group .)
    LT              reduce using rule 93 (expr9 -> group .)
    NE              reduce using rule 93 (expr9 -> group .)
    EQ              reduce using rule 93 (expr9 -> group .)
    LAND            reduce using rule 93 (expr9 -> group .)
    LOR             reduce using rule 93 (expr9 -> group .)
    ;               reduce using rule 93 (expr9 -> group .)
    )               reduce using rule 93 (expr9 -> group .)
    ,               reduce using rule 93 (expr9 -> group .)
    ]               reduce using rule 93 (expr9 -> group .)
    }               reduce using rule 93 (expr9 -> group .)


state 51

    (94) expr9 -> DEC . expr9
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    DEC             shift and go to state 51
    INC             shift and go to state 52
    ID              shift and go to state 108
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    expr9                          shift and go to state 114
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 52

    (96) expr9 -> INC . expr9
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    DEC             shift and go to state 51
    INC             shift and go to state 52
    ID              shift and go to state 108
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    expr9                          shift and go to state 115
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 53

    (98) group -> factor .
    DEC             reduce using rule 98 (group -> factor .)
    INC             reduce using rule 98 (group -> factor .)
    ^               reduce using rule 98 (group -> factor .)
    %               reduce using rule 98 (group -> factor .)
    /               reduce using rule 98 (group -> factor .)
    *               reduce using rule 98 (group -> factor .)
    -               reduce using rule 98 (group -> factor .)
    +               reduce using rule 98 (group -> factor .)
    GE              reduce using rule 98 (group -> factor .)
    GT              reduce using rule 98 (group -> factor .)
    LE              reduce using rule 98 (group -> factor .)
    LT              reduce using rule 98 (group -> factor .)
    NE              reduce using rule 98 (group -> factor .)
    EQ              reduce using rule 98 (group -> factor .)
    LAND            reduce using rule 98 (group -> factor .)
    LOR             reduce using rule 98 (group -> factor .)
    ;               reduce using rule 98 (group -> factor .)
    )               reduce using rule 98 (group -> factor .)
    ,               reduce using rule 98 (group -> factor .)
    ]               reduce using rule 98 (group -> factor .)
    }               reduce using rule 98 (group -> factor .)


state 54

    (103) factor -> FALSE .
    DEC             reduce using rule 103 (factor -> FALSE .)
    INC             reduce using rule 103 (factor -> FALSE .)
    ^               reduce using rule 103 (factor -> FALSE .)
    %               reduce using rule 103 (factor -> FALSE .)
    /               reduce using rule 103 (factor -> FALSE .)
    *               reduce using rule 103 (factor -> FALSE .)
    -               reduce using rule 103 (factor -> FALSE .)
    +               reduce using rule 103 (factor -> FALSE .)
    GE              reduce using rule 103 (factor -> FALSE .)
    GT              reduce using rule 103 (factor -> FALSE .)
    LE              reduce using rule 103 (factor -> FALSE .)
    LT              reduce using rule 103 (factor -> FALSE .)
    NE              reduce using rule 103 (factor -> FALSE .)
    EQ              reduce using rule 103 (factor -> FALSE .)
    LAND            reduce using rule 103 (factor -> FALSE .)
    LOR             reduce using rule 103 (factor -> FALSE .)
    ;               reduce using rule 103 (factor -> FALSE .)
    )               reduce using rule 103 (factor -> FALSE .)
    ,               reduce using rule 103 (factor -> FALSE .)
    ]               reduce using rule 103 (factor -> FALSE .)
    }               reduce using rule 103 (factor -> FALSE .)


state 55

    (104) factor -> TRUE .
    DEC             reduce using rule 104 (factor -> TRUE .)
    INC             reduce using rule 104 (factor -> TRUE .)
    ^               reduce using rule 104 (factor -> TRUE .)
    %               reduce using rule 104 (factor -> TRUE .)
    /               reduce using rule 104 (factor -> TRUE .)
    *               reduce using rule 104 (factor -> TRUE .)
    -               reduce using rule 104 (factor -> TRUE .)
    +               reduce using rule 104 (factor -> TRUE .)
    GE              reduce using rule 104 (factor -> TRUE .)
    GT              reduce using rule 104 (factor -> TRUE .)
    LE              reduce using rule 104 (factor -> TRUE .)
    LT              reduce using rule 104 (factor -> TRUE .)
    NE              reduce using rule 104 (factor -> TRUE .)
    EQ              reduce using rule 104 (factor -> TRUE .)
    LAND            reduce using rule 104 (factor -> TRUE .)
    LOR             reduce using rule 104 (factor -> TRUE .)
    ;               reduce using rule 104 (factor -> TRUE .)
    )               reduce using rule 104 (factor -> TRUE .)
    ,               reduce using rule 104 (factor -> TRUE .)
    ]               reduce using rule 104 (factor -> TRUE .)
    }               reduce using rule 104 (factor -> TRUE .)


state 56

    (105) factor -> STRING_LITERAL .
    DEC             reduce using rule 105 (factor -> STRING_LITERAL .)
    INC             reduce using rule 105 (factor -> STRING_LITERAL .)
    ^               reduce using rule 105 (factor -> STRING_LITERAL .)
    %               reduce using rule 105 (factor -> STRING_LITERAL .)
    /               reduce using rule 105 (factor -> STRING_LITERAL .)
    *               reduce using rule 105 (factor -> STRING_LITERAL .)
    -               reduce using rule 105 (factor -> STRING_LITERAL .)
    +               reduce using rule 105 (factor -> STRING_LITERAL .)
    GE              reduce using rule 105 (factor -> STRING_LITERAL .)
    GT              reduce using rule 105 (factor -> STRING_LITERAL .)
    LE              reduce using rule 105 (factor -> STRING_LITERAL .)
    LT              reduce using rule 105 (factor -> STRING_LITERAL .)
    NE              reduce using rule 105 (factor -> STRING_LITERAL .)
    EQ              reduce using rule 105 (factor -> STRING_LITERAL .)
    LAND            reduce using rule 105 (factor -> STRING_LITERAL .)
    LOR             reduce using rule 105 (factor -> STRING_LITERAL .)
    ;               reduce using rule 105 (factor -> STRING_LITERAL .)
    )               reduce using rule 105 (factor -> STRING_LITERAL .)
    ,               reduce using rule 105 (factor -> STRING_LITERAL .)
    ]               reduce using rule 105 (factor -> STRING_LITERAL .)
    }               reduce using rule 105 (factor -> STRING_LITERAL .)


state 57

    (106) factor -> CHAR_LITERAL .
    DEC             reduce using rule 106 (factor -> CHAR_LITERAL .)
    INC             reduce using rule 106 (factor -> CHAR_LITERAL .)
    ^               reduce using rule 106 (factor -> CHAR_LITERAL .)
    %               reduce using rule 106 (factor -> CHAR_LITERAL .)
    /               reduce using rule 106 (factor -> CHAR_LITERAL .)
    *               reduce using rule 106 (factor -> CHAR_LITERAL .)
    -               reduce using rule 106 (factor -> CHAR_LITERAL .)
    +               reduce using rule 106 (factor -> CHAR_LITERAL .)
    GE              reduce using rule 106 (factor -> CHAR_LITERAL .)
    GT              reduce using rule 106 (factor -> CHAR_LITERAL .)
    LE              reduce using rule 106 (factor -> CHAR_LITERAL .)
    LT              reduce using rule 106 (factor -> CHAR_LITERAL .)
    NE              reduce using rule 106 (factor -> CHAR_LITERAL .)
    EQ              reduce using rule 106 (factor -> CHAR_LITERAL .)
    LAND            reduce using rule 106 (factor -> CHAR_LITERAL .)
    LOR             reduce using rule 106 (factor -> CHAR_LITERAL .)
    ;               reduce using rule 106 (factor -> CHAR_LITERAL .)
    )               reduce using rule 106 (factor -> CHAR_LITERAL .)
    ,               reduce using rule 106 (factor -> CHAR_LITERAL .)
    ]               reduce using rule 106 (factor -> CHAR_LITERAL .)
    }               reduce using rule 106 (factor -> CHAR_LITERAL .)


state 58

    (107) factor -> FLOAT_LITERAL .
    DEC             reduce using rule 107 (factor -> FLOAT_LITERAL .)
    INC             reduce using rule 107 (factor -> FLOAT_LITERAL .)
    ^               reduce using rule 107 (factor -> FLOAT_LITERAL .)
    %               reduce using rule 107 (factor -> FLOAT_LITERAL .)
    /               reduce using rule 107 (factor -> FLOAT_LITERAL .)
    *               reduce using rule 107 (factor -> FLOAT_LITERAL .)
    -               reduce using rule 107 (factor -> FLOAT_LITERAL .)
    +               reduce using rule 107 (factor -> FLOAT_LITERAL .)
    GE              reduce using rule 107 (factor -> FLOAT_LITERAL .)
    GT              reduce using rule 107 (factor -> FLOAT_LITERAL .)
    LE              reduce using rule 107 (factor -> FLOAT_LITERAL .)
    LT              reduce using rule 107 (factor -> FLOAT_LITERAL .)
    NE              reduce using rule 107 (factor -> FLOAT_LITERAL .)
    EQ              reduce using rule 107 (factor -> FLOAT_LITERAL .)
    LAND            reduce using rule 107 (factor -> FLOAT_LITERAL .)
    LOR             reduce using rule 107 (factor -> FLOAT_LITERAL .)
    ;               reduce using rule 107 (factor -> FLOAT_LITERAL .)
    )               reduce using rule 107 (factor -> FLOAT_LITERAL .)
    ,               reduce using rule 107 (factor -> FLOAT_LITERAL .)
    ]               reduce using rule 107 (factor -> FLOAT_LITERAL .)
    }               reduce using rule 107 (factor -> FLOAT_LITERAL .)


state 59

    (108) factor -> INTEGER_LITERAL .
    DEC             reduce using rule 108 (factor -> INTEGER_LITERAL .)
    INC             reduce using rule 108 (factor -> INTEGER_LITERAL .)
    ^               reduce using rule 108 (factor -> INTEGER_LITERAL .)
    %               reduce using rule 108 (factor -> INTEGER_LITERAL .)
    /               reduce using rule 108 (factor -> INTEGER_LITERAL .)
    *               reduce using rule 108 (factor -> INTEGER_LITERAL .)
    -               reduce using rule 108 (factor -> INTEGER_LITERAL .)
    +               reduce using rule 108 (factor -> INTEGER_LITERAL .)
    GE              reduce using rule 108 (factor -> INTEGER_LITERAL .)
    GT              reduce using rule 108 (factor -> INTEGER_LITERAL .)
    LE              reduce using rule 108 (factor -> INTEGER_LITERAL .)
    LT              reduce using rule 108 (factor -> INTEGER_LITERAL .)
    NE              reduce using rule 108 (factor -> INTEGER_LITERAL .)
    EQ              reduce using rule 108 (factor -> INTEGER_LITERAL .)
    LAND            reduce using rule 108 (factor -> INTEGER_LITERAL .)
    LOR             reduce using rule 108 (factor -> INTEGER_LITERAL .)
    ;               reduce using rule 108 (factor -> INTEGER_LITERAL .)
    )               reduce using rule 108 (factor -> INTEGER_LITERAL .)
    ,               reduce using rule 108 (factor -> INTEGER_LITERAL .)
    ]               reduce using rule 108 (factor -> INTEGER_LITERAL .)
    }               reduce using rule 108 (factor -> INTEGER_LITERAL .)


state 60

    (7) global_list -> global_item global_list .
    $end            reduce using rule 7 (global_list -> global_item global_list .)


state 61

    (9) decl -> ID : . type_func ;
    (10) decl -> ID : . type_array_sized ;
    (11) decl -> ID : . type_simple ;
    (12) decl_init -> ID : . type_func = { opt_stmt_list }
    (13) decl_init -> ID : . type_array_sized = { opt_expr_list } ;
    (14) decl_init -> ID : . CONSTANT error
    (15) decl_init -> ID : . CONSTANT = { opt_expr_list } ;
    (16) decl_init -> ID : . CONSTANT = expr ;
    (17) decl_init -> ID : . AUTO error
    (18) decl_init -> ID : . AUTO = { opt_expr_list } ;
    (19) decl_init -> ID : . AUTO = expr ;
    (20) decl_init -> ID : . type_simple = expr ;
    (120) type_func -> . FUNCTION type_array_sized ( opt_param_list )
    (121) type_func -> . FUNCTION type_array ( opt_param_list )
    (122) type_func -> . FUNCTION type_simple ( opt_param_list )
    (116) type_array_sized -> . ARRAY index type_array_sized
    (117) type_array_sized -> . ARRAY index type_simple
    (110) type_simple -> . VOID
    (111) type_simple -> . STRING
    (112) type_simple -> . CHAR
    (113) type_simple -> . BOOLEAN
    (114) type_simple -> . FLOAT
    (115) type_simple -> . INTEGER
    CONSTANT        shift and go to state 119
    AUTO            shift and go to state 120
    FUNCTION        shift and go to state 121
    ARRAY           shift and go to state 122
    VOID            shift and go to state 123
    STRING          shift and go to state 124
    CHAR            shift and go to state 125
    BOOLEAN         shift and go to state 126
    FLOAT           shift and go to state 127
    INTEGER         shift and go to state 128

    type_func                      shift and go to state 116
    type_array_sized               shift and go to state 117
    type_simple                    shift and go to state 118

state 62

    (67) lval -> ID index .
    (99) group -> ID index .
    =               reduce using rule 67 (lval -> ID index .)
    DEC             reduce using rule 99 (group -> ID index .)
    INC             reduce using rule 99 (group -> ID index .)
    ^               reduce using rule 99 (group -> ID index .)
    %               reduce using rule 99 (group -> ID index .)
    /               reduce using rule 99 (group -> ID index .)
    *               reduce using rule 99 (group -> ID index .)
    -               reduce using rule 99 (group -> ID index .)
    +               reduce using rule 99 (group -> ID index .)
    GE              reduce using rule 99 (group -> ID index .)
    GT              reduce using rule 99 (group -> ID index .)
    LE              reduce using rule 99 (group -> ID index .)
    LT              reduce using rule 99 (group -> ID index .)
    NE              reduce using rule 99 (group -> ID index .)
    EQ              reduce using rule 99 (group -> ID index .)
    LAND            reduce using rule 99 (group -> ID index .)
    LOR             reduce using rule 99 (group -> ID index .)
    ;               reduce using rule 99 (group -> ID index .)
    )               reduce using rule 99 (group -> ID index .)
    ,               reduce using rule 99 (group -> ID index .)
    ]               reduce using rule 99 (group -> ID index .)
    }               reduce using rule 99 (group -> ID index .)


state 63

    (100) group -> ID ( . opt_expr_list )
    (58) opt_expr_list -> . expr_list
    (59) opt_expr_list -> . empty
    (60) expr_list -> . expr
    (61) expr_list -> . expr , expr_list
    (130) empty -> .
    (64) expr -> . expr1
    (65) expr1 -> . expr2
    (66) expr1 -> . lval = expr1
    (69) expr2 -> . expr3
    (70) expr2 -> . expr2 LOR expr3
    (67) lval -> . ID index
    (68) lval -> . ID
    (71) expr3 -> . expr4
    (72) expr3 -> . expr3 LAND expr4
    (73) expr4 -> . expr5
    (74) expr4 -> . expr4 GE expr5
    (75) expr4 -> . expr4 GT expr5
    (76) expr4 -> . expr4 LE expr5
    (77) expr4 -> . expr4 LT expr5
    (78) expr4 -> . expr4 NE expr5
    (79) expr4 -> . expr4 EQ expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    )               reduce using rule 130 (empty -> .)
    ID              shift and go to state 77
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    opt_expr_list                  shift and go to state 129
    expr_list                      shift and go to state 89
    empty                          shift and go to state 90
    expr                           shift and go to state 91
    expr1                          shift and go to state 32
    expr2                          shift and go to state 39
    lval                           shift and go to state 76
    expr3                          shift and go to state 40
    expr4                          shift and go to state 41
    expr5                          shift and go to state 42
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 64

    (102) index -> [ . expr ]
    (64) expr -> . expr1
    (65) expr1 -> . expr2
    (66) expr1 -> . lval = expr1
    (69) expr2 -> . expr3
    (70) expr2 -> . expr2 LOR expr3
    (67) lval -> . ID index
    (68) lval -> . ID
    (71) expr3 -> . expr4
    (72) expr3 -> . expr3 LAND expr4
    (73) expr4 -> . expr5
    (74) expr4 -> . expr4 GE expr5
    (75) expr4 -> . expr4 GT expr5
    (76) expr4 -> . expr4 LE expr5
    (77) expr4 -> . expr4 LT expr5
    (78) expr4 -> . expr4 NE expr5
    (79) expr4 -> . expr4 EQ expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    ID              shift and go to state 77
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    expr                           shift and go to state 130
    expr1                          shift and go to state 32
    expr2                          shift and go to state 39
    lval                           shift and go to state 76
    expr3                          shift and go to state 40
    expr4                          shift and go to state 41
    expr5                          shift and go to state 42
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 65

    (57) block_stmt -> { stmt_list . }
    }               shift and go to state 131


state 66

    (23) stmt_list -> stmt .
    (24) stmt_list -> stmt . stmt_list
    (23) stmt_list -> . stmt
    (24) stmt_list -> . stmt stmt_list
    (25) stmt -> . closed_stmt
    (26) stmt -> . open_stmt
    (27) closed_stmt -> . do_while_stmt
    (28) closed_stmt -> . while_stmt_closed
    (29) closed_stmt -> . simple_stmt
    (30) closed_stmt -> . for_stmt_closed
    (31) closed_stmt -> . if_stmt_closed
    (32) open_stmt -> . while_stmt_open
    (33) open_stmt -> . for_stmt_open
    (34) open_stmt -> . if_stmt_open
    (44) do_while_stmt -> . DO closed_stmt WHILE ( expr ) ;
    (43) while_stmt_closed -> . WHILE ( opt_expr ) closed_stmt
    (45) simple_stmt -> . lval = expr ;
    (46) simple_stmt -> . expr ;
    (47) simple_stmt -> . decl
    (48) simple_stmt -> . block_stmt
    (49) simple_stmt -> . break_stmt
    (50) simple_stmt -> . continue_stmt
    (51) simple_stmt -> . return_stmt
    (52) simple_stmt -> . print_stmt
    (41) for_stmt_closed -> . for_header closed_stmt
    (36) if_stmt_closed -> . if_cond closed_stmt ELSE closed_stmt
    (42) while_stmt_open -> . WHILE ( opt_expr ) open_stmt
    (40) for_stmt_open -> . for_header open_stmt
    (37) if_stmt_open -> . if_cond closed_stmt ELSE if_stmt_open
    (38) if_stmt_open -> . if_cond stmt
    (67) lval -> . ID index
    (68) lval -> . ID
    (64) expr -> . expr1
    (8) decl -> . decl_init
    (9) decl -> . ID : type_func ;
    (10) decl -> . ID : type_array_sized ;
    (11) decl -> . ID : type_simple ;
    (57) block_stmt -> . { stmt_list }
    (56) break_stmt -> . BREAK ;
    (55) continue_stmt -> . CONTINUE ;
    (54) return_stmt -> . RETURN opt_expr ;
    (53) print_stmt -> . PRINT opt_expr_list ;
    (39) for_header -> . FOR ( opt_expr ; opt_expr ; opt_expr )
    (35) if_cond -> . IF ( expr )
    (65) expr1 -> . expr2
    (66) expr1 -> . lval = expr1
    (12) decl_init -> . ID : type_func = { opt_stmt_list }
    (13) decl_init -> . ID : type_array_sized = { opt_expr_list } ;
    (14) decl_init -> . ID : CONSTANT error
    (15) decl_init -> . ID : CONSTANT = { opt_expr_list } ;
    (16) decl_init -> . ID : CONSTANT = expr ;
    (17) decl_init -> . ID : AUTO error
    (18) decl_init -> . ID : AUTO = { opt_expr_list } ;
    (19) decl_init -> . ID : AUTO = expr ;
    (20) decl_init -> . ID : type_simple = expr ;
    (69) expr2 -> . expr3
    (70) expr2 -> . expr2 LOR expr3
    (71) expr3 -> . expr4
    (72) expr3 -> . expr3 LAND expr4
    (73) expr4 -> . expr5
    (74) expr4 -> . expr4 GE expr5
    (75) expr4 -> . expr4 GT expr5
    (76) expr4 -> . expr4 LE expr5
    (77) expr4 -> . expr4 LT expr5
    (78) expr4 -> . expr4 NE expr5
    (79) expr4 -> . expr4 EQ expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    }               reduce using rule 23 (stmt_list -> stmt .)
    DO              shift and go to state 21
    WHILE           shift and go to state 22
    ID              shift and go to state 68
    {               shift and go to state 19
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    RETURN          shift and go to state 35
    PRINT           shift and go to state 36
    FOR             shift and go to state 37
    IF              shift and go to state 38
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    stmt                           shift and go to state 66
    stmt_list                      shift and go to state 132
    closed_stmt                    shift and go to state 7
    open_stmt                      shift and go to state 8
    do_while_stmt                  shift and go to state 11
    while_stmt_closed              shift and go to state 12
    simple_stmt                    shift and go to state 13
    for_stmt_closed                shift and go to state 14
    if_stmt_closed                 shift and go to state 15
    while_stmt_open                shift and go to state 16
    for_stmt_open                  shift and go to state 17
    if_stmt_open                   shift and go to state 18
    expr                           shift and go to state 20
    lval                           shift and go to state 24
    decl                           shift and go to state 67
    block_stmt                     shift and go to state 25
    break_stmt                     shift and go to state 26
    continue_stmt                  shift and go to state 27
    return_stmt                    shift and go to state 28
    print_stmt                     shift and go to state 29
    for_header                     shift and go to state 30
    if_cond                        shift and go to state 31
    expr1                          shift and go to state 32
    decl_init                      shift and go to state 9
    expr2                          shift and go to state 39
    expr3                          shift and go to state 40
    expr4                          shift and go to state 41
    expr5                          shift and go to state 42
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 67

    (47) simple_stmt -> decl .
    DO              reduce using rule 47 (simple_stmt -> decl .)
    WHILE           reduce using rule 47 (simple_stmt -> decl .)
    ID              reduce using rule 47 (simple_stmt -> decl .)
    {               reduce using rule 47 (simple_stmt -> decl .)
    BREAK           reduce using rule 47 (simple_stmt -> decl .)
    CONTINUE        reduce using rule 47 (simple_stmt -> decl .)
    RETURN          reduce using rule 47 (simple_stmt -> decl .)
    PRINT           reduce using rule 47 (simple_stmt -> decl .)
    FOR             reduce using rule 47 (simple_stmt -> decl .)
    IF              reduce using rule 47 (simple_stmt -> decl .)
    !               reduce using rule 47 (simple_stmt -> decl .)
    +               reduce using rule 47 (simple_stmt -> decl .)
    -               reduce using rule 47 (simple_stmt -> decl .)
    DEC             reduce using rule 47 (simple_stmt -> decl .)
    INC             reduce using rule 47 (simple_stmt -> decl .)
    (               reduce using rule 47 (simple_stmt -> decl .)
    FALSE           reduce using rule 47 (simple_stmt -> decl .)
    TRUE            reduce using rule 47 (simple_stmt -> decl .)
    STRING_LITERAL  reduce using rule 47 (simple_stmt -> decl .)
    CHAR_LITERAL    reduce using rule 47 (simple_stmt -> decl .)
    FLOAT_LITERAL   reduce using rule 47 (simple_stmt -> decl .)
    INTEGER_LITERAL reduce using rule 47 (simple_stmt -> decl .)
    }               reduce using rule 47 (simple_stmt -> decl .)
    $end            reduce using rule 47 (simple_stmt -> decl .)
    ELSE            reduce using rule 47 (simple_stmt -> decl .)


state 68

    (67) lval -> ID . index
    (68) lval -> ID .
    (9) decl -> ID . : type_func ;
    (10) decl -> ID . : type_array_sized ;
    (11) decl -> ID . : type_simple ;
    (12) decl_init -> ID . : type_func = { opt_stmt_list }
    (13) decl_init -> ID . : type_array_sized = { opt_expr_list } ;
    (14) decl_init -> ID . : CONSTANT error
    (15) decl_init -> ID . : CONSTANT = { opt_expr_list } ;
    (16) decl_init -> ID . : CONSTANT = expr ;
    (17) decl_init -> ID . : AUTO error
    (18) decl_init -> ID . : AUTO = { opt_expr_list } ;
    (19) decl_init -> ID . : AUTO = expr ;
    (20) decl_init -> ID . : type_simple = expr ;
    (99) group -> ID . index
    (100) group -> ID . ( opt_expr_list )
    (109) factor -> ID .
    (102) index -> . [ expr ]
    =               reduce using rule 68 (lval -> ID .)
    :               shift and go to state 61
    (               shift and go to state 63
    DEC             reduce using rule 109 (factor -> ID .)
    INC             reduce using rule 109 (factor -> ID .)
    ^               reduce using rule 109 (factor -> ID .)
    %               reduce using rule 109 (factor -> ID .)
    /               reduce using rule 109 (factor -> ID .)
    *               reduce using rule 109 (factor -> ID .)
    -               reduce using rule 109 (factor -> ID .)
    +               reduce using rule 109 (factor -> ID .)
    GE              reduce using rule 109 (factor -> ID .)
    GT              reduce using rule 109 (factor -> ID .)
    LE              reduce using rule 109 (factor -> ID .)
    LT              reduce using rule 109 (factor -> ID .)
    NE              reduce using rule 109 (factor -> ID .)
    EQ              reduce using rule 109 (factor -> ID .)
    LAND            reduce using rule 109 (factor -> ID .)
    LOR             reduce using rule 109 (factor -> ID .)
    ;               reduce using rule 109 (factor -> ID .)
    [               shift and go to state 64

    index                          shift and go to state 62

state 69

    (46) simple_stmt -> expr ; .
    ID              reduce using rule 46 (simple_stmt -> expr ; .)
    DO              reduce using rule 46 (simple_stmt -> expr ; .)
    WHILE           reduce using rule 46 (simple_stmt -> expr ; .)
    {               reduce using rule 46 (simple_stmt -> expr ; .)
    BREAK           reduce using rule 46 (simple_stmt -> expr ; .)
    CONTINUE        reduce using rule 46 (simple_stmt -> expr ; .)
    RETURN          reduce using rule 46 (simple_stmt -> expr ; .)
    PRINT           reduce using rule 46 (simple_stmt -> expr ; .)
    FOR             reduce using rule 46 (simple_stmt -> expr ; .)
    IF              reduce using rule 46 (simple_stmt -> expr ; .)
    !               reduce using rule 46 (simple_stmt -> expr ; .)
    +               reduce using rule 46 (simple_stmt -> expr ; .)
    -               reduce using rule 46 (simple_stmt -> expr ; .)
    DEC             reduce using rule 46 (simple_stmt -> expr ; .)
    INC             reduce using rule 46 (simple_stmt -> expr ; .)
    (               reduce using rule 46 (simple_stmt -> expr ; .)
    FALSE           reduce using rule 46 (simple_stmt -> expr ; .)
    TRUE            reduce using rule 46 (simple_stmt -> expr ; .)
    STRING_LITERAL  reduce using rule 46 (simple_stmt -> expr ; .)
    CHAR_LITERAL    reduce using rule 46 (simple_stmt -> expr ; .)
    FLOAT_LITERAL   reduce using rule 46 (simple_stmt -> expr ; .)
    INTEGER_LITERAL reduce using rule 46 (simple_stmt -> expr ; .)
    $end            reduce using rule 46 (simple_stmt -> expr ; .)
    }               reduce using rule 46 (simple_stmt -> expr ; .)
    ELSE            reduce using rule 46 (simple_stmt -> expr ; .)


state 70

    (44) do_while_stmt -> DO closed_stmt . WHILE ( expr ) ;
    WHILE           shift and go to state 133


state 71

    (43) while_stmt_closed -> WHILE . ( opt_expr ) closed_stmt
    (               shift and go to state 134


state 72

    (41) for_stmt_closed -> for_header . closed_stmt
    (27) closed_stmt -> . do_while_stmt
    (28) closed_stmt -> . while_stmt_closed
    (29) closed_stmt -> . simple_stmt
    (30) closed_stmt -> . for_stmt_closed
    (31) closed_stmt -> . if_stmt_closed
    (44) do_while_stmt -> . DO closed_stmt WHILE ( expr ) ;
    (43) while_stmt_closed -> . WHILE ( opt_expr ) closed_stmt
    (45) simple_stmt -> . lval = expr ;
    (46) simple_stmt -> . expr ;
    (47) simple_stmt -> . decl
    (48) simple_stmt -> . block_stmt
    (49) simple_stmt -> . break_stmt
    (50) simple_stmt -> . continue_stmt
    (51) simple_stmt -> . return_stmt
    (52) simple_stmt -> . print_stmt
    (41) for_stmt_closed -> . for_header closed_stmt
    (36) if_stmt_closed -> . if_cond closed_stmt ELSE closed_stmt
    (67) lval -> . ID index
    (68) lval -> . ID
    (64) expr -> . expr1
    (8) decl -> . decl_init
    (9) decl -> . ID : type_func ;
    (10) decl -> . ID : type_array_sized ;
    (11) decl -> . ID : type_simple ;
    (57) block_stmt -> . { stmt_list }
    (56) break_stmt -> . BREAK ;
    (55) continue_stmt -> . CONTINUE ;
    (54) return_stmt -> . RETURN opt_expr ;
    (53) print_stmt -> . PRINT opt_expr_list ;
    (39) for_header -> . FOR ( opt_expr ; opt_expr ; opt_expr )
    (35) if_cond -> . IF ( expr )
    (65) expr1 -> . expr2
    (66) expr1 -> . lval = expr1
    (12) decl_init -> . ID : type_func = { opt_stmt_list }
    (13) decl_init -> . ID : type_array_sized = { opt_expr_list } ;
    (14) decl_init -> . ID : CONSTANT error
    (15) decl_init -> . ID : CONSTANT = { opt_expr_list } ;
    (16) decl_init -> . ID : CONSTANT = expr ;
    (17) decl_init -> . ID : AUTO error
    (18) decl_init -> . ID : AUTO = { opt_expr_list } ;
    (19) decl_init -> . ID : AUTO = expr ;
    (20) decl_init -> . ID : type_simple = expr ;
    (69) expr2 -> . expr3
    (70) expr2 -> . expr2 LOR expr3
    (71) expr3 -> . expr4
    (72) expr3 -> . expr3 LAND expr4
    (73) expr4 -> . expr5
    (74) expr4 -> . expr4 GE expr5
    (75) expr4 -> . expr4 GT expr5
    (76) expr4 -> . expr4 LE expr5
    (77) expr4 -> . expr4 LT expr5
    (78) expr4 -> . expr4 NE expr5
    (79) expr4 -> . expr4 EQ expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    DO              shift and go to state 21
    WHILE           shift and go to state 71
    ID              shift and go to state 68
    {               shift and go to state 19
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    RETURN          shift and go to state 35
    PRINT           shift and go to state 36
    FOR             shift and go to state 37
    IF              shift and go to state 38
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    for_header                     shift and go to state 72
    closed_stmt                    shift and go to state 79
    do_while_stmt                  shift and go to state 11
    while_stmt_closed              shift and go to state 12
    simple_stmt                    shift and go to state 13
    for_stmt_closed                shift and go to state 14
    if_stmt_closed                 shift and go to state 15
    expr                           shift and go to state 20
    lval                           shift and go to state 24
    decl                           shift and go to state 67
    block_stmt                     shift and go to state 25
    break_stmt                     shift and go to state 26
    continue_stmt                  shift and go to state 27
    return_stmt                    shift and go to state 28
    print_stmt                     shift and go to state 29
    if_cond                        shift and go to state 73
    expr1                          shift and go to state 32
    decl_init                      shift and go to state 9
    expr2                          shift and go to state 39
    expr3                          shift and go to state 40
    expr4                          shift and go to state 41
    expr5                          shift and go to state 42
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 73

    (36) if_stmt_closed -> if_cond . closed_stmt ELSE closed_stmt
    (27) closed_stmt -> . do_while_stmt
    (28) closed_stmt -> . while_stmt_closed
    (29) closed_stmt -> . simple_stmt
    (30) closed_stmt -> . for_stmt_closed
    (31) closed_stmt -> . if_stmt_closed
    (44) do_while_stmt -> . DO closed_stmt WHILE ( expr ) ;
    (43) while_stmt_closed -> . WHILE ( opt_expr ) closed_stmt
    (45) simple_stmt -> . lval = expr ;
    (46) simple_stmt -> . expr ;
    (47) simple_stmt -> . decl
    (48) simple_stmt -> . block_stmt
    (49) simple_stmt -> . break_stmt
    (50) simple_stmt -> . continue_stmt
    (51) simple_stmt -> . return_stmt
    (52) simple_stmt -> . print_stmt
    (41) for_stmt_closed -> . for_header closed_stmt
    (36) if_stmt_closed -> . if_cond closed_stmt ELSE closed_stmt
    (67) lval -> . ID index
    (68) lval -> . ID
    (64) expr -> . expr1
    (8) decl -> . decl_init
    (9) decl -> . ID : type_func ;
    (10) decl -> . ID : type_array_sized ;
    (11) decl -> . ID : type_simple ;
    (57) block_stmt -> . { stmt_list }
    (56) break_stmt -> . BREAK ;
    (55) continue_stmt -> . CONTINUE ;
    (54) return_stmt -> . RETURN opt_expr ;
    (53) print_stmt -> . PRINT opt_expr_list ;
    (39) for_header -> . FOR ( opt_expr ; opt_expr ; opt_expr )
    (35) if_cond -> . IF ( expr )
    (65) expr1 -> . expr2
    (66) expr1 -> . lval = expr1
    (12) decl_init -> . ID : type_func = { opt_stmt_list }
    (13) decl_init -> . ID : type_array_sized = { opt_expr_list } ;
    (14) decl_init -> . ID : CONSTANT error
    (15) decl_init -> . ID : CONSTANT = { opt_expr_list } ;
    (16) decl_init -> . ID : CONSTANT = expr ;
    (17) decl_init -> . ID : AUTO error
    (18) decl_init -> . ID : AUTO = { opt_expr_list } ;
    (19) decl_init -> . ID : AUTO = expr ;
    (20) decl_init -> . ID : type_simple = expr ;
    (69) expr2 -> . expr3
    (70) expr2 -> . expr2 LOR expr3
    (71) expr3 -> . expr4
    (72) expr3 -> . expr3 LAND expr4
    (73) expr4 -> . expr5
    (74) expr4 -> . expr4 GE expr5
    (75) expr4 -> . expr4 GT expr5
    (76) expr4 -> . expr4 LE expr5
    (77) expr4 -> . expr4 LT expr5
    (78) expr4 -> . expr4 NE expr5
    (79) expr4 -> . expr4 EQ expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    DO              shift and go to state 21
    WHILE           shift and go to state 71
    ID              shift and go to state 68
    {               shift and go to state 19
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    RETURN          shift and go to state 35
    PRINT           shift and go to state 36
    FOR             shift and go to state 37
    IF              shift and go to state 38
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    if_cond                        shift and go to state 73
    closed_stmt                    shift and go to state 135
    do_while_stmt                  shift and go to state 11
    while_stmt_closed              shift and go to state 12
    simple_stmt                    shift and go to state 13
    for_stmt_closed                shift and go to state 14
    if_stmt_closed                 shift and go to state 15
    expr                           shift and go to state 20
    lval                           shift and go to state 24
    decl                           shift and go to state 67
    block_stmt                     shift and go to state 25
    break_stmt                     shift and go to state 26
    continue_stmt                  shift and go to state 27
    return_stmt                    shift and go to state 28
    print_stmt                     shift and go to state 29
    for_header                     shift and go to state 72
    expr1                          shift and go to state 32
    decl_init                      shift and go to state 9
    expr2                          shift and go to state 39
    expr3                          shift and go to state 40
    expr4                          shift and go to state 41
    expr5                          shift and go to state 42
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 74

    (43) while_stmt_closed -> WHILE ( . opt_expr ) closed_stmt
    (42) while_stmt_open -> WHILE ( . opt_expr ) open_stmt
    (62) opt_expr -> . expr
    (63) opt_expr -> . empty
    (64) expr -> . expr1
    (130) empty -> .
    (65) expr1 -> . expr2
    (66) expr1 -> . lval = expr1
    (69) expr2 -> . expr3
    (70) expr2 -> . expr2 LOR expr3
    (67) lval -> . ID index
    (68) lval -> . ID
    (71) expr3 -> . expr4
    (72) expr3 -> . expr3 LAND expr4
    (73) expr4 -> . expr5
    (74) expr4 -> . expr4 GE expr5
    (75) expr4 -> . expr4 GT expr5
    (76) expr4 -> . expr4 LE expr5
    (77) expr4 -> . expr4 LT expr5
    (78) expr4 -> . expr4 NE expr5
    (79) expr4 -> . expr4 EQ expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    )               reduce using rule 130 (empty -> .)
    ID              shift and go to state 77
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    opt_expr                       shift and go to state 136
    expr                           shift and go to state 86
    empty                          shift and go to state 87
    expr1                          shift and go to state 32
    expr2                          shift and go to state 39
    lval                           shift and go to state 76
    expr3                          shift and go to state 40
    expr4                          shift and go to state 41
    expr5                          shift and go to state 42
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 75

    (101) group -> ( expr . )
    )               shift and go to state 137


state 76

    (66) expr1 -> lval . = expr1
    =               shift and go to state 138


state 77

    (67) lval -> ID . index
    (68) lval -> ID .
    (99) group -> ID . index
    (100) group -> ID . ( opt_expr_list )
    (109) factor -> ID .
    (102) index -> . [ expr ]
    =               reduce using rule 68 (lval -> ID .)
    (               shift and go to state 63
    DEC             reduce using rule 109 (factor -> ID .)
    INC             reduce using rule 109 (factor -> ID .)
    ^               reduce using rule 109 (factor -> ID .)
    %               reduce using rule 109 (factor -> ID .)
    /               reduce using rule 109 (factor -> ID .)
    *               reduce using rule 109 (factor -> ID .)
    -               reduce using rule 109 (factor -> ID .)
    +               reduce using rule 109 (factor -> ID .)
    GE              reduce using rule 109 (factor -> ID .)
    GT              reduce using rule 109 (factor -> ID .)
    LE              reduce using rule 109 (factor -> ID .)
    LT              reduce using rule 109 (factor -> ID .)
    NE              reduce using rule 109 (factor -> ID .)
    EQ              reduce using rule 109 (factor -> ID .)
    LAND            reduce using rule 109 (factor -> ID .)
    LOR             reduce using rule 109 (factor -> ID .)
    )               reduce using rule 109 (factor -> ID .)
    ;               reduce using rule 109 (factor -> ID .)
    ,               reduce using rule 109 (factor -> ID .)
    ]               reduce using rule 109 (factor -> ID .)
    }               reduce using rule 109 (factor -> ID .)
    [               shift and go to state 64

    index                          shift and go to state 62

state 78

    (45) simple_stmt -> lval = . expr ;
    (66) expr1 -> lval = . expr1
    (64) expr -> . expr1
    (65) expr1 -> . expr2
    (66) expr1 -> . lval = expr1
    (69) expr2 -> . expr3
    (70) expr2 -> . expr2 LOR expr3
    (67) lval -> . ID index
    (68) lval -> . ID
    (71) expr3 -> . expr4
    (72) expr3 -> . expr3 LAND expr4
    (73) expr4 -> . expr5
    (74) expr4 -> . expr4 GE expr5
    (75) expr4 -> . expr4 GT expr5
    (76) expr4 -> . expr4 LE expr5
    (77) expr4 -> . expr4 LT expr5
    (78) expr4 -> . expr4 NE expr5
    (79) expr4 -> . expr4 EQ expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    ID              shift and go to state 77
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    lval                           shift and go to state 76
    expr                           shift and go to state 139
    expr1                          shift and go to state 140
    expr2                          shift and go to state 39
    expr3                          shift and go to state 40
    expr4                          shift and go to state 41
    expr5                          shift and go to state 42
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 79

    (41) for_stmt_closed -> for_header closed_stmt .
    ID              reduce using rule 41 (for_stmt_closed -> for_header closed_stmt .)
    DO              reduce using rule 41 (for_stmt_closed -> for_header closed_stmt .)
    WHILE           reduce using rule 41 (for_stmt_closed -> for_header closed_stmt .)
    {               reduce using rule 41 (for_stmt_closed -> for_header closed_stmt .)
    BREAK           reduce using rule 41 (for_stmt_closed -> for_header closed_stmt .)
    CONTINUE        reduce using rule 41 (for_stmt_closed -> for_header closed_stmt .)
    RETURN          reduce using rule 41 (for_stmt_closed -> for_header closed_stmt .)
    PRINT           reduce using rule 41 (for_stmt_closed -> for_header closed_stmt .)
    FOR             reduce using rule 41 (for_stmt_closed -> for_header closed_stmt .)
    IF              reduce using rule 41 (for_stmt_closed -> for_header closed_stmt .)
    !               reduce using rule 41 (for_stmt_closed -> for_header closed_stmt .)
    +               reduce using rule 41 (for_stmt_closed -> for_header closed_stmt .)
    -               reduce using rule 41 (for_stmt_closed -> for_header closed_stmt .)
    DEC             reduce using rule 41 (for_stmt_closed -> for_header closed_stmt .)
    INC             reduce using rule 41 (for_stmt_closed -> for_header closed_stmt .)
    (               reduce using rule 41 (for_stmt_closed -> for_header closed_stmt .)
    FALSE           reduce using rule 41 (for_stmt_closed -> for_header closed_stmt .)
    TRUE            reduce using rule 41 (for_stmt_closed -> for_header closed_stmt .)
    STRING_LITERAL  reduce using rule 41 (for_stmt_closed -> for_header closed_stmt .)
    CHAR_LITERAL    reduce using rule 41 (for_stmt_closed -> for_header closed_stmt .)
    FLOAT_LITERAL   reduce using rule 41 (for_stmt_closed -> for_header closed_stmt .)
    INTEGER_LITERAL reduce using rule 41 (for_stmt_closed -> for_header closed_stmt .)
    $end            reduce using rule 41 (for_stmt_closed -> for_header closed_stmt .)
    }               reduce using rule 41 (for_stmt_closed -> for_header closed_stmt .)
    ELSE            reduce using rule 41 (for_stmt_closed -> for_header closed_stmt .)


state 80

    (40) for_stmt_open -> for_header open_stmt .
    ID              reduce using rule 40 (for_stmt_open -> for_header open_stmt .)
    DO              reduce using rule 40 (for_stmt_open -> for_header open_stmt .)
    WHILE           reduce using rule 40 (for_stmt_open -> for_header open_stmt .)
    {               reduce using rule 40 (for_stmt_open -> for_header open_stmt .)
    BREAK           reduce using rule 40 (for_stmt_open -> for_header open_stmt .)
    CONTINUE        reduce using rule 40 (for_stmt_open -> for_header open_stmt .)
    RETURN          reduce using rule 40 (for_stmt_open -> for_header open_stmt .)
    PRINT           reduce using rule 40 (for_stmt_open -> for_header open_stmt .)
    FOR             reduce using rule 40 (for_stmt_open -> for_header open_stmt .)
    IF              reduce using rule 40 (for_stmt_open -> for_header open_stmt .)
    !               reduce using rule 40 (for_stmt_open -> for_header open_stmt .)
    +               reduce using rule 40 (for_stmt_open -> for_header open_stmt .)
    -               reduce using rule 40 (for_stmt_open -> for_header open_stmt .)
    DEC             reduce using rule 40 (for_stmt_open -> for_header open_stmt .)
    INC             reduce using rule 40 (for_stmt_open -> for_header open_stmt .)
    (               reduce using rule 40 (for_stmt_open -> for_header open_stmt .)
    FALSE           reduce using rule 40 (for_stmt_open -> for_header open_stmt .)
    TRUE            reduce using rule 40 (for_stmt_open -> for_header open_stmt .)
    STRING_LITERAL  reduce using rule 40 (for_stmt_open -> for_header open_stmt .)
    CHAR_LITERAL    reduce using rule 40 (for_stmt_open -> for_header open_stmt .)
    FLOAT_LITERAL   reduce using rule 40 (for_stmt_open -> for_header open_stmt .)
    INTEGER_LITERAL reduce using rule 40 (for_stmt_open -> for_header open_stmt .)
    $end            reduce using rule 40 (for_stmt_open -> for_header open_stmt .)
    }               reduce using rule 40 (for_stmt_open -> for_header open_stmt .)


state 81

    (36) if_stmt_closed -> if_cond closed_stmt . ELSE closed_stmt
    (37) if_stmt_open -> if_cond closed_stmt . ELSE if_stmt_open
    (25) stmt -> closed_stmt .
    ELSE            shift and go to state 141
    ID              reduce using rule 25 (stmt -> closed_stmt .)
    DO              reduce using rule 25 (stmt -> closed_stmt .)
    WHILE           reduce using rule 25 (stmt -> closed_stmt .)
    {               reduce using rule 25 (stmt -> closed_stmt .)
    BREAK           reduce using rule 25 (stmt -> closed_stmt .)
    CONTINUE        reduce using rule 25 (stmt -> closed_stmt .)
    RETURN          reduce using rule 25 (stmt -> closed_stmt .)
    PRINT           reduce using rule 25 (stmt -> closed_stmt .)
    FOR             reduce using rule 25 (stmt -> closed_stmt .)
    IF              reduce using rule 25 (stmt -> closed_stmt .)
    !               reduce using rule 25 (stmt -> closed_stmt .)
    +               reduce using rule 25 (stmt -> closed_stmt .)
    -               reduce using rule 25 (stmt -> closed_stmt .)
    DEC             reduce using rule 25 (stmt -> closed_stmt .)
    INC             reduce using rule 25 (stmt -> closed_stmt .)
    (               reduce using rule 25 (stmt -> closed_stmt .)
    FALSE           reduce using rule 25 (stmt -> closed_stmt .)
    TRUE            reduce using rule 25 (stmt -> closed_stmt .)
    STRING_LITERAL  reduce using rule 25 (stmt -> closed_stmt .)
    CHAR_LITERAL    reduce using rule 25 (stmt -> closed_stmt .)
    FLOAT_LITERAL   reduce using rule 25 (stmt -> closed_stmt .)
    INTEGER_LITERAL reduce using rule 25 (stmt -> closed_stmt .)
    $end            reduce using rule 25 (stmt -> closed_stmt .)
    }               reduce using rule 25 (stmt -> closed_stmt .)


state 82

    (38) if_stmt_open -> if_cond stmt .
    ID              reduce using rule 38 (if_stmt_open -> if_cond stmt .)
    DO              reduce using rule 38 (if_stmt_open -> if_cond stmt .)
    WHILE           reduce using rule 38 (if_stmt_open -> if_cond stmt .)
    {               reduce using rule 38 (if_stmt_open -> if_cond stmt .)
    BREAK           reduce using rule 38 (if_stmt_open -> if_cond stmt .)
    CONTINUE        reduce using rule 38 (if_stmt_open -> if_cond stmt .)
    RETURN          reduce using rule 38 (if_stmt_open -> if_cond stmt .)
    PRINT           reduce using rule 38 (if_stmt_open -> if_cond stmt .)
    FOR             reduce using rule 38 (if_stmt_open -> if_cond stmt .)
    IF              reduce using rule 38 (if_stmt_open -> if_cond stmt .)
    !               reduce using rule 38 (if_stmt_open -> if_cond stmt .)
    +               reduce using rule 38 (if_stmt_open -> if_cond stmt .)
    -               reduce using rule 38 (if_stmt_open -> if_cond stmt .)
    DEC             reduce using rule 38 (if_stmt_open -> if_cond stmt .)
    INC             reduce using rule 38 (if_stmt_open -> if_cond stmt .)
    (               reduce using rule 38 (if_stmt_open -> if_cond stmt .)
    FALSE           reduce using rule 38 (if_stmt_open -> if_cond stmt .)
    TRUE            reduce using rule 38 (if_stmt_open -> if_cond stmt .)
    STRING_LITERAL  reduce using rule 38 (if_stmt_open -> if_cond stmt .)
    CHAR_LITERAL    reduce using rule 38 (if_stmt_open -> if_cond stmt .)
    FLOAT_LITERAL   reduce using rule 38 (if_stmt_open -> if_cond stmt .)
    INTEGER_LITERAL reduce using rule 38 (if_stmt_open -> if_cond stmt .)
    $end            reduce using rule 38 (if_stmt_open -> if_cond stmt .)
    }               reduce using rule 38 (if_stmt_open -> if_cond stmt .)


state 83

    (56) break_stmt -> BREAK ; .
    ID              reduce using rule 56 (break_stmt -> BREAK ; .)
    DO              reduce using rule 56 (break_stmt -> BREAK ; .)
    WHILE           reduce using rule 56 (break_stmt -> BREAK ; .)
    {               reduce using rule 56 (break_stmt -> BREAK ; .)
    BREAK           reduce using rule 56 (break_stmt -> BREAK ; .)
    CONTINUE        reduce using rule 56 (break_stmt -> BREAK ; .)
    RETURN          reduce using rule 56 (break_stmt -> BREAK ; .)
    PRINT           reduce using rule 56 (break_stmt -> BREAK ; .)
    FOR             reduce using rule 56 (break_stmt -> BREAK ; .)
    IF              reduce using rule 56 (break_stmt -> BREAK ; .)
    !               reduce using rule 56 (break_stmt -> BREAK ; .)
    +               reduce using rule 56 (break_stmt -> BREAK ; .)
    -               reduce using rule 56 (break_stmt -> BREAK ; .)
    DEC             reduce using rule 56 (break_stmt -> BREAK ; .)
    INC             reduce using rule 56 (break_stmt -> BREAK ; .)
    (               reduce using rule 56 (break_stmt -> BREAK ; .)
    FALSE           reduce using rule 56 (break_stmt -> BREAK ; .)
    TRUE            reduce using rule 56 (break_stmt -> BREAK ; .)
    STRING_LITERAL  reduce using rule 56 (break_stmt -> BREAK ; .)
    CHAR_LITERAL    reduce using rule 56 (break_stmt -> BREAK ; .)
    FLOAT_LITERAL   reduce using rule 56 (break_stmt -> BREAK ; .)
    INTEGER_LITERAL reduce using rule 56 (break_stmt -> BREAK ; .)
    $end            reduce using rule 56 (break_stmt -> BREAK ; .)
    }               reduce using rule 56 (break_stmt -> BREAK ; .)
    ELSE            reduce using rule 56 (break_stmt -> BREAK ; .)


state 84

    (55) continue_stmt -> CONTINUE ; .
    ID              reduce using rule 55 (continue_stmt -> CONTINUE ; .)
    DO              reduce using rule 55 (continue_stmt -> CONTINUE ; .)
    WHILE           reduce using rule 55 (continue_stmt -> CONTINUE ; .)
    {               reduce using rule 55 (continue_stmt -> CONTINUE ; .)
    BREAK           reduce using rule 55 (continue_stmt -> CONTINUE ; .)
    CONTINUE        reduce using rule 55 (continue_stmt -> CONTINUE ; .)
    RETURN          reduce using rule 55 (continue_stmt -> CONTINUE ; .)
    PRINT           reduce using rule 55 (continue_stmt -> CONTINUE ; .)
    FOR             reduce using rule 55 (continue_stmt -> CONTINUE ; .)
    IF              reduce using rule 55 (continue_stmt -> CONTINUE ; .)
    !               reduce using rule 55 (continue_stmt -> CONTINUE ; .)
    +               reduce using rule 55 (continue_stmt -> CONTINUE ; .)
    -               reduce using rule 55 (continue_stmt -> CONTINUE ; .)
    DEC             reduce using rule 55 (continue_stmt -> CONTINUE ; .)
    INC             reduce using rule 55 (continue_stmt -> CONTINUE ; .)
    (               reduce using rule 55 (continue_stmt -> CONTINUE ; .)
    FALSE           reduce using rule 55 (continue_stmt -> CONTINUE ; .)
    TRUE            reduce using rule 55 (continue_stmt -> CONTINUE ; .)
    STRING_LITERAL  reduce using rule 55 (continue_stmt -> CONTINUE ; .)
    CHAR_LITERAL    reduce using rule 55 (continue_stmt -> CONTINUE ; .)
    FLOAT_LITERAL   reduce using rule 55 (continue_stmt -> CONTINUE ; .)
    INTEGER_LITERAL reduce using rule 55 (continue_stmt -> CONTINUE ; .)
    $end            reduce using rule 55 (continue_stmt -> CONTINUE ; .)
    }               reduce using rule 55 (continue_stmt -> CONTINUE ; .)
    ELSE            reduce using rule 55 (continue_stmt -> CONTINUE ; .)


state 85

    (54) return_stmt -> RETURN opt_expr . ;
    ;               shift and go to state 142


state 86

    (62) opt_expr -> expr .
    ;               reduce using rule 62 (opt_expr -> expr .)
    )               reduce using rule 62 (opt_expr -> expr .)


state 87

    (63) opt_expr -> empty .
    ;               reduce using rule 63 (opt_expr -> empty .)
    )               reduce using rule 63 (opt_expr -> empty .)


state 88

    (53) print_stmt -> PRINT opt_expr_list . ;
    ;               shift and go to state 143


state 89

    (58) opt_expr_list -> expr_list .
    ;               reduce using rule 58 (opt_expr_list -> expr_list .)
    )               reduce using rule 58 (opt_expr_list -> expr_list .)
    }               reduce using rule 58 (opt_expr_list -> expr_list .)


state 90

    (59) opt_expr_list -> empty .
    ;               reduce using rule 59 (opt_expr_list -> empty .)
    )               reduce using rule 59 (opt_expr_list -> empty .)
    }               reduce using rule 59 (opt_expr_list -> empty .)


state 91

    (60) expr_list -> expr .
    (61) expr_list -> expr . , expr_list
    ;               reduce using rule 60 (expr_list -> expr .)
    )               reduce using rule 60 (expr_list -> expr .)
    }               reduce using rule 60 (expr_list -> expr .)
    ,               shift and go to state 144


state 92

    (39) for_header -> FOR ( . opt_expr ; opt_expr ; opt_expr )
    (62) opt_expr -> . expr
    (63) opt_expr -> . empty
    (64) expr -> . expr1
    (130) empty -> .
    (65) expr1 -> . expr2
    (66) expr1 -> . lval = expr1
    (69) expr2 -> . expr3
    (70) expr2 -> . expr2 LOR expr3
    (67) lval -> . ID index
    (68) lval -> . ID
    (71) expr3 -> . expr4
    (72) expr3 -> . expr3 LAND expr4
    (73) expr4 -> . expr5
    (74) expr4 -> . expr4 GE expr5
    (75) expr4 -> . expr4 GT expr5
    (76) expr4 -> . expr4 LE expr5
    (77) expr4 -> . expr4 LT expr5
    (78) expr4 -> . expr4 NE expr5
    (79) expr4 -> . expr4 EQ expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    ;               reduce using rule 130 (empty -> .)
    ID              shift and go to state 77
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    opt_expr                       shift and go to state 145
    expr                           shift and go to state 86
    empty                          shift and go to state 87
    expr1                          shift and go to state 32
    expr2                          shift and go to state 39
    lval                           shift and go to state 76
    expr3                          shift and go to state 40
    expr4                          shift and go to state 41
    expr5                          shift and go to state 42
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 93

    (35) if_cond -> IF ( . expr )
    (64) expr -> . expr1
    (65) expr1 -> . expr2
    (66) expr1 -> . lval = expr1
    (69) expr2 -> . expr3
    (70) expr2 -> . expr2 LOR expr3
    (67) lval -> . ID index
    (68) lval -> . ID
    (71) expr3 -> . expr4
    (72) expr3 -> . expr3 LAND expr4
    (73) expr4 -> . expr5
    (74) expr4 -> . expr4 GE expr5
    (75) expr4 -> . expr4 GT expr5
    (76) expr4 -> . expr4 LE expr5
    (77) expr4 -> . expr4 LT expr5
    (78) expr4 -> . expr4 NE expr5
    (79) expr4 -> . expr4 EQ expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    ID              shift and go to state 77
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    expr                           shift and go to state 146
    expr1                          shift and go to state 32
    expr2                          shift and go to state 39
    lval                           shift and go to state 76
    expr3                          shift and go to state 40
    expr4                          shift and go to state 41
    expr5                          shift and go to state 42
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 94

    (70) expr2 -> expr2 LOR . expr3
    (71) expr3 -> . expr4
    (72) expr3 -> . expr3 LAND expr4
    (73) expr4 -> . expr5
    (74) expr4 -> . expr4 GE expr5
    (75) expr4 -> . expr4 GT expr5
    (76) expr4 -> . expr4 LE expr5
    (77) expr4 -> . expr4 LT expr5
    (78) expr4 -> . expr4 NE expr5
    (79) expr4 -> . expr4 EQ expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    ID              shift and go to state 108
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    expr3                          shift and go to state 147
    expr4                          shift and go to state 41
    expr5                          shift and go to state 42
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 95

    (72) expr3 -> expr3 LAND . expr4
    (73) expr4 -> . expr5
    (74) expr4 -> . expr4 GE expr5
    (75) expr4 -> . expr4 GT expr5
    (76) expr4 -> . expr4 LE expr5
    (77) expr4 -> . expr4 LT expr5
    (78) expr4 -> . expr4 NE expr5
    (79) expr4 -> . expr4 EQ expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    ID              shift and go to state 108
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    expr4                          shift and go to state 148
    expr5                          shift and go to state 42
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 96

    (74) expr4 -> expr4 GE . expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    ID              shift and go to state 108
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    expr5                          shift and go to state 149
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 97

    (75) expr4 -> expr4 GT . expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    ID              shift and go to state 108
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    expr5                          shift and go to state 150
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 98

    (76) expr4 -> expr4 LE . expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    ID              shift and go to state 108
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    expr5                          shift and go to state 151
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 99

    (77) expr4 -> expr4 LT . expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    ID              shift and go to state 108
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    expr5                          shift and go to state 152
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 100

    (78) expr4 -> expr4 NE . expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    ID              shift and go to state 108
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    expr5                          shift and go to state 153
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 101

    (79) expr4 -> expr4 EQ . expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    ID              shift and go to state 108
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    expr5                          shift and go to state 154
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 102

    (81) expr5 -> expr5 - . expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    ID              shift and go to state 108
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    expr6                          shift and go to state 155
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 103

    (82) expr5 -> expr5 + . expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    ID              shift and go to state 108
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    expr6                          shift and go to state 156
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 104

    (84) expr6 -> expr6 % . expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    ID              shift and go to state 108
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    expr7                          shift and go to state 157
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 105

    (85) expr6 -> expr6 / . expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    ID              shift and go to state 108
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    expr7                          shift and go to state 158
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 106

    (86) expr6 -> expr6 * . expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    ID              shift and go to state 108
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    expr7                          shift and go to state 159
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 107

    (92) expr8 -> - expr8 .
    ^               reduce using rule 92 (expr8 -> - expr8 .)
    %               reduce using rule 92 (expr8 -> - expr8 .)
    /               reduce using rule 92 (expr8 -> - expr8 .)
    *               reduce using rule 92 (expr8 -> - expr8 .)
    -               reduce using rule 92 (expr8 -> - expr8 .)
    +               reduce using rule 92 (expr8 -> - expr8 .)
    GE              reduce using rule 92 (expr8 -> - expr8 .)
    GT              reduce using rule 92 (expr8 -> - expr8 .)
    LE              reduce using rule 92 (expr8 -> - expr8 .)
    LT              reduce using rule 92 (expr8 -> - expr8 .)
    NE              reduce using rule 92 (expr8 -> - expr8 .)
    EQ              reduce using rule 92 (expr8 -> - expr8 .)
    LAND            reduce using rule 92 (expr8 -> - expr8 .)
    LOR             reduce using rule 92 (expr8 -> - expr8 .)
    ;               reduce using rule 92 (expr8 -> - expr8 .)
    )               reduce using rule 92 (expr8 -> - expr8 .)
    ,               reduce using rule 92 (expr8 -> - expr8 .)
    ]               reduce using rule 92 (expr8 -> - expr8 .)
    }               reduce using rule 92 (expr8 -> - expr8 .)


state 108

    (99) group -> ID . index
    (100) group -> ID . ( opt_expr_list )
    (109) factor -> ID .
    (102) index -> . [ expr ]
    (               shift and go to state 63
    DEC             reduce using rule 109 (factor -> ID .)
    INC             reduce using rule 109 (factor -> ID .)
    ^               reduce using rule 109 (factor -> ID .)
    %               reduce using rule 109 (factor -> ID .)
    /               reduce using rule 109 (factor -> ID .)
    *               reduce using rule 109 (factor -> ID .)
    -               reduce using rule 109 (factor -> ID .)
    +               reduce using rule 109 (factor -> ID .)
    GE              reduce using rule 109 (factor -> ID .)
    GT              reduce using rule 109 (factor -> ID .)
    LE              reduce using rule 109 (factor -> ID .)
    LT              reduce using rule 109 (factor -> ID .)
    NE              reduce using rule 109 (factor -> ID .)
    EQ              reduce using rule 109 (factor -> ID .)
    LAND            reduce using rule 109 (factor -> ID .)
    LOR             reduce using rule 109 (factor -> ID .)
    ;               reduce using rule 109 (factor -> ID .)
    )               reduce using rule 109 (factor -> ID .)
    ,               reduce using rule 109 (factor -> ID .)
    ]               reduce using rule 109 (factor -> ID .)
    }               reduce using rule 109 (factor -> ID .)
    [               shift and go to state 64

    index                          shift and go to state 160

state 109

    (91) expr8 -> + expr8 .
    ^               reduce using rule 91 (expr8 -> + expr8 .)
    %               reduce using rule 91 (expr8 -> + expr8 .)
    /               reduce using rule 91 (expr8 -> + expr8 .)
    *               reduce using rule 91 (expr8 -> + expr8 .)
    -               reduce using rule 91 (expr8 -> + expr8 .)
    +               reduce using rule 91 (expr8 -> + expr8 .)
    GE              reduce using rule 91 (expr8 -> + expr8 .)
    GT              reduce using rule 91 (expr8 -> + expr8 .)
    LE              reduce using rule 91 (expr8 -> + expr8 .)
    LT              reduce using rule 91 (expr8 -> + expr8 .)
    NE              reduce using rule 91 (expr8 -> + expr8 .)
    EQ              reduce using rule 91 (expr8 -> + expr8 .)
    LAND            reduce using rule 91 (expr8 -> + expr8 .)
    LOR             reduce using rule 91 (expr8 -> + expr8 .)
    ;               reduce using rule 91 (expr8 -> + expr8 .)
    )               reduce using rule 91 (expr8 -> + expr8 .)
    ,               reduce using rule 91 (expr8 -> + expr8 .)
    ]               reduce using rule 91 (expr8 -> + expr8 .)
    }               reduce using rule 91 (expr8 -> + expr8 .)


state 110

    (88) expr7 -> expr7 ^ . expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    ID              shift and go to state 108
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    expr8                          shift and go to state 161
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 111

    (95) expr9 -> expr9 DEC .
    DEC             reduce using rule 95 (expr9 -> expr9 DEC .)
    INC             reduce using rule 95 (expr9 -> expr9 DEC .)
    ^               reduce using rule 95 (expr9 -> expr9 DEC .)
    %               reduce using rule 95 (expr9 -> expr9 DEC .)
    /               reduce using rule 95 (expr9 -> expr9 DEC .)
    *               reduce using rule 95 (expr9 -> expr9 DEC .)
    -               reduce using rule 95 (expr9 -> expr9 DEC .)
    +               reduce using rule 95 (expr9 -> expr9 DEC .)
    GE              reduce using rule 95 (expr9 -> expr9 DEC .)
    GT              reduce using rule 95 (expr9 -> expr9 DEC .)
    LE              reduce using rule 95 (expr9 -> expr9 DEC .)
    LT              reduce using rule 95 (expr9 -> expr9 DEC .)
    NE              reduce using rule 95 (expr9 -> expr9 DEC .)
    EQ              reduce using rule 95 (expr9 -> expr9 DEC .)
    LAND            reduce using rule 95 (expr9 -> expr9 DEC .)
    LOR             reduce using rule 95 (expr9 -> expr9 DEC .)
    ;               reduce using rule 95 (expr9 -> expr9 DEC .)
    )               reduce using rule 95 (expr9 -> expr9 DEC .)
    ,               reduce using rule 95 (expr9 -> expr9 DEC .)
    ]               reduce using rule 95 (expr9 -> expr9 DEC .)
    }               reduce using rule 95 (expr9 -> expr9 DEC .)


state 112

    (97) expr9 -> expr9 INC .
    DEC             reduce using rule 97 (expr9 -> expr9 INC .)
    INC             reduce using rule 97 (expr9 -> expr9 INC .)
    ^               reduce using rule 97 (expr9 -> expr9 INC .)
    %               reduce using rule 97 (expr9 -> expr9 INC .)
    /               reduce using rule 97 (expr9 -> expr9 INC .)
    *               reduce using rule 97 (expr9 -> expr9 INC .)
    -               reduce using rule 97 (expr9 -> expr9 INC .)
    +               reduce using rule 97 (expr9 -> expr9 INC .)
    GE              reduce using rule 97 (expr9 -> expr9 INC .)
    GT              reduce using rule 97 (expr9 -> expr9 INC .)
    LE              reduce using rule 97 (expr9 -> expr9 INC .)
    LT              reduce using rule 97 (expr9 -> expr9 INC .)
    NE              reduce using rule 97 (expr9 -> expr9 INC .)
    EQ              reduce using rule 97 (expr9 -> expr9 INC .)
    LAND            reduce using rule 97 (expr9 -> expr9 INC .)
    LOR             reduce using rule 97 (expr9 -> expr9 INC .)
    ;               reduce using rule 97 (expr9 -> expr9 INC .)
    )               reduce using rule 97 (expr9 -> expr9 INC .)
    ,               reduce using rule 97 (expr9 -> expr9 INC .)
    ]               reduce using rule 97 (expr9 -> expr9 INC .)
    }               reduce using rule 97 (expr9 -> expr9 INC .)


state 113

    (90) expr8 -> ! expr8 .
    ^               reduce using rule 90 (expr8 -> ! expr8 .)
    %               reduce using rule 90 (expr8 -> ! expr8 .)
    /               reduce using rule 90 (expr8 -> ! expr8 .)
    *               reduce using rule 90 (expr8 -> ! expr8 .)
    -               reduce using rule 90 (expr8 -> ! expr8 .)
    +               reduce using rule 90 (expr8 -> ! expr8 .)
    GE              reduce using rule 90 (expr8 -> ! expr8 .)
    GT              reduce using rule 90 (expr8 -> ! expr8 .)
    LE              reduce using rule 90 (expr8 -> ! expr8 .)
    LT              reduce using rule 90 (expr8 -> ! expr8 .)
    NE              reduce using rule 90 (expr8 -> ! expr8 .)
    EQ              reduce using rule 90 (expr8 -> ! expr8 .)
    LAND            reduce using rule 90 (expr8 -> ! expr8 .)
    LOR             reduce using rule 90 (expr8 -> ! expr8 .)
    ;               reduce using rule 90 (expr8 -> ! expr8 .)
    )               reduce using rule 90 (expr8 -> ! expr8 .)
    ,               reduce using rule 90 (expr8 -> ! expr8 .)
    ]               reduce using rule 90 (expr8 -> ! expr8 .)
    }               reduce using rule 90 (expr8 -> ! expr8 .)


state 114

    (94) expr9 -> DEC expr9 .
    (95) expr9 -> expr9 . DEC
    (97) expr9 -> expr9 . INC
  ! shift/reduce conflict for DEC resolved as shift
  ! shift/reduce conflict for INC resolved as shift
    ^               reduce using rule 94 (expr9 -> DEC expr9 .)
    %               reduce using rule 94 (expr9 -> DEC expr9 .)
    /               reduce using rule 94 (expr9 -> DEC expr9 .)
    *               reduce using rule 94 (expr9 -> DEC expr9 .)
    -               reduce using rule 94 (expr9 -> DEC expr9 .)
    +               reduce using rule 94 (expr9 -> DEC expr9 .)
    GE              reduce using rule 94 (expr9 -> DEC expr9 .)
    GT              reduce using rule 94 (expr9 -> DEC expr9 .)
    LE              reduce using rule 94 (expr9 -> DEC expr9 .)
    LT              reduce using rule 94 (expr9 -> DEC expr9 .)
    NE              reduce using rule 94 (expr9 -> DEC expr9 .)
    EQ              reduce using rule 94 (expr9 -> DEC expr9 .)
    LAND            reduce using rule 94 (expr9 -> DEC expr9 .)
    LOR             reduce using rule 94 (expr9 -> DEC expr9 .)
    ;               reduce using rule 94 (expr9 -> DEC expr9 .)
    )               reduce using rule 94 (expr9 -> DEC expr9 .)
    ,               reduce using rule 94 (expr9 -> DEC expr9 .)
    ]               reduce using rule 94 (expr9 -> DEC expr9 .)
    }               reduce using rule 94 (expr9 -> DEC expr9 .)
    DEC             shift and go to state 111
    INC             shift and go to state 112


state 115

    (96) expr9 -> INC expr9 .
    (95) expr9 -> expr9 . DEC
    (97) expr9 -> expr9 . INC
  ! shift/reduce conflict for DEC resolved as shift
  ! shift/reduce conflict for INC resolved as shift
    ^               reduce using rule 96 (expr9 -> INC expr9 .)
    %               reduce using rule 96 (expr9 -> INC expr9 .)
    /               reduce using rule 96 (expr9 -> INC expr9 .)
    *               reduce using rule 96 (expr9 -> INC expr9 .)
    -               reduce using rule 96 (expr9 -> INC expr9 .)
    +               reduce using rule 96 (expr9 -> INC expr9 .)
    GE              reduce using rule 96 (expr9 -> INC expr9 .)
    GT              reduce using rule 96 (expr9 -> INC expr9 .)
    LE              reduce using rule 96 (expr9 -> INC expr9 .)
    LT              reduce using rule 96 (expr9 -> INC expr9 .)
    NE              reduce using rule 96 (expr9 -> INC expr9 .)
    EQ              reduce using rule 96 (expr9 -> INC expr9 .)
    LAND            reduce using rule 96 (expr9 -> INC expr9 .)
    LOR             reduce using rule 96 (expr9 -> INC expr9 .)
    ;               reduce using rule 96 (expr9 -> INC expr9 .)
    )               reduce using rule 96 (expr9 -> INC expr9 .)
    ,               reduce using rule 96 (expr9 -> INC expr9 .)
    ]               reduce using rule 96 (expr9 -> INC expr9 .)
    }               reduce using rule 96 (expr9 -> INC expr9 .)
    DEC             shift and go to state 111
    INC             shift and go to state 112


state 116

    (9) decl -> ID : type_func . ;
    (12) decl_init -> ID : type_func . = { opt_stmt_list }
    ;               shift and go to state 162
    =               shift and go to state 163


state 117

    (10) decl -> ID : type_array_sized . ;
    (13) decl_init -> ID : type_array_sized . = { opt_expr_list } ;
    ;               shift and go to state 164
    =               shift and go to state 165


state 118

    (11) decl -> ID : type_simple . ;
    (20) decl_init -> ID : type_simple . = expr ;
    ;               shift and go to state 166
    =               shift and go to state 167


state 119

    (14) decl_init -> ID : CONSTANT . error
    (15) decl_init -> ID : CONSTANT . = { opt_expr_list } ;
    (16) decl_init -> ID : CONSTANT . = expr ;
    error           shift and go to state 168
    =               shift and go to state 169


state 120

    (17) decl_init -> ID : AUTO . error
    (18) decl_init -> ID : AUTO . = { opt_expr_list } ;
    (19) decl_init -> ID : AUTO . = expr ;
    error           shift and go to state 170
    =               shift and go to state 171


state 121

    (120) type_func -> FUNCTION . type_array_sized ( opt_param_list )
    (121) type_func -> FUNCTION . type_array ( opt_param_list )
    (122) type_func -> FUNCTION . type_simple ( opt_param_list )
    (116) type_array_sized -> . ARRAY index type_array_sized
    (117) type_array_sized -> . ARRAY index type_simple
    (118) type_array -> . ARRAY [ ] type_array
    (119) type_array -> . ARRAY [ ] type_simple
    (110) type_simple -> . VOID
    (111) type_simple -> . STRING
    (112) type_simple -> . CHAR
    (113) type_simple -> . BOOLEAN
    (114) type_simple -> . FLOAT
    (115) type_simple -> . INTEGER
    ARRAY           shift and go to state 175
    VOID            shift and go to state 123
    STRING          shift and go to state 124
    CHAR            shift and go to state 125
    BOOLEAN         shift and go to state 126
    FLOAT           shift and go to state 127
    INTEGER         shift and go to state 128

    type_array_sized               shift and go to state 172
    type_array                     shift and go to state 173
    type_simple                    shift and go to state 174

state 122

    (116) type_array_sized -> ARRAY . index type_array_sized
    (117) type_array_sized -> ARRAY . index type_simple
    (102) index -> . [ expr ]
    [               shift and go to state 64

    index                          shift and go to state 176

state 123

    (110) type_simple -> VOID .
    ;               reduce using rule 110 (type_simple -> VOID .)
    =               reduce using rule 110 (type_simple -> VOID .)
    (               reduce using rule 110 (type_simple -> VOID .)
    ,               reduce using rule 110 (type_simple -> VOID .)
    )               reduce using rule 110 (type_simple -> VOID .)


state 124

    (111) type_simple -> STRING .
    ;               reduce using rule 111 (type_simple -> STRING .)
    =               reduce using rule 111 (type_simple -> STRING .)
    (               reduce using rule 111 (type_simple -> STRING .)
    ,               reduce using rule 111 (type_simple -> STRING .)
    )               reduce using rule 111 (type_simple -> STRING .)


state 125

    (112) type_simple -> CHAR .
    ;               reduce using rule 112 (type_simple -> CHAR .)
    =               reduce using rule 112 (type_simple -> CHAR .)
    (               reduce using rule 112 (type_simple -> CHAR .)
    ,               reduce using rule 112 (type_simple -> CHAR .)
    )               reduce using rule 112 (type_simple -> CHAR .)


state 126

    (113) type_simple -> BOOLEAN .
    ;               reduce using rule 113 (type_simple -> BOOLEAN .)
    =               reduce using rule 113 (type_simple -> BOOLEAN .)
    (               reduce using rule 113 (type_simple -> BOOLEAN .)
    ,               reduce using rule 113 (type_simple -> BOOLEAN .)
    )               reduce using rule 113 (type_simple -> BOOLEAN .)


state 127

    (114) type_simple -> FLOAT .
    ;               reduce using rule 114 (type_simple -> FLOAT .)
    =               reduce using rule 114 (type_simple -> FLOAT .)
    (               reduce using rule 114 (type_simple -> FLOAT .)
    ,               reduce using rule 114 (type_simple -> FLOAT .)
    )               reduce using rule 114 (type_simple -> FLOAT .)


state 128

    (115) type_simple -> INTEGER .
    ;               reduce using rule 115 (type_simple -> INTEGER .)
    =               reduce using rule 115 (type_simple -> INTEGER .)
    (               reduce using rule 115 (type_simple -> INTEGER .)
    ,               reduce using rule 115 (type_simple -> INTEGER .)
    )               reduce using rule 115 (type_simple -> INTEGER .)


state 129

    (100) group -> ID ( opt_expr_list . )
    )               shift and go to state 177


state 130

    (102) index -> [ expr . ]
    ]               shift and go to state 178


state 131

    (57) block_stmt -> { stmt_list } .
    ID              reduce using rule 57 (block_stmt -> { stmt_list } .)
    DO              reduce using rule 57 (block_stmt -> { stmt_list } .)
    WHILE           reduce using rule 57 (block_stmt -> { stmt_list } .)
    {               reduce using rule 57 (block_stmt -> { stmt_list } .)
    BREAK           reduce using rule 57 (block_stmt -> { stmt_list } .)
    CONTINUE        reduce using rule 57 (block_stmt -> { stmt_list } .)
    RETURN          reduce using rule 57 (block_stmt -> { stmt_list } .)
    PRINT           reduce using rule 57 (block_stmt -> { stmt_list } .)
    FOR             reduce using rule 57 (block_stmt -> { stmt_list } .)
    IF              reduce using rule 57 (block_stmt -> { stmt_list } .)
    !               reduce using rule 57 (block_stmt -> { stmt_list } .)
    +               reduce using rule 57 (block_stmt -> { stmt_list } .)
    -               reduce using rule 57 (block_stmt -> { stmt_list } .)
    DEC             reduce using rule 57 (block_stmt -> { stmt_list } .)
    INC             reduce using rule 57 (block_stmt -> { stmt_list } .)
    (               reduce using rule 57 (block_stmt -> { stmt_list } .)
    FALSE           reduce using rule 57 (block_stmt -> { stmt_list } .)
    TRUE            reduce using rule 57 (block_stmt -> { stmt_list } .)
    STRING_LITERAL  reduce using rule 57 (block_stmt -> { stmt_list } .)
    CHAR_LITERAL    reduce using rule 57 (block_stmt -> { stmt_list } .)
    FLOAT_LITERAL   reduce using rule 57 (block_stmt -> { stmt_list } .)
    INTEGER_LITERAL reduce using rule 57 (block_stmt -> { stmt_list } .)
    $end            reduce using rule 57 (block_stmt -> { stmt_list } .)
    }               reduce using rule 57 (block_stmt -> { stmt_list } .)
    ELSE            reduce using rule 57 (block_stmt -> { stmt_list } .)


state 132

    (24) stmt_list -> stmt stmt_list .
    }               reduce using rule 24 (stmt_list -> stmt stmt_list .)


state 133

    (44) do_while_stmt -> DO closed_stmt WHILE . ( expr ) ;
    (               shift and go to state 179


state 134

    (43) while_stmt_closed -> WHILE ( . opt_expr ) closed_stmt
    (62) opt_expr -> . expr
    (63) opt_expr -> . empty
    (64) expr -> . expr1
    (130) empty -> .
    (65) expr1 -> . expr2
    (66) expr1 -> . lval = expr1
    (69) expr2 -> . expr3
    (70) expr2 -> . expr2 LOR expr3
    (67) lval -> . ID index
    (68) lval -> . ID
    (71) expr3 -> . expr4
    (72) expr3 -> . expr3 LAND expr4
    (73) expr4 -> . expr5
    (74) expr4 -> . expr4 GE expr5
    (75) expr4 -> . expr4 GT expr5
    (76) expr4 -> . expr4 LE expr5
    (77) expr4 -> . expr4 LT expr5
    (78) expr4 -> . expr4 NE expr5
    (79) expr4 -> . expr4 EQ expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    )               reduce using rule 130 (empty -> .)
    ID              shift and go to state 77
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    opt_expr                       shift and go to state 180
    expr                           shift and go to state 86
    empty                          shift and go to state 87
    expr1                          shift and go to state 32
    expr2                          shift and go to state 39
    lval                           shift and go to state 76
    expr3                          shift and go to state 40
    expr4                          shift and go to state 41
    expr5                          shift and go to state 42
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 135

    (36) if_stmt_closed -> if_cond closed_stmt . ELSE closed_stmt
    ELSE            shift and go to state 181


state 136

    (43) while_stmt_closed -> WHILE ( opt_expr . ) closed_stmt
    (42) while_stmt_open -> WHILE ( opt_expr . ) open_stmt
    )               shift and go to state 182


state 137

    (101) group -> ( expr ) .
    DEC             reduce using rule 101 (group -> ( expr ) .)
    INC             reduce using rule 101 (group -> ( expr ) .)
    ^               reduce using rule 101 (group -> ( expr ) .)
    %               reduce using rule 101 (group -> ( expr ) .)
    /               reduce using rule 101 (group -> ( expr ) .)
    *               reduce using rule 101 (group -> ( expr ) .)
    -               reduce using rule 101 (group -> ( expr ) .)
    +               reduce using rule 101 (group -> ( expr ) .)
    GE              reduce using rule 101 (group -> ( expr ) .)
    GT              reduce using rule 101 (group -> ( expr ) .)
    LE              reduce using rule 101 (group -> ( expr ) .)
    LT              reduce using rule 101 (group -> ( expr ) .)
    NE              reduce using rule 101 (group -> ( expr ) .)
    EQ              reduce using rule 101 (group -> ( expr ) .)
    LAND            reduce using rule 101 (group -> ( expr ) .)
    LOR             reduce using rule 101 (group -> ( expr ) .)
    ;               reduce using rule 101 (group -> ( expr ) .)
    )               reduce using rule 101 (group -> ( expr ) .)
    ,               reduce using rule 101 (group -> ( expr ) .)
    ]               reduce using rule 101 (group -> ( expr ) .)
    }               reduce using rule 101 (group -> ( expr ) .)


state 138

    (66) expr1 -> lval = . expr1
    (65) expr1 -> . expr2
    (66) expr1 -> . lval = expr1
    (69) expr2 -> . expr3
    (70) expr2 -> . expr2 LOR expr3
    (67) lval -> . ID index
    (68) lval -> . ID
    (71) expr3 -> . expr4
    (72) expr3 -> . expr3 LAND expr4
    (73) expr4 -> . expr5
    (74) expr4 -> . expr4 GE expr5
    (75) expr4 -> . expr4 GT expr5
    (76) expr4 -> . expr4 LE expr5
    (77) expr4 -> . expr4 LT expr5
    (78) expr4 -> . expr4 NE expr5
    (79) expr4 -> . expr4 EQ expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    ID              shift and go to state 77
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    lval                           shift and go to state 76
    expr1                          shift and go to state 183
    expr2                          shift and go to state 39
    expr3                          shift and go to state 40
    expr4                          shift and go to state 41
    expr5                          shift and go to state 42
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 139

    (45) simple_stmt -> lval = expr . ;
    ;               shift and go to state 184


state 140

    (66) expr1 -> lval = expr1 .
    (64) expr -> expr1 .
  ! reduce/reduce conflict for ; resolved using rule 64 (expr -> expr1 .)
    ;               reduce using rule 64 (expr -> expr1 .)


state 141

    (36) if_stmt_closed -> if_cond closed_stmt ELSE . closed_stmt
    (37) if_stmt_open -> if_cond closed_stmt ELSE . if_stmt_open
    (27) closed_stmt -> . do_while_stmt
    (28) closed_stmt -> . while_stmt_closed
    (29) closed_stmt -> . simple_stmt
    (30) closed_stmt -> . for_stmt_closed
    (31) closed_stmt -> . if_stmt_closed
    (37) if_stmt_open -> . if_cond closed_stmt ELSE if_stmt_open
    (38) if_stmt_open -> . if_cond stmt
    (44) do_while_stmt -> . DO closed_stmt WHILE ( expr ) ;
    (43) while_stmt_closed -> . WHILE ( opt_expr ) closed_stmt
    (45) simple_stmt -> . lval = expr ;
    (46) simple_stmt -> . expr ;
    (47) simple_stmt -> . decl
    (48) simple_stmt -> . block_stmt
    (49) simple_stmt -> . break_stmt
    (50) simple_stmt -> . continue_stmt
    (51) simple_stmt -> . return_stmt
    (52) simple_stmt -> . print_stmt
    (41) for_stmt_closed -> . for_header closed_stmt
    (36) if_stmt_closed -> . if_cond closed_stmt ELSE closed_stmt
    (35) if_cond -> . IF ( expr )
    (67) lval -> . ID index
    (68) lval -> . ID
    (64) expr -> . expr1
    (8) decl -> . decl_init
    (9) decl -> . ID : type_func ;
    (10) decl -> . ID : type_array_sized ;
    (11) decl -> . ID : type_simple ;
    (57) block_stmt -> . { stmt_list }
    (56) break_stmt -> . BREAK ;
    (55) continue_stmt -> . CONTINUE ;
    (54) return_stmt -> . RETURN opt_expr ;
    (53) print_stmt -> . PRINT opt_expr_list ;
    (39) for_header -> . FOR ( opt_expr ; opt_expr ; opt_expr )
    (65) expr1 -> . expr2
    (66) expr1 -> . lval = expr1
    (12) decl_init -> . ID : type_func = { opt_stmt_list }
    (13) decl_init -> . ID : type_array_sized = { opt_expr_list } ;
    (14) decl_init -> . ID : CONSTANT error
    (15) decl_init -> . ID : CONSTANT = { opt_expr_list } ;
    (16) decl_init -> . ID : CONSTANT = expr ;
    (17) decl_init -> . ID : AUTO error
    (18) decl_init -> . ID : AUTO = { opt_expr_list } ;
    (19) decl_init -> . ID : AUTO = expr ;
    (20) decl_init -> . ID : type_simple = expr ;
    (69) expr2 -> . expr3
    (70) expr2 -> . expr2 LOR expr3
    (71) expr3 -> . expr4
    (72) expr3 -> . expr3 LAND expr4
    (73) expr4 -> . expr5
    (74) expr4 -> . expr4 GE expr5
    (75) expr4 -> . expr4 GT expr5
    (76) expr4 -> . expr4 LE expr5
    (77) expr4 -> . expr4 LT expr5
    (78) expr4 -> . expr4 NE expr5
    (79) expr4 -> . expr4 EQ expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    DO              shift and go to state 21
    WHILE           shift and go to state 71
    IF              shift and go to state 38
    ID              shift and go to state 68
    {               shift and go to state 19
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    RETURN          shift and go to state 35
    PRINT           shift and go to state 36
    FOR             shift and go to state 37
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    if_cond                        shift and go to state 185
    closed_stmt                    shift and go to state 186
    if_stmt_open                   shift and go to state 187
    do_while_stmt                  shift and go to state 11
    while_stmt_closed              shift and go to state 12
    simple_stmt                    shift and go to state 13
    for_stmt_closed                shift and go to state 14
    if_stmt_closed                 shift and go to state 15
    expr                           shift and go to state 20
    lval                           shift and go to state 24
    decl                           shift and go to state 67
    block_stmt                     shift and go to state 25
    break_stmt                     shift and go to state 26
    continue_stmt                  shift and go to state 27
    return_stmt                    shift and go to state 28
    print_stmt                     shift and go to state 29
    for_header                     shift and go to state 72
    expr1                          shift and go to state 32
    decl_init                      shift and go to state 9
    expr2                          shift and go to state 39
    expr3                          shift and go to state 40
    expr4                          shift and go to state 41
    expr5                          shift and go to state 42
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 142

    (54) return_stmt -> RETURN opt_expr ; .
    ID              reduce using rule 54 (return_stmt -> RETURN opt_expr ; .)
    DO              reduce using rule 54 (return_stmt -> RETURN opt_expr ; .)
    WHILE           reduce using rule 54 (return_stmt -> RETURN opt_expr ; .)
    {               reduce using rule 54 (return_stmt -> RETURN opt_expr ; .)
    BREAK           reduce using rule 54 (return_stmt -> RETURN opt_expr ; .)
    CONTINUE        reduce using rule 54 (return_stmt -> RETURN opt_expr ; .)
    RETURN          reduce using rule 54 (return_stmt -> RETURN opt_expr ; .)
    PRINT           reduce using rule 54 (return_stmt -> RETURN opt_expr ; .)
    FOR             reduce using rule 54 (return_stmt -> RETURN opt_expr ; .)
    IF              reduce using rule 54 (return_stmt -> RETURN opt_expr ; .)
    !               reduce using rule 54 (return_stmt -> RETURN opt_expr ; .)
    +               reduce using rule 54 (return_stmt -> RETURN opt_expr ; .)
    -               reduce using rule 54 (return_stmt -> RETURN opt_expr ; .)
    DEC             reduce using rule 54 (return_stmt -> RETURN opt_expr ; .)
    INC             reduce using rule 54 (return_stmt -> RETURN opt_expr ; .)
    (               reduce using rule 54 (return_stmt -> RETURN opt_expr ; .)
    FALSE           reduce using rule 54 (return_stmt -> RETURN opt_expr ; .)
    TRUE            reduce using rule 54 (return_stmt -> RETURN opt_expr ; .)
    STRING_LITERAL  reduce using rule 54 (return_stmt -> RETURN opt_expr ; .)
    CHAR_LITERAL    reduce using rule 54 (return_stmt -> RETURN opt_expr ; .)
    FLOAT_LITERAL   reduce using rule 54 (return_stmt -> RETURN opt_expr ; .)
    INTEGER_LITERAL reduce using rule 54 (return_stmt -> RETURN opt_expr ; .)
    $end            reduce using rule 54 (return_stmt -> RETURN opt_expr ; .)
    }               reduce using rule 54 (return_stmt -> RETURN opt_expr ; .)
    ELSE            reduce using rule 54 (return_stmt -> RETURN opt_expr ; .)


state 143

    (53) print_stmt -> PRINT opt_expr_list ; .
    ID              reduce using rule 53 (print_stmt -> PRINT opt_expr_list ; .)
    DO              reduce using rule 53 (print_stmt -> PRINT opt_expr_list ; .)
    WHILE           reduce using rule 53 (print_stmt -> PRINT opt_expr_list ; .)
    {               reduce using rule 53 (print_stmt -> PRINT opt_expr_list ; .)
    BREAK           reduce using rule 53 (print_stmt -> PRINT opt_expr_list ; .)
    CONTINUE        reduce using rule 53 (print_stmt -> PRINT opt_expr_list ; .)
    RETURN          reduce using rule 53 (print_stmt -> PRINT opt_expr_list ; .)
    PRINT           reduce using rule 53 (print_stmt -> PRINT opt_expr_list ; .)
    FOR             reduce using rule 53 (print_stmt -> PRINT opt_expr_list ; .)
    IF              reduce using rule 53 (print_stmt -> PRINT opt_expr_list ; .)
    !               reduce using rule 53 (print_stmt -> PRINT opt_expr_list ; .)
    +               reduce using rule 53 (print_stmt -> PRINT opt_expr_list ; .)
    -               reduce using rule 53 (print_stmt -> PRINT opt_expr_list ; .)
    DEC             reduce using rule 53 (print_stmt -> PRINT opt_expr_list ; .)
    INC             reduce using rule 53 (print_stmt -> PRINT opt_expr_list ; .)
    (               reduce using rule 53 (print_stmt -> PRINT opt_expr_list ; .)
    FALSE           reduce using rule 53 (print_stmt -> PRINT opt_expr_list ; .)
    TRUE            reduce using rule 53 (print_stmt -> PRINT opt_expr_list ; .)
    STRING_LITERAL  reduce using rule 53 (print_stmt -> PRINT opt_expr_list ; .)
    CHAR_LITERAL    reduce using rule 53 (print_stmt -> PRINT opt_expr_list ; .)
    FLOAT_LITERAL   reduce using rule 53 (print_stmt -> PRINT opt_expr_list ; .)
    INTEGER_LITERAL reduce using rule 53 (print_stmt -> PRINT opt_expr_list ; .)
    $end            reduce using rule 53 (print_stmt -> PRINT opt_expr_list ; .)
    }               reduce using rule 53 (print_stmt -> PRINT opt_expr_list ; .)
    ELSE            reduce using rule 53 (print_stmt -> PRINT opt_expr_list ; .)


state 144

    (61) expr_list -> expr , . expr_list
    (60) expr_list -> . expr
    (61) expr_list -> . expr , expr_list
    (64) expr -> . expr1
    (65) expr1 -> . expr2
    (66) expr1 -> . lval = expr1
    (69) expr2 -> . expr3
    (70) expr2 -> . expr2 LOR expr3
    (67) lval -> . ID index
    (68) lval -> . ID
    (71) expr3 -> . expr4
    (72) expr3 -> . expr3 LAND expr4
    (73) expr4 -> . expr5
    (74) expr4 -> . expr4 GE expr5
    (75) expr4 -> . expr4 GT expr5
    (76) expr4 -> . expr4 LE expr5
    (77) expr4 -> . expr4 LT expr5
    (78) expr4 -> . expr4 NE expr5
    (79) expr4 -> . expr4 EQ expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    ID              shift and go to state 77
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    expr                           shift and go to state 91
    expr_list                      shift and go to state 188
    expr1                          shift and go to state 32
    expr2                          shift and go to state 39
    lval                           shift and go to state 76
    expr3                          shift and go to state 40
    expr4                          shift and go to state 41
    expr5                          shift and go to state 42
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 145

    (39) for_header -> FOR ( opt_expr . ; opt_expr ; opt_expr )
    ;               shift and go to state 189


state 146

    (35) if_cond -> IF ( expr . )
    )               shift and go to state 190


state 147

    (70) expr2 -> expr2 LOR expr3 .
    (72) expr3 -> expr3 . LAND expr4
    LOR             reduce using rule 70 (expr2 -> expr2 LOR expr3 .)
    ;               reduce using rule 70 (expr2 -> expr2 LOR expr3 .)
    )               reduce using rule 70 (expr2 -> expr2 LOR expr3 .)
    ,               reduce using rule 70 (expr2 -> expr2 LOR expr3 .)
    ]               reduce using rule 70 (expr2 -> expr2 LOR expr3 .)
    }               reduce using rule 70 (expr2 -> expr2 LOR expr3 .)
    LAND            shift and go to state 95


state 148

    (72) expr3 -> expr3 LAND expr4 .
    (74) expr4 -> expr4 . GE expr5
    (75) expr4 -> expr4 . GT expr5
    (76) expr4 -> expr4 . LE expr5
    (77) expr4 -> expr4 . LT expr5
    (78) expr4 -> expr4 . NE expr5
    (79) expr4 -> expr4 . EQ expr5
    LAND            reduce using rule 72 (expr3 -> expr3 LAND expr4 .)
    LOR             reduce using rule 72 (expr3 -> expr3 LAND expr4 .)
    ;               reduce using rule 72 (expr3 -> expr3 LAND expr4 .)
    )               reduce using rule 72 (expr3 -> expr3 LAND expr4 .)
    ,               reduce using rule 72 (expr3 -> expr3 LAND expr4 .)
    ]               reduce using rule 72 (expr3 -> expr3 LAND expr4 .)
    }               reduce using rule 72 (expr3 -> expr3 LAND expr4 .)
    GE              shift and go to state 96
    GT              shift and go to state 97
    LE              shift and go to state 98
    LT              shift and go to state 99
    NE              shift and go to state 100
    EQ              shift and go to state 101


state 149

    (74) expr4 -> expr4 GE expr5 .
    (81) expr5 -> expr5 . - expr6
    (82) expr5 -> expr5 . + expr6
    GE              reduce using rule 74 (expr4 -> expr4 GE expr5 .)
    GT              reduce using rule 74 (expr4 -> expr4 GE expr5 .)
    LE              reduce using rule 74 (expr4 -> expr4 GE expr5 .)
    LT              reduce using rule 74 (expr4 -> expr4 GE expr5 .)
    NE              reduce using rule 74 (expr4 -> expr4 GE expr5 .)
    EQ              reduce using rule 74 (expr4 -> expr4 GE expr5 .)
    LAND            reduce using rule 74 (expr4 -> expr4 GE expr5 .)
    LOR             reduce using rule 74 (expr4 -> expr4 GE expr5 .)
    ;               reduce using rule 74 (expr4 -> expr4 GE expr5 .)
    )               reduce using rule 74 (expr4 -> expr4 GE expr5 .)
    ,               reduce using rule 74 (expr4 -> expr4 GE expr5 .)
    ]               reduce using rule 74 (expr4 -> expr4 GE expr5 .)
    }               reduce using rule 74 (expr4 -> expr4 GE expr5 .)
    -               shift and go to state 102
    +               shift and go to state 103


state 150

    (75) expr4 -> expr4 GT expr5 .
    (81) expr5 -> expr5 . - expr6
    (82) expr5 -> expr5 . + expr6
    GE              reduce using rule 75 (expr4 -> expr4 GT expr5 .)
    GT              reduce using rule 75 (expr4 -> expr4 GT expr5 .)
    LE              reduce using rule 75 (expr4 -> expr4 GT expr5 .)
    LT              reduce using rule 75 (expr4 -> expr4 GT expr5 .)
    NE              reduce using rule 75 (expr4 -> expr4 GT expr5 .)
    EQ              reduce using rule 75 (expr4 -> expr4 GT expr5 .)
    LAND            reduce using rule 75 (expr4 -> expr4 GT expr5 .)
    LOR             reduce using rule 75 (expr4 -> expr4 GT expr5 .)
    ;               reduce using rule 75 (expr4 -> expr4 GT expr5 .)
    )               reduce using rule 75 (expr4 -> expr4 GT expr5 .)
    ,               reduce using rule 75 (expr4 -> expr4 GT expr5 .)
    ]               reduce using rule 75 (expr4 -> expr4 GT expr5 .)
    }               reduce using rule 75 (expr4 -> expr4 GT expr5 .)
    -               shift and go to state 102
    +               shift and go to state 103


state 151

    (76) expr4 -> expr4 LE expr5 .
    (81) expr5 -> expr5 . - expr6
    (82) expr5 -> expr5 . + expr6
    GE              reduce using rule 76 (expr4 -> expr4 LE expr5 .)
    GT              reduce using rule 76 (expr4 -> expr4 LE expr5 .)
    LE              reduce using rule 76 (expr4 -> expr4 LE expr5 .)
    LT              reduce using rule 76 (expr4 -> expr4 LE expr5 .)
    NE              reduce using rule 76 (expr4 -> expr4 LE expr5 .)
    EQ              reduce using rule 76 (expr4 -> expr4 LE expr5 .)
    LAND            reduce using rule 76 (expr4 -> expr4 LE expr5 .)
    LOR             reduce using rule 76 (expr4 -> expr4 LE expr5 .)
    ;               reduce using rule 76 (expr4 -> expr4 LE expr5 .)
    )               reduce using rule 76 (expr4 -> expr4 LE expr5 .)
    ,               reduce using rule 76 (expr4 -> expr4 LE expr5 .)
    ]               reduce using rule 76 (expr4 -> expr4 LE expr5 .)
    }               reduce using rule 76 (expr4 -> expr4 LE expr5 .)
    -               shift and go to state 102
    +               shift and go to state 103


state 152

    (77) expr4 -> expr4 LT expr5 .
    (81) expr5 -> expr5 . - expr6
    (82) expr5 -> expr5 . + expr6
    GE              reduce using rule 77 (expr4 -> expr4 LT expr5 .)
    GT              reduce using rule 77 (expr4 -> expr4 LT expr5 .)
    LE              reduce using rule 77 (expr4 -> expr4 LT expr5 .)
    LT              reduce using rule 77 (expr4 -> expr4 LT expr5 .)
    NE              reduce using rule 77 (expr4 -> expr4 LT expr5 .)
    EQ              reduce using rule 77 (expr4 -> expr4 LT expr5 .)
    LAND            reduce using rule 77 (expr4 -> expr4 LT expr5 .)
    LOR             reduce using rule 77 (expr4 -> expr4 LT expr5 .)
    ;               reduce using rule 77 (expr4 -> expr4 LT expr5 .)
    )               reduce using rule 77 (expr4 -> expr4 LT expr5 .)
    ,               reduce using rule 77 (expr4 -> expr4 LT expr5 .)
    ]               reduce using rule 77 (expr4 -> expr4 LT expr5 .)
    }               reduce using rule 77 (expr4 -> expr4 LT expr5 .)
    -               shift and go to state 102
    +               shift and go to state 103


state 153

    (78) expr4 -> expr4 NE expr5 .
    (81) expr5 -> expr5 . - expr6
    (82) expr5 -> expr5 . + expr6
    GE              reduce using rule 78 (expr4 -> expr4 NE expr5 .)
    GT              reduce using rule 78 (expr4 -> expr4 NE expr5 .)
    LE              reduce using rule 78 (expr4 -> expr4 NE expr5 .)
    LT              reduce using rule 78 (expr4 -> expr4 NE expr5 .)
    NE              reduce using rule 78 (expr4 -> expr4 NE expr5 .)
    EQ              reduce using rule 78 (expr4 -> expr4 NE expr5 .)
    LAND            reduce using rule 78 (expr4 -> expr4 NE expr5 .)
    LOR             reduce using rule 78 (expr4 -> expr4 NE expr5 .)
    ;               reduce using rule 78 (expr4 -> expr4 NE expr5 .)
    )               reduce using rule 78 (expr4 -> expr4 NE expr5 .)
    ,               reduce using rule 78 (expr4 -> expr4 NE expr5 .)
    ]               reduce using rule 78 (expr4 -> expr4 NE expr5 .)
    }               reduce using rule 78 (expr4 -> expr4 NE expr5 .)
    -               shift and go to state 102
    +               shift and go to state 103


state 154

    (79) expr4 -> expr4 EQ expr5 .
    (81) expr5 -> expr5 . - expr6
    (82) expr5 -> expr5 . + expr6
    GE              reduce using rule 79 (expr4 -> expr4 EQ expr5 .)
    GT              reduce using rule 79 (expr4 -> expr4 EQ expr5 .)
    LE              reduce using rule 79 (expr4 -> expr4 EQ expr5 .)
    LT              reduce using rule 79 (expr4 -> expr4 EQ expr5 .)
    NE              reduce using rule 79 (expr4 -> expr4 EQ expr5 .)
    EQ              reduce using rule 79 (expr4 -> expr4 EQ expr5 .)
    LAND            reduce using rule 79 (expr4 -> expr4 EQ expr5 .)
    LOR             reduce using rule 79 (expr4 -> expr4 EQ expr5 .)
    ;               reduce using rule 79 (expr4 -> expr4 EQ expr5 .)
    )               reduce using rule 79 (expr4 -> expr4 EQ expr5 .)
    ,               reduce using rule 79 (expr4 -> expr4 EQ expr5 .)
    ]               reduce using rule 79 (expr4 -> expr4 EQ expr5 .)
    }               reduce using rule 79 (expr4 -> expr4 EQ expr5 .)
    -               shift and go to state 102
    +               shift and go to state 103


state 155

    (81) expr5 -> expr5 - expr6 .
    (84) expr6 -> expr6 . % expr7
    (85) expr6 -> expr6 . / expr7
    (86) expr6 -> expr6 . * expr7
    -               reduce using rule 81 (expr5 -> expr5 - expr6 .)
    +               reduce using rule 81 (expr5 -> expr5 - expr6 .)
    GE              reduce using rule 81 (expr5 -> expr5 - expr6 .)
    GT              reduce using rule 81 (expr5 -> expr5 - expr6 .)
    LE              reduce using rule 81 (expr5 -> expr5 - expr6 .)
    LT              reduce using rule 81 (expr5 -> expr5 - expr6 .)
    NE              reduce using rule 81 (expr5 -> expr5 - expr6 .)
    EQ              reduce using rule 81 (expr5 -> expr5 - expr6 .)
    LAND            reduce using rule 81 (expr5 -> expr5 - expr6 .)
    LOR             reduce using rule 81 (expr5 -> expr5 - expr6 .)
    ;               reduce using rule 81 (expr5 -> expr5 - expr6 .)
    )               reduce using rule 81 (expr5 -> expr5 - expr6 .)
    ,               reduce using rule 81 (expr5 -> expr5 - expr6 .)
    ]               reduce using rule 81 (expr5 -> expr5 - expr6 .)
    }               reduce using rule 81 (expr5 -> expr5 - expr6 .)
    %               shift and go to state 104
    /               shift and go to state 105
    *               shift and go to state 106


state 156

    (82) expr5 -> expr5 + expr6 .
    (84) expr6 -> expr6 . % expr7
    (85) expr6 -> expr6 . / expr7
    (86) expr6 -> expr6 . * expr7
    -               reduce using rule 82 (expr5 -> expr5 + expr6 .)
    +               reduce using rule 82 (expr5 -> expr5 + expr6 .)
    GE              reduce using rule 82 (expr5 -> expr5 + expr6 .)
    GT              reduce using rule 82 (expr5 -> expr5 + expr6 .)
    LE              reduce using rule 82 (expr5 -> expr5 + expr6 .)
    LT              reduce using rule 82 (expr5 -> expr5 + expr6 .)
    NE              reduce using rule 82 (expr5 -> expr5 + expr6 .)
    EQ              reduce using rule 82 (expr5 -> expr5 + expr6 .)
    LAND            reduce using rule 82 (expr5 -> expr5 + expr6 .)
    LOR             reduce using rule 82 (expr5 -> expr5 + expr6 .)
    ;               reduce using rule 82 (expr5 -> expr5 + expr6 .)
    )               reduce using rule 82 (expr5 -> expr5 + expr6 .)
    ,               reduce using rule 82 (expr5 -> expr5 + expr6 .)
    ]               reduce using rule 82 (expr5 -> expr5 + expr6 .)
    }               reduce using rule 82 (expr5 -> expr5 + expr6 .)
    %               shift and go to state 104
    /               shift and go to state 105
    *               shift and go to state 106


state 157

    (84) expr6 -> expr6 % expr7 .
    (88) expr7 -> expr7 . ^ expr8
    %               reduce using rule 84 (expr6 -> expr6 % expr7 .)
    /               reduce using rule 84 (expr6 -> expr6 % expr7 .)
    *               reduce using rule 84 (expr6 -> expr6 % expr7 .)
    -               reduce using rule 84 (expr6 -> expr6 % expr7 .)
    +               reduce using rule 84 (expr6 -> expr6 % expr7 .)
    GE              reduce using rule 84 (expr6 -> expr6 % expr7 .)
    GT              reduce using rule 84 (expr6 -> expr6 % expr7 .)
    LE              reduce using rule 84 (expr6 -> expr6 % expr7 .)
    LT              reduce using rule 84 (expr6 -> expr6 % expr7 .)
    NE              reduce using rule 84 (expr6 -> expr6 % expr7 .)
    EQ              reduce using rule 84 (expr6 -> expr6 % expr7 .)
    LAND            reduce using rule 84 (expr6 -> expr6 % expr7 .)
    LOR             reduce using rule 84 (expr6 -> expr6 % expr7 .)
    ;               reduce using rule 84 (expr6 -> expr6 % expr7 .)
    )               reduce using rule 84 (expr6 -> expr6 % expr7 .)
    ,               reduce using rule 84 (expr6 -> expr6 % expr7 .)
    ]               reduce using rule 84 (expr6 -> expr6 % expr7 .)
    }               reduce using rule 84 (expr6 -> expr6 % expr7 .)
    ^               shift and go to state 110


state 158

    (85) expr6 -> expr6 / expr7 .
    (88) expr7 -> expr7 . ^ expr8
    %               reduce using rule 85 (expr6 -> expr6 / expr7 .)
    /               reduce using rule 85 (expr6 -> expr6 / expr7 .)
    *               reduce using rule 85 (expr6 -> expr6 / expr7 .)
    -               reduce using rule 85 (expr6 -> expr6 / expr7 .)
    +               reduce using rule 85 (expr6 -> expr6 / expr7 .)
    GE              reduce using rule 85 (expr6 -> expr6 / expr7 .)
    GT              reduce using rule 85 (expr6 -> expr6 / expr7 .)
    LE              reduce using rule 85 (expr6 -> expr6 / expr7 .)
    LT              reduce using rule 85 (expr6 -> expr6 / expr7 .)
    NE              reduce using rule 85 (expr6 -> expr6 / expr7 .)
    EQ              reduce using rule 85 (expr6 -> expr6 / expr7 .)
    LAND            reduce using rule 85 (expr6 -> expr6 / expr7 .)
    LOR             reduce using rule 85 (expr6 -> expr6 / expr7 .)
    ;               reduce using rule 85 (expr6 -> expr6 / expr7 .)
    )               reduce using rule 85 (expr6 -> expr6 / expr7 .)
    ,               reduce using rule 85 (expr6 -> expr6 / expr7 .)
    ]               reduce using rule 85 (expr6 -> expr6 / expr7 .)
    }               reduce using rule 85 (expr6 -> expr6 / expr7 .)
    ^               shift and go to state 110


state 159

    (86) expr6 -> expr6 * expr7 .
    (88) expr7 -> expr7 . ^ expr8
    %               reduce using rule 86 (expr6 -> expr6 * expr7 .)
    /               reduce using rule 86 (expr6 -> expr6 * expr7 .)
    *               reduce using rule 86 (expr6 -> expr6 * expr7 .)
    -               reduce using rule 86 (expr6 -> expr6 * expr7 .)
    +               reduce using rule 86 (expr6 -> expr6 * expr7 .)
    GE              reduce using rule 86 (expr6 -> expr6 * expr7 .)
    GT              reduce using rule 86 (expr6 -> expr6 * expr7 .)
    LE              reduce using rule 86 (expr6 -> expr6 * expr7 .)
    LT              reduce using rule 86 (expr6 -> expr6 * expr7 .)
    NE              reduce using rule 86 (expr6 -> expr6 * expr7 .)
    EQ              reduce using rule 86 (expr6 -> expr6 * expr7 .)
    LAND            reduce using rule 86 (expr6 -> expr6 * expr7 .)
    LOR             reduce using rule 86 (expr6 -> expr6 * expr7 .)
    ;               reduce using rule 86 (expr6 -> expr6 * expr7 .)
    )               reduce using rule 86 (expr6 -> expr6 * expr7 .)
    ,               reduce using rule 86 (expr6 -> expr6 * expr7 .)
    ]               reduce using rule 86 (expr6 -> expr6 * expr7 .)
    }               reduce using rule 86 (expr6 -> expr6 * expr7 .)
    ^               shift and go to state 110


state 160

    (99) group -> ID index .
    DEC             reduce using rule 99 (group -> ID index .)
    INC             reduce using rule 99 (group -> ID index .)
    ^               reduce using rule 99 (group -> ID index .)
    %               reduce using rule 99 (group -> ID index .)
    /               reduce using rule 99 (group -> ID index .)
    *               reduce using rule 99 (group -> ID index .)
    -               reduce using rule 99 (group -> ID index .)
    +               reduce using rule 99 (group -> ID index .)
    GE              reduce using rule 99 (group -> ID index .)
    GT              reduce using rule 99 (group -> ID index .)
    LE              reduce using rule 99 (group -> ID index .)
    LT              reduce using rule 99 (group -> ID index .)
    NE              reduce using rule 99 (group -> ID index .)
    EQ              reduce using rule 99 (group -> ID index .)
    LAND            reduce using rule 99 (group -> ID index .)
    LOR             reduce using rule 99 (group -> ID index .)
    ;               reduce using rule 99 (group -> ID index .)
    )               reduce using rule 99 (group -> ID index .)
    ,               reduce using rule 99 (group -> ID index .)
    ]               reduce using rule 99 (group -> ID index .)
    }               reduce using rule 99 (group -> ID index .)


state 161

    (88) expr7 -> expr7 ^ expr8 .
    ^               reduce using rule 88 (expr7 -> expr7 ^ expr8 .)
    %               reduce using rule 88 (expr7 -> expr7 ^ expr8 .)
    /               reduce using rule 88 (expr7 -> expr7 ^ expr8 .)
    *               reduce using rule 88 (expr7 -> expr7 ^ expr8 .)
    -               reduce using rule 88 (expr7 -> expr7 ^ expr8 .)
    +               reduce using rule 88 (expr7 -> expr7 ^ expr8 .)
    GE              reduce using rule 88 (expr7 -> expr7 ^ expr8 .)
    GT              reduce using rule 88 (expr7 -> expr7 ^ expr8 .)
    LE              reduce using rule 88 (expr7 -> expr7 ^ expr8 .)
    LT              reduce using rule 88 (expr7 -> expr7 ^ expr8 .)
    NE              reduce using rule 88 (expr7 -> expr7 ^ expr8 .)
    EQ              reduce using rule 88 (expr7 -> expr7 ^ expr8 .)
    LAND            reduce using rule 88 (expr7 -> expr7 ^ expr8 .)
    LOR             reduce using rule 88 (expr7 -> expr7 ^ expr8 .)
    ;               reduce using rule 88 (expr7 -> expr7 ^ expr8 .)
    )               reduce using rule 88 (expr7 -> expr7 ^ expr8 .)
    ,               reduce using rule 88 (expr7 -> expr7 ^ expr8 .)
    ]               reduce using rule 88 (expr7 -> expr7 ^ expr8 .)
    }               reduce using rule 88 (expr7 -> expr7 ^ expr8 .)


state 162

    (9) decl -> ID : type_func ; .
    ID              reduce using rule 9 (decl -> ID : type_func ; .)
    DO              reduce using rule 9 (decl -> ID : type_func ; .)
    WHILE           reduce using rule 9 (decl -> ID : type_func ; .)
    {               reduce using rule 9 (decl -> ID : type_func ; .)
    BREAK           reduce using rule 9 (decl -> ID : type_func ; .)
    CONTINUE        reduce using rule 9 (decl -> ID : type_func ; .)
    RETURN          reduce using rule 9 (decl -> ID : type_func ; .)
    PRINT           reduce using rule 9 (decl -> ID : type_func ; .)
    FOR             reduce using rule 9 (decl -> ID : type_func ; .)
    IF              reduce using rule 9 (decl -> ID : type_func ; .)
    !               reduce using rule 9 (decl -> ID : type_func ; .)
    +               reduce using rule 9 (decl -> ID : type_func ; .)
    -               reduce using rule 9 (decl -> ID : type_func ; .)
    DEC             reduce using rule 9 (decl -> ID : type_func ; .)
    INC             reduce using rule 9 (decl -> ID : type_func ; .)
    (               reduce using rule 9 (decl -> ID : type_func ; .)
    FALSE           reduce using rule 9 (decl -> ID : type_func ; .)
    TRUE            reduce using rule 9 (decl -> ID : type_func ; .)
    STRING_LITERAL  reduce using rule 9 (decl -> ID : type_func ; .)
    CHAR_LITERAL    reduce using rule 9 (decl -> ID : type_func ; .)
    FLOAT_LITERAL   reduce using rule 9 (decl -> ID : type_func ; .)
    INTEGER_LITERAL reduce using rule 9 (decl -> ID : type_func ; .)
    $end            reduce using rule 9 (decl -> ID : type_func ; .)
    }               reduce using rule 9 (decl -> ID : type_func ; .)
    ELSE            reduce using rule 9 (decl -> ID : type_func ; .)


state 163

    (12) decl_init -> ID : type_func = . { opt_stmt_list }
    {               shift and go to state 191


state 164

    (10) decl -> ID : type_array_sized ; .
    ID              reduce using rule 10 (decl -> ID : type_array_sized ; .)
    DO              reduce using rule 10 (decl -> ID : type_array_sized ; .)
    WHILE           reduce using rule 10 (decl -> ID : type_array_sized ; .)
    {               reduce using rule 10 (decl -> ID : type_array_sized ; .)
    BREAK           reduce using rule 10 (decl -> ID : type_array_sized ; .)
    CONTINUE        reduce using rule 10 (decl -> ID : type_array_sized ; .)
    RETURN          reduce using rule 10 (decl -> ID : type_array_sized ; .)
    PRINT           reduce using rule 10 (decl -> ID : type_array_sized ; .)
    FOR             reduce using rule 10 (decl -> ID : type_array_sized ; .)
    IF              reduce using rule 10 (decl -> ID : type_array_sized ; .)
    !               reduce using rule 10 (decl -> ID : type_array_sized ; .)
    +               reduce using rule 10 (decl -> ID : type_array_sized ; .)
    -               reduce using rule 10 (decl -> ID : type_array_sized ; .)
    DEC             reduce using rule 10 (decl -> ID : type_array_sized ; .)
    INC             reduce using rule 10 (decl -> ID : type_array_sized ; .)
    (               reduce using rule 10 (decl -> ID : type_array_sized ; .)
    FALSE           reduce using rule 10 (decl -> ID : type_array_sized ; .)
    TRUE            reduce using rule 10 (decl -> ID : type_array_sized ; .)
    STRING_LITERAL  reduce using rule 10 (decl -> ID : type_array_sized ; .)
    CHAR_LITERAL    reduce using rule 10 (decl -> ID : type_array_sized ; .)
    FLOAT_LITERAL   reduce using rule 10 (decl -> ID : type_array_sized ; .)
    INTEGER_LITERAL reduce using rule 10 (decl -> ID : type_array_sized ; .)
    $end            reduce using rule 10 (decl -> ID : type_array_sized ; .)
    }               reduce using rule 10 (decl -> ID : type_array_sized ; .)
    ELSE            reduce using rule 10 (decl -> ID : type_array_sized ; .)


state 165

    (13) decl_init -> ID : type_array_sized = . { opt_expr_list } ;
    {               shift and go to state 192


state 166

    (11) decl -> ID : type_simple ; .
    ID              reduce using rule 11 (decl -> ID : type_simple ; .)
    DO              reduce using rule 11 (decl -> ID : type_simple ; .)
    WHILE           reduce using rule 11 (decl -> ID : type_simple ; .)
    {               reduce using rule 11 (decl -> ID : type_simple ; .)
    BREAK           reduce using rule 11 (decl -> ID : type_simple ; .)
    CONTINUE        reduce using rule 11 (decl -> ID : type_simple ; .)
    RETURN          reduce using rule 11 (decl -> ID : type_simple ; .)
    PRINT           reduce using rule 11 (decl -> ID : type_simple ; .)
    FOR             reduce using rule 11 (decl -> ID : type_simple ; .)
    IF              reduce using rule 11 (decl -> ID : type_simple ; .)
    !               reduce using rule 11 (decl -> ID : type_simple ; .)
    +               reduce using rule 11 (decl -> ID : type_simple ; .)
    -               reduce using rule 11 (decl -> ID : type_simple ; .)
    DEC             reduce using rule 11 (decl -> ID : type_simple ; .)
    INC             reduce using rule 11 (decl -> ID : type_simple ; .)
    (               reduce using rule 11 (decl -> ID : type_simple ; .)
    FALSE           reduce using rule 11 (decl -> ID : type_simple ; .)
    TRUE            reduce using rule 11 (decl -> ID : type_simple ; .)
    STRING_LITERAL  reduce using rule 11 (decl -> ID : type_simple ; .)
    CHAR_LITERAL    reduce using rule 11 (decl -> ID : type_simple ; .)
    FLOAT_LITERAL   reduce using rule 11 (decl -> ID : type_simple ; .)
    INTEGER_LITERAL reduce using rule 11 (decl -> ID : type_simple ; .)
    $end            reduce using rule 11 (decl -> ID : type_simple ; .)
    }               reduce using rule 11 (decl -> ID : type_simple ; .)
    ELSE            reduce using rule 11 (decl -> ID : type_simple ; .)


state 167

    (20) decl_init -> ID : type_simple = . expr ;
    (64) expr -> . expr1
    (65) expr1 -> . expr2
    (66) expr1 -> . lval = expr1
    (69) expr2 -> . expr3
    (70) expr2 -> . expr2 LOR expr3
    (67) lval -> . ID index
    (68) lval -> . ID
    (71) expr3 -> . expr4
    (72) expr3 -> . expr3 LAND expr4
    (73) expr4 -> . expr5
    (74) expr4 -> . expr4 GE expr5
    (75) expr4 -> . expr4 GT expr5
    (76) expr4 -> . expr4 LE expr5
    (77) expr4 -> . expr4 LT expr5
    (78) expr4 -> . expr4 NE expr5
    (79) expr4 -> . expr4 EQ expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    ID              shift and go to state 77
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    expr                           shift and go to state 193
    expr1                          shift and go to state 32
    expr2                          shift and go to state 39
    lval                           shift and go to state 76
    expr3                          shift and go to state 40
    expr4                          shift and go to state 41
    expr5                          shift and go to state 42
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 168

    (14) decl_init -> ID : CONSTANT error .
    ID              reduce using rule 14 (decl_init -> ID : CONSTANT error .)
    DO              reduce using rule 14 (decl_init -> ID : CONSTANT error .)
    WHILE           reduce using rule 14 (decl_init -> ID : CONSTANT error .)
    {               reduce using rule 14 (decl_init -> ID : CONSTANT error .)
    BREAK           reduce using rule 14 (decl_init -> ID : CONSTANT error .)
    CONTINUE        reduce using rule 14 (decl_init -> ID : CONSTANT error .)
    RETURN          reduce using rule 14 (decl_init -> ID : CONSTANT error .)
    PRINT           reduce using rule 14 (decl_init -> ID : CONSTANT error .)
    FOR             reduce using rule 14 (decl_init -> ID : CONSTANT error .)
    IF              reduce using rule 14 (decl_init -> ID : CONSTANT error .)
    !               reduce using rule 14 (decl_init -> ID : CONSTANT error .)
    +               reduce using rule 14 (decl_init -> ID : CONSTANT error .)
    -               reduce using rule 14 (decl_init -> ID : CONSTANT error .)
    DEC             reduce using rule 14 (decl_init -> ID : CONSTANT error .)
    INC             reduce using rule 14 (decl_init -> ID : CONSTANT error .)
    (               reduce using rule 14 (decl_init -> ID : CONSTANT error .)
    FALSE           reduce using rule 14 (decl_init -> ID : CONSTANT error .)
    TRUE            reduce using rule 14 (decl_init -> ID : CONSTANT error .)
    STRING_LITERAL  reduce using rule 14 (decl_init -> ID : CONSTANT error .)
    CHAR_LITERAL    reduce using rule 14 (decl_init -> ID : CONSTANT error .)
    FLOAT_LITERAL   reduce using rule 14 (decl_init -> ID : CONSTANT error .)
    INTEGER_LITERAL reduce using rule 14 (decl_init -> ID : CONSTANT error .)
    $end            reduce using rule 14 (decl_init -> ID : CONSTANT error .)
    }               reduce using rule 14 (decl_init -> ID : CONSTANT error .)
    ELSE            reduce using rule 14 (decl_init -> ID : CONSTANT error .)


state 169

    (15) decl_init -> ID : CONSTANT = . { opt_expr_list } ;
    (16) decl_init -> ID : CONSTANT = . expr ;
    (64) expr -> . expr1
    (65) expr1 -> . expr2
    (66) expr1 -> . lval = expr1
    (69) expr2 -> . expr3
    (70) expr2 -> . expr2 LOR expr3
    (67) lval -> . ID index
    (68) lval -> . ID
    (71) expr3 -> . expr4
    (72) expr3 -> . expr3 LAND expr4
    (73) expr4 -> . expr5
    (74) expr4 -> . expr4 GE expr5
    (75) expr4 -> . expr4 GT expr5
    (76) expr4 -> . expr4 LE expr5
    (77) expr4 -> . expr4 LT expr5
    (78) expr4 -> . expr4 NE expr5
    (79) expr4 -> . expr4 EQ expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    {               shift and go to state 194
    ID              shift and go to state 77
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    expr                           shift and go to state 195
    expr1                          shift and go to state 32
    expr2                          shift and go to state 39
    lval                           shift and go to state 76
    expr3                          shift and go to state 40
    expr4                          shift and go to state 41
    expr5                          shift and go to state 42
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 170

    (17) decl_init -> ID : AUTO error .
    ID              reduce using rule 17 (decl_init -> ID : AUTO error .)
    DO              reduce using rule 17 (decl_init -> ID : AUTO error .)
    WHILE           reduce using rule 17 (decl_init -> ID : AUTO error .)
    {               reduce using rule 17 (decl_init -> ID : AUTO error .)
    BREAK           reduce using rule 17 (decl_init -> ID : AUTO error .)
    CONTINUE        reduce using rule 17 (decl_init -> ID : AUTO error .)
    RETURN          reduce using rule 17 (decl_init -> ID : AUTO error .)
    PRINT           reduce using rule 17 (decl_init -> ID : AUTO error .)
    FOR             reduce using rule 17 (decl_init -> ID : AUTO error .)
    IF              reduce using rule 17 (decl_init -> ID : AUTO error .)
    !               reduce using rule 17 (decl_init -> ID : AUTO error .)
    +               reduce using rule 17 (decl_init -> ID : AUTO error .)
    -               reduce using rule 17 (decl_init -> ID : AUTO error .)
    DEC             reduce using rule 17 (decl_init -> ID : AUTO error .)
    INC             reduce using rule 17 (decl_init -> ID : AUTO error .)
    (               reduce using rule 17 (decl_init -> ID : AUTO error .)
    FALSE           reduce using rule 17 (decl_init -> ID : AUTO error .)
    TRUE            reduce using rule 17 (decl_init -> ID : AUTO error .)
    STRING_LITERAL  reduce using rule 17 (decl_init -> ID : AUTO error .)
    CHAR_LITERAL    reduce using rule 17 (decl_init -> ID : AUTO error .)
    FLOAT_LITERAL   reduce using rule 17 (decl_init -> ID : AUTO error .)
    INTEGER_LITERAL reduce using rule 17 (decl_init -> ID : AUTO error .)
    $end            reduce using rule 17 (decl_init -> ID : AUTO error .)
    }               reduce using rule 17 (decl_init -> ID : AUTO error .)
    ELSE            reduce using rule 17 (decl_init -> ID : AUTO error .)


state 171

    (18) decl_init -> ID : AUTO = . { opt_expr_list } ;
    (19) decl_init -> ID : AUTO = . expr ;
    (64) expr -> . expr1
    (65) expr1 -> . expr2
    (66) expr1 -> . lval = expr1
    (69) expr2 -> . expr3
    (70) expr2 -> . expr2 LOR expr3
    (67) lval -> . ID index
    (68) lval -> . ID
    (71) expr3 -> . expr4
    (72) expr3 -> . expr3 LAND expr4
    (73) expr4 -> . expr5
    (74) expr4 -> . expr4 GE expr5
    (75) expr4 -> . expr4 GT expr5
    (76) expr4 -> . expr4 LE expr5
    (77) expr4 -> . expr4 LT expr5
    (78) expr4 -> . expr4 NE expr5
    (79) expr4 -> . expr4 EQ expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    {               shift and go to state 196
    ID              shift and go to state 77
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    expr                           shift and go to state 197
    expr1                          shift and go to state 32
    expr2                          shift and go to state 39
    lval                           shift and go to state 76
    expr3                          shift and go to state 40
    expr4                          shift and go to state 41
    expr5                          shift and go to state 42
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 172

    (120) type_func -> FUNCTION type_array_sized . ( opt_param_list )
    (               shift and go to state 198


state 173

    (121) type_func -> FUNCTION type_array . ( opt_param_list )
    (               shift and go to state 199


state 174

    (122) type_func -> FUNCTION type_simple . ( opt_param_list )
    (               shift and go to state 200


state 175

    (116) type_array_sized -> ARRAY . index type_array_sized
    (117) type_array_sized -> ARRAY . index type_simple
    (118) type_array -> ARRAY . [ ] type_array
    (119) type_array -> ARRAY . [ ] type_simple
    (102) index -> . [ expr ]
    [               shift and go to state 201

    index                          shift and go to state 176

state 176

    (116) type_array_sized -> ARRAY index . type_array_sized
    (117) type_array_sized -> ARRAY index . type_simple
    (116) type_array_sized -> . ARRAY index type_array_sized
    (117) type_array_sized -> . ARRAY index type_simple
    (110) type_simple -> . VOID
    (111) type_simple -> . STRING
    (112) type_simple -> . CHAR
    (113) type_simple -> . BOOLEAN
    (114) type_simple -> . FLOAT
    (115) type_simple -> . INTEGER
    ARRAY           shift and go to state 122
    VOID            shift and go to state 123
    STRING          shift and go to state 124
    CHAR            shift and go to state 125
    BOOLEAN         shift and go to state 126
    FLOAT           shift and go to state 127
    INTEGER         shift and go to state 128

    type_array_sized               shift and go to state 202
    type_simple                    shift and go to state 203

state 177

    (100) group -> ID ( opt_expr_list ) .
    DEC             reduce using rule 100 (group -> ID ( opt_expr_list ) .)
    INC             reduce using rule 100 (group -> ID ( opt_expr_list ) .)
    ^               reduce using rule 100 (group -> ID ( opt_expr_list ) .)
    %               reduce using rule 100 (group -> ID ( opt_expr_list ) .)
    /               reduce using rule 100 (group -> ID ( opt_expr_list ) .)
    *               reduce using rule 100 (group -> ID ( opt_expr_list ) .)
    -               reduce using rule 100 (group -> ID ( opt_expr_list ) .)
    +               reduce using rule 100 (group -> ID ( opt_expr_list ) .)
    GE              reduce using rule 100 (group -> ID ( opt_expr_list ) .)
    GT              reduce using rule 100 (group -> ID ( opt_expr_list ) .)
    LE              reduce using rule 100 (group -> ID ( opt_expr_list ) .)
    LT              reduce using rule 100 (group -> ID ( opt_expr_list ) .)
    NE              reduce using rule 100 (group -> ID ( opt_expr_list ) .)
    EQ              reduce using rule 100 (group -> ID ( opt_expr_list ) .)
    LAND            reduce using rule 100 (group -> ID ( opt_expr_list ) .)
    LOR             reduce using rule 100 (group -> ID ( opt_expr_list ) .)
    ;               reduce using rule 100 (group -> ID ( opt_expr_list ) .)
    )               reduce using rule 100 (group -> ID ( opt_expr_list ) .)
    ,               reduce using rule 100 (group -> ID ( opt_expr_list ) .)
    ]               reduce using rule 100 (group -> ID ( opt_expr_list ) .)
    }               reduce using rule 100 (group -> ID ( opt_expr_list ) .)


state 178

    (102) index -> [ expr ] .
    =               reduce using rule 102 (index -> [ expr ] .)
    DEC             reduce using rule 102 (index -> [ expr ] .)
    INC             reduce using rule 102 (index -> [ expr ] .)
    ^               reduce using rule 102 (index -> [ expr ] .)
    %               reduce using rule 102 (index -> [ expr ] .)
    /               reduce using rule 102 (index -> [ expr ] .)
    *               reduce using rule 102 (index -> [ expr ] .)
    -               reduce using rule 102 (index -> [ expr ] .)
    +               reduce using rule 102 (index -> [ expr ] .)
    GE              reduce using rule 102 (index -> [ expr ] .)
    GT              reduce using rule 102 (index -> [ expr ] .)
    LE              reduce using rule 102 (index -> [ expr ] .)
    LT              reduce using rule 102 (index -> [ expr ] .)
    NE              reduce using rule 102 (index -> [ expr ] .)
    EQ              reduce using rule 102 (index -> [ expr ] .)
    LAND            reduce using rule 102 (index -> [ expr ] .)
    LOR             reduce using rule 102 (index -> [ expr ] .)
    ;               reduce using rule 102 (index -> [ expr ] .)
    )               reduce using rule 102 (index -> [ expr ] .)
    ,               reduce using rule 102 (index -> [ expr ] .)
    ]               reduce using rule 102 (index -> [ expr ] .)
    }               reduce using rule 102 (index -> [ expr ] .)
    ARRAY           reduce using rule 102 (index -> [ expr ] .)
    VOID            reduce using rule 102 (index -> [ expr ] .)
    STRING          reduce using rule 102 (index -> [ expr ] .)
    CHAR            reduce using rule 102 (index -> [ expr ] .)
    BOOLEAN         reduce using rule 102 (index -> [ expr ] .)
    FLOAT           reduce using rule 102 (index -> [ expr ] .)
    INTEGER         reduce using rule 102 (index -> [ expr ] .)


state 179

    (44) do_while_stmt -> DO closed_stmt WHILE ( . expr ) ;
    (64) expr -> . expr1
    (65) expr1 -> . expr2
    (66) expr1 -> . lval = expr1
    (69) expr2 -> . expr3
    (70) expr2 -> . expr2 LOR expr3
    (67) lval -> . ID index
    (68) lval -> . ID
    (71) expr3 -> . expr4
    (72) expr3 -> . expr3 LAND expr4
    (73) expr4 -> . expr5
    (74) expr4 -> . expr4 GE expr5
    (75) expr4 -> . expr4 GT expr5
    (76) expr4 -> . expr4 LE expr5
    (77) expr4 -> . expr4 LT expr5
    (78) expr4 -> . expr4 NE expr5
    (79) expr4 -> . expr4 EQ expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    ID              shift and go to state 77
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    expr                           shift and go to state 204
    expr1                          shift and go to state 32
    expr2                          shift and go to state 39
    lval                           shift and go to state 76
    expr3                          shift and go to state 40
    expr4                          shift and go to state 41
    expr5                          shift and go to state 42
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 180

    (43) while_stmt_closed -> WHILE ( opt_expr . ) closed_stmt
    )               shift and go to state 205


state 181

    (36) if_stmt_closed -> if_cond closed_stmt ELSE . closed_stmt
    (27) closed_stmt -> . do_while_stmt
    (28) closed_stmt -> . while_stmt_closed
    (29) closed_stmt -> . simple_stmt
    (30) closed_stmt -> . for_stmt_closed
    (31) closed_stmt -> . if_stmt_closed
    (44) do_while_stmt -> . DO closed_stmt WHILE ( expr ) ;
    (43) while_stmt_closed -> . WHILE ( opt_expr ) closed_stmt
    (45) simple_stmt -> . lval = expr ;
    (46) simple_stmt -> . expr ;
    (47) simple_stmt -> . decl
    (48) simple_stmt -> . block_stmt
    (49) simple_stmt -> . break_stmt
    (50) simple_stmt -> . continue_stmt
    (51) simple_stmt -> . return_stmt
    (52) simple_stmt -> . print_stmt
    (41) for_stmt_closed -> . for_header closed_stmt
    (36) if_stmt_closed -> . if_cond closed_stmt ELSE closed_stmt
    (67) lval -> . ID index
    (68) lval -> . ID
    (64) expr -> . expr1
    (8) decl -> . decl_init
    (9) decl -> . ID : type_func ;
    (10) decl -> . ID : type_array_sized ;
    (11) decl -> . ID : type_simple ;
    (57) block_stmt -> . { stmt_list }
    (56) break_stmt -> . BREAK ;
    (55) continue_stmt -> . CONTINUE ;
    (54) return_stmt -> . RETURN opt_expr ;
    (53) print_stmt -> . PRINT opt_expr_list ;
    (39) for_header -> . FOR ( opt_expr ; opt_expr ; opt_expr )
    (35) if_cond -> . IF ( expr )
    (65) expr1 -> . expr2
    (66) expr1 -> . lval = expr1
    (12) decl_init -> . ID : type_func = { opt_stmt_list }
    (13) decl_init -> . ID : type_array_sized = { opt_expr_list } ;
    (14) decl_init -> . ID : CONSTANT error
    (15) decl_init -> . ID : CONSTANT = { opt_expr_list } ;
    (16) decl_init -> . ID : CONSTANT = expr ;
    (17) decl_init -> . ID : AUTO error
    (18) decl_init -> . ID : AUTO = { opt_expr_list } ;
    (19) decl_init -> . ID : AUTO = expr ;
    (20) decl_init -> . ID : type_simple = expr ;
    (69) expr2 -> . expr3
    (70) expr2 -> . expr2 LOR expr3
    (71) expr3 -> . expr4
    (72) expr3 -> . expr3 LAND expr4
    (73) expr4 -> . expr5
    (74) expr4 -> . expr4 GE expr5
    (75) expr4 -> . expr4 GT expr5
    (76) expr4 -> . expr4 LE expr5
    (77) expr4 -> . expr4 LT expr5
    (78) expr4 -> . expr4 NE expr5
    (79) expr4 -> . expr4 EQ expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    DO              shift and go to state 21
    WHILE           shift and go to state 71
    ID              shift and go to state 68
    {               shift and go to state 19
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    RETURN          shift and go to state 35
    PRINT           shift and go to state 36
    FOR             shift and go to state 37
    IF              shift and go to state 38
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    if_cond                        shift and go to state 73
    closed_stmt                    shift and go to state 186
    do_while_stmt                  shift and go to state 11
    while_stmt_closed              shift and go to state 12
    simple_stmt                    shift and go to state 13
    for_stmt_closed                shift and go to state 14
    if_stmt_closed                 shift and go to state 15
    expr                           shift and go to state 20
    lval                           shift and go to state 24
    decl                           shift and go to state 67
    block_stmt                     shift and go to state 25
    break_stmt                     shift and go to state 26
    continue_stmt                  shift and go to state 27
    return_stmt                    shift and go to state 28
    print_stmt                     shift and go to state 29
    for_header                     shift and go to state 72
    expr1                          shift and go to state 32
    decl_init                      shift and go to state 9
    expr2                          shift and go to state 39
    expr3                          shift and go to state 40
    expr4                          shift and go to state 41
    expr5                          shift and go to state 42
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 182

    (43) while_stmt_closed -> WHILE ( opt_expr ) . closed_stmt
    (42) while_stmt_open -> WHILE ( opt_expr ) . open_stmt
    (27) closed_stmt -> . do_while_stmt
    (28) closed_stmt -> . while_stmt_closed
    (29) closed_stmt -> . simple_stmt
    (30) closed_stmt -> . for_stmt_closed
    (31) closed_stmt -> . if_stmt_closed
    (32) open_stmt -> . while_stmt_open
    (33) open_stmt -> . for_stmt_open
    (34) open_stmt -> . if_stmt_open
    (44) do_while_stmt -> . DO closed_stmt WHILE ( expr ) ;
    (43) while_stmt_closed -> . WHILE ( opt_expr ) closed_stmt
    (45) simple_stmt -> . lval = expr ;
    (46) simple_stmt -> . expr ;
    (47) simple_stmt -> . decl
    (48) simple_stmt -> . block_stmt
    (49) simple_stmt -> . break_stmt
    (50) simple_stmt -> . continue_stmt
    (51) simple_stmt -> . return_stmt
    (52) simple_stmt -> . print_stmt
    (41) for_stmt_closed -> . for_header closed_stmt
    (36) if_stmt_closed -> . if_cond closed_stmt ELSE closed_stmt
    (42) while_stmt_open -> . WHILE ( opt_expr ) open_stmt
    (40) for_stmt_open -> . for_header open_stmt
    (37) if_stmt_open -> . if_cond closed_stmt ELSE if_stmt_open
    (38) if_stmt_open -> . if_cond stmt
    (67) lval -> . ID index
    (68) lval -> . ID
    (64) expr -> . expr1
    (8) decl -> . decl_init
    (9) decl -> . ID : type_func ;
    (10) decl -> . ID : type_array_sized ;
    (11) decl -> . ID : type_simple ;
    (57) block_stmt -> . { stmt_list }
    (56) break_stmt -> . BREAK ;
    (55) continue_stmt -> . CONTINUE ;
    (54) return_stmt -> . RETURN opt_expr ;
    (53) print_stmt -> . PRINT opt_expr_list ;
    (39) for_header -> . FOR ( opt_expr ; opt_expr ; opt_expr )
    (35) if_cond -> . IF ( expr )
    (65) expr1 -> . expr2
    (66) expr1 -> . lval = expr1
    (12) decl_init -> . ID : type_func = { opt_stmt_list }
    (13) decl_init -> . ID : type_array_sized = { opt_expr_list } ;
    (14) decl_init -> . ID : CONSTANT error
    (15) decl_init -> . ID : CONSTANT = { opt_expr_list } ;
    (16) decl_init -> . ID : CONSTANT = expr ;
    (17) decl_init -> . ID : AUTO error
    (18) decl_init -> . ID : AUTO = { opt_expr_list } ;
    (19) decl_init -> . ID : AUTO = expr ;
    (20) decl_init -> . ID : type_simple = expr ;
    (69) expr2 -> . expr3
    (70) expr2 -> . expr2 LOR expr3
    (71) expr3 -> . expr4
    (72) expr3 -> . expr3 LAND expr4
    (73) expr4 -> . expr5
    (74) expr4 -> . expr4 GE expr5
    (75) expr4 -> . expr4 GT expr5
    (76) expr4 -> . expr4 LE expr5
    (77) expr4 -> . expr4 LT expr5
    (78) expr4 -> . expr4 NE expr5
    (79) expr4 -> . expr4 EQ expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    DO              shift and go to state 21
    WHILE           shift and go to state 22
    ID              shift and go to state 68
    {               shift and go to state 19
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    RETURN          shift and go to state 35
    PRINT           shift and go to state 36
    FOR             shift and go to state 37
    IF              shift and go to state 38
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    closed_stmt                    shift and go to state 206
    open_stmt                      shift and go to state 207
    do_while_stmt                  shift and go to state 11
    while_stmt_closed              shift and go to state 12
    simple_stmt                    shift and go to state 13
    for_stmt_closed                shift and go to state 14
    if_stmt_closed                 shift and go to state 15
    while_stmt_open                shift and go to state 16
    for_stmt_open                  shift and go to state 17
    if_stmt_open                   shift and go to state 18
    expr                           shift and go to state 20
    lval                           shift and go to state 24
    decl                           shift and go to state 67
    block_stmt                     shift and go to state 25
    break_stmt                     shift and go to state 26
    continue_stmt                  shift and go to state 27
    return_stmt                    shift and go to state 28
    print_stmt                     shift and go to state 29
    for_header                     shift and go to state 30
    if_cond                        shift and go to state 31
    expr1                          shift and go to state 32
    decl_init                      shift and go to state 9
    expr2                          shift and go to state 39
    expr3                          shift and go to state 40
    expr4                          shift and go to state 41
    expr5                          shift and go to state 42
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 183

    (66) expr1 -> lval = expr1 .
    )               reduce using rule 66 (expr1 -> lval = expr1 .)
    ;               reduce using rule 66 (expr1 -> lval = expr1 .)
    ,               reduce using rule 66 (expr1 -> lval = expr1 .)
    ]               reduce using rule 66 (expr1 -> lval = expr1 .)
    }               reduce using rule 66 (expr1 -> lval = expr1 .)


state 184

    (45) simple_stmt -> lval = expr ; .
    ID              reduce using rule 45 (simple_stmt -> lval = expr ; .)
    DO              reduce using rule 45 (simple_stmt -> lval = expr ; .)
    WHILE           reduce using rule 45 (simple_stmt -> lval = expr ; .)
    {               reduce using rule 45 (simple_stmt -> lval = expr ; .)
    BREAK           reduce using rule 45 (simple_stmt -> lval = expr ; .)
    CONTINUE        reduce using rule 45 (simple_stmt -> lval = expr ; .)
    RETURN          reduce using rule 45 (simple_stmt -> lval = expr ; .)
    PRINT           reduce using rule 45 (simple_stmt -> lval = expr ; .)
    FOR             reduce using rule 45 (simple_stmt -> lval = expr ; .)
    IF              reduce using rule 45 (simple_stmt -> lval = expr ; .)
    !               reduce using rule 45 (simple_stmt -> lval = expr ; .)
    +               reduce using rule 45 (simple_stmt -> lval = expr ; .)
    -               reduce using rule 45 (simple_stmt -> lval = expr ; .)
    DEC             reduce using rule 45 (simple_stmt -> lval = expr ; .)
    INC             reduce using rule 45 (simple_stmt -> lval = expr ; .)
    (               reduce using rule 45 (simple_stmt -> lval = expr ; .)
    FALSE           reduce using rule 45 (simple_stmt -> lval = expr ; .)
    TRUE            reduce using rule 45 (simple_stmt -> lval = expr ; .)
    STRING_LITERAL  reduce using rule 45 (simple_stmt -> lval = expr ; .)
    CHAR_LITERAL    reduce using rule 45 (simple_stmt -> lval = expr ; .)
    FLOAT_LITERAL   reduce using rule 45 (simple_stmt -> lval = expr ; .)
    INTEGER_LITERAL reduce using rule 45 (simple_stmt -> lval = expr ; .)
    $end            reduce using rule 45 (simple_stmt -> lval = expr ; .)
    }               reduce using rule 45 (simple_stmt -> lval = expr ; .)
    ELSE            reduce using rule 45 (simple_stmt -> lval = expr ; .)


state 185

    (37) if_stmt_open -> if_cond . closed_stmt ELSE if_stmt_open
    (38) if_stmt_open -> if_cond . stmt
    (36) if_stmt_closed -> if_cond . closed_stmt ELSE closed_stmt
    (27) closed_stmt -> . do_while_stmt
    (28) closed_stmt -> . while_stmt_closed
    (29) closed_stmt -> . simple_stmt
    (30) closed_stmt -> . for_stmt_closed
    (31) closed_stmt -> . if_stmt_closed
    (25) stmt -> . closed_stmt
    (26) stmt -> . open_stmt
    (44) do_while_stmt -> . DO closed_stmt WHILE ( expr ) ;
    (43) while_stmt_closed -> . WHILE ( opt_expr ) closed_stmt
    (45) simple_stmt -> . lval = expr ;
    (46) simple_stmt -> . expr ;
    (47) simple_stmt -> . decl
    (48) simple_stmt -> . block_stmt
    (49) simple_stmt -> . break_stmt
    (50) simple_stmt -> . continue_stmt
    (51) simple_stmt -> . return_stmt
    (52) simple_stmt -> . print_stmt
    (41) for_stmt_closed -> . for_header closed_stmt
    (36) if_stmt_closed -> . if_cond closed_stmt ELSE closed_stmt
    (32) open_stmt -> . while_stmt_open
    (33) open_stmt -> . for_stmt_open
    (34) open_stmt -> . if_stmt_open
    (67) lval -> . ID index
    (68) lval -> . ID
    (64) expr -> . expr1
    (8) decl -> . decl_init
    (9) decl -> . ID : type_func ;
    (10) decl -> . ID : type_array_sized ;
    (11) decl -> . ID : type_simple ;
    (57) block_stmt -> . { stmt_list }
    (56) break_stmt -> . BREAK ;
    (55) continue_stmt -> . CONTINUE ;
    (54) return_stmt -> . RETURN opt_expr ;
    (53) print_stmt -> . PRINT opt_expr_list ;
    (39) for_header -> . FOR ( opt_expr ; opt_expr ; opt_expr )
    (35) if_cond -> . IF ( expr )
    (42) while_stmt_open -> . WHILE ( opt_expr ) open_stmt
    (40) for_stmt_open -> . for_header open_stmt
    (37) if_stmt_open -> . if_cond closed_stmt ELSE if_stmt_open
    (38) if_stmt_open -> . if_cond stmt
    (65) expr1 -> . expr2
    (66) expr1 -> . lval = expr1
    (12) decl_init -> . ID : type_func = { opt_stmt_list }
    (13) decl_init -> . ID : type_array_sized = { opt_expr_list } ;
    (14) decl_init -> . ID : CONSTANT error
    (15) decl_init -> . ID : CONSTANT = { opt_expr_list } ;
    (16) decl_init -> . ID : CONSTANT = expr ;
    (17) decl_init -> . ID : AUTO error
    (18) decl_init -> . ID : AUTO = { opt_expr_list } ;
    (19) decl_init -> . ID : AUTO = expr ;
    (20) decl_init -> . ID : type_simple = expr ;
    (69) expr2 -> . expr3
    (70) expr2 -> . expr2 LOR expr3
    (71) expr3 -> . expr4
    (72) expr3 -> . expr3 LAND expr4
    (73) expr4 -> . expr5
    (74) expr4 -> . expr4 GE expr5
    (75) expr4 -> . expr4 GT expr5
    (76) expr4 -> . expr4 LE expr5
    (77) expr4 -> . expr4 LT expr5
    (78) expr4 -> . expr4 NE expr5
    (79) expr4 -> . expr4 EQ expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    DO              shift and go to state 21
    WHILE           shift and go to state 22
    ID              shift and go to state 68
    {               shift and go to state 19
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    RETURN          shift and go to state 35
    PRINT           shift and go to state 36
    FOR             shift and go to state 37
    IF              shift and go to state 38
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    if_cond                        shift and go to state 31
    closed_stmt                    shift and go to state 208
    if_stmt_open                   shift and go to state 18
    stmt                           shift and go to state 82
    do_while_stmt                  shift and go to state 11
    while_stmt_closed              shift and go to state 12
    simple_stmt                    shift and go to state 13
    for_stmt_closed                shift and go to state 14
    if_stmt_closed                 shift and go to state 15
    open_stmt                      shift and go to state 8
    expr                           shift and go to state 20
    lval                           shift and go to state 24
    decl                           shift and go to state 67
    block_stmt                     shift and go to state 25
    break_stmt                     shift and go to state 26
    continue_stmt                  shift and go to state 27
    return_stmt                    shift and go to state 28
    print_stmt                     shift and go to state 29
    for_header                     shift and go to state 30
    while_stmt_open                shift and go to state 16
    for_stmt_open                  shift and go to state 17
    expr1                          shift and go to state 32
    decl_init                      shift and go to state 9
    expr2                          shift and go to state 39
    expr3                          shift and go to state 40
    expr4                          shift and go to state 41
    expr5                          shift and go to state 42
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 186

    (36) if_stmt_closed -> if_cond closed_stmt ELSE closed_stmt .
    ID              reduce using rule 36 (if_stmt_closed -> if_cond closed_stmt ELSE closed_stmt .)
    DO              reduce using rule 36 (if_stmt_closed -> if_cond closed_stmt ELSE closed_stmt .)
    WHILE           reduce using rule 36 (if_stmt_closed -> if_cond closed_stmt ELSE closed_stmt .)
    {               reduce using rule 36 (if_stmt_closed -> if_cond closed_stmt ELSE closed_stmt .)
    BREAK           reduce using rule 36 (if_stmt_closed -> if_cond closed_stmt ELSE closed_stmt .)
    CONTINUE        reduce using rule 36 (if_stmt_closed -> if_cond closed_stmt ELSE closed_stmt .)
    RETURN          reduce using rule 36 (if_stmt_closed -> if_cond closed_stmt ELSE closed_stmt .)
    PRINT           reduce using rule 36 (if_stmt_closed -> if_cond closed_stmt ELSE closed_stmt .)
    FOR             reduce using rule 36 (if_stmt_closed -> if_cond closed_stmt ELSE closed_stmt .)
    IF              reduce using rule 36 (if_stmt_closed -> if_cond closed_stmt ELSE closed_stmt .)
    !               reduce using rule 36 (if_stmt_closed -> if_cond closed_stmt ELSE closed_stmt .)
    +               reduce using rule 36 (if_stmt_closed -> if_cond closed_stmt ELSE closed_stmt .)
    -               reduce using rule 36 (if_stmt_closed -> if_cond closed_stmt ELSE closed_stmt .)
    DEC             reduce using rule 36 (if_stmt_closed -> if_cond closed_stmt ELSE closed_stmt .)
    INC             reduce using rule 36 (if_stmt_closed -> if_cond closed_stmt ELSE closed_stmt .)
    (               reduce using rule 36 (if_stmt_closed -> if_cond closed_stmt ELSE closed_stmt .)
    FALSE           reduce using rule 36 (if_stmt_closed -> if_cond closed_stmt ELSE closed_stmt .)
    TRUE            reduce using rule 36 (if_stmt_closed -> if_cond closed_stmt ELSE closed_stmt .)
    STRING_LITERAL  reduce using rule 36 (if_stmt_closed -> if_cond closed_stmt ELSE closed_stmt .)
    CHAR_LITERAL    reduce using rule 36 (if_stmt_closed -> if_cond closed_stmt ELSE closed_stmt .)
    FLOAT_LITERAL   reduce using rule 36 (if_stmt_closed -> if_cond closed_stmt ELSE closed_stmt .)
    INTEGER_LITERAL reduce using rule 36 (if_stmt_closed -> if_cond closed_stmt ELSE closed_stmt .)
    $end            reduce using rule 36 (if_stmt_closed -> if_cond closed_stmt ELSE closed_stmt .)
    }               reduce using rule 36 (if_stmt_closed -> if_cond closed_stmt ELSE closed_stmt .)
    ELSE            reduce using rule 36 (if_stmt_closed -> if_cond closed_stmt ELSE closed_stmt .)


state 187

    (37) if_stmt_open -> if_cond closed_stmt ELSE if_stmt_open .
    ID              reduce using rule 37 (if_stmt_open -> if_cond closed_stmt ELSE if_stmt_open .)
    DO              reduce using rule 37 (if_stmt_open -> if_cond closed_stmt ELSE if_stmt_open .)
    WHILE           reduce using rule 37 (if_stmt_open -> if_cond closed_stmt ELSE if_stmt_open .)
    {               reduce using rule 37 (if_stmt_open -> if_cond closed_stmt ELSE if_stmt_open .)
    BREAK           reduce using rule 37 (if_stmt_open -> if_cond closed_stmt ELSE if_stmt_open .)
    CONTINUE        reduce using rule 37 (if_stmt_open -> if_cond closed_stmt ELSE if_stmt_open .)
    RETURN          reduce using rule 37 (if_stmt_open -> if_cond closed_stmt ELSE if_stmt_open .)
    PRINT           reduce using rule 37 (if_stmt_open -> if_cond closed_stmt ELSE if_stmt_open .)
    FOR             reduce using rule 37 (if_stmt_open -> if_cond closed_stmt ELSE if_stmt_open .)
    IF              reduce using rule 37 (if_stmt_open -> if_cond closed_stmt ELSE if_stmt_open .)
    !               reduce using rule 37 (if_stmt_open -> if_cond closed_stmt ELSE if_stmt_open .)
    +               reduce using rule 37 (if_stmt_open -> if_cond closed_stmt ELSE if_stmt_open .)
    -               reduce using rule 37 (if_stmt_open -> if_cond closed_stmt ELSE if_stmt_open .)
    DEC             reduce using rule 37 (if_stmt_open -> if_cond closed_stmt ELSE if_stmt_open .)
    INC             reduce using rule 37 (if_stmt_open -> if_cond closed_stmt ELSE if_stmt_open .)
    (               reduce using rule 37 (if_stmt_open -> if_cond closed_stmt ELSE if_stmt_open .)
    FALSE           reduce using rule 37 (if_stmt_open -> if_cond closed_stmt ELSE if_stmt_open .)
    TRUE            reduce using rule 37 (if_stmt_open -> if_cond closed_stmt ELSE if_stmt_open .)
    STRING_LITERAL  reduce using rule 37 (if_stmt_open -> if_cond closed_stmt ELSE if_stmt_open .)
    CHAR_LITERAL    reduce using rule 37 (if_stmt_open -> if_cond closed_stmt ELSE if_stmt_open .)
    FLOAT_LITERAL   reduce using rule 37 (if_stmt_open -> if_cond closed_stmt ELSE if_stmt_open .)
    INTEGER_LITERAL reduce using rule 37 (if_stmt_open -> if_cond closed_stmt ELSE if_stmt_open .)
    $end            reduce using rule 37 (if_stmt_open -> if_cond closed_stmt ELSE if_stmt_open .)
    }               reduce using rule 37 (if_stmt_open -> if_cond closed_stmt ELSE if_stmt_open .)


state 188

    (61) expr_list -> expr , expr_list .
    ;               reduce using rule 61 (expr_list -> expr , expr_list .)
    )               reduce using rule 61 (expr_list -> expr , expr_list .)
    }               reduce using rule 61 (expr_list -> expr , expr_list .)


state 189

    (39) for_header -> FOR ( opt_expr ; . opt_expr ; opt_expr )
    (62) opt_expr -> . expr
    (63) opt_expr -> . empty
    (64) expr -> . expr1
    (130) empty -> .
    (65) expr1 -> . expr2
    (66) expr1 -> . lval = expr1
    (69) expr2 -> . expr3
    (70) expr2 -> . expr2 LOR expr3
    (67) lval -> . ID index
    (68) lval -> . ID
    (71) expr3 -> . expr4
    (72) expr3 -> . expr3 LAND expr4
    (73) expr4 -> . expr5
    (74) expr4 -> . expr4 GE expr5
    (75) expr4 -> . expr4 GT expr5
    (76) expr4 -> . expr4 LE expr5
    (77) expr4 -> . expr4 LT expr5
    (78) expr4 -> . expr4 NE expr5
    (79) expr4 -> . expr4 EQ expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    ;               reduce using rule 130 (empty -> .)
    ID              shift and go to state 77
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    opt_expr                       shift and go to state 209
    expr                           shift and go to state 86
    empty                          shift and go to state 87
    expr1                          shift and go to state 32
    expr2                          shift and go to state 39
    lval                           shift and go to state 76
    expr3                          shift and go to state 40
    expr4                          shift and go to state 41
    expr5                          shift and go to state 42
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 190

    (35) if_cond -> IF ( expr ) .
    DO              reduce using rule 35 (if_cond -> IF ( expr ) .)
    WHILE           reduce using rule 35 (if_cond -> IF ( expr ) .)
    ID              reduce using rule 35 (if_cond -> IF ( expr ) .)
    {               reduce using rule 35 (if_cond -> IF ( expr ) .)
    BREAK           reduce using rule 35 (if_cond -> IF ( expr ) .)
    CONTINUE        reduce using rule 35 (if_cond -> IF ( expr ) .)
    RETURN          reduce using rule 35 (if_cond -> IF ( expr ) .)
    PRINT           reduce using rule 35 (if_cond -> IF ( expr ) .)
    FOR             reduce using rule 35 (if_cond -> IF ( expr ) .)
    IF              reduce using rule 35 (if_cond -> IF ( expr ) .)
    !               reduce using rule 35 (if_cond -> IF ( expr ) .)
    +               reduce using rule 35 (if_cond -> IF ( expr ) .)
    -               reduce using rule 35 (if_cond -> IF ( expr ) .)
    DEC             reduce using rule 35 (if_cond -> IF ( expr ) .)
    INC             reduce using rule 35 (if_cond -> IF ( expr ) .)
    (               reduce using rule 35 (if_cond -> IF ( expr ) .)
    FALSE           reduce using rule 35 (if_cond -> IF ( expr ) .)
    TRUE            reduce using rule 35 (if_cond -> IF ( expr ) .)
    STRING_LITERAL  reduce using rule 35 (if_cond -> IF ( expr ) .)
    CHAR_LITERAL    reduce using rule 35 (if_cond -> IF ( expr ) .)
    FLOAT_LITERAL   reduce using rule 35 (if_cond -> IF ( expr ) .)
    INTEGER_LITERAL reduce using rule 35 (if_cond -> IF ( expr ) .)


state 191

    (12) decl_init -> ID : type_func = { . opt_stmt_list }
    (21) opt_stmt_list -> . empty
    (22) opt_stmt_list -> . stmt_list
    (130) empty -> .
    (23) stmt_list -> . stmt
    (24) stmt_list -> . stmt stmt_list
    (25) stmt -> . closed_stmt
    (26) stmt -> . open_stmt
    (27) closed_stmt -> . do_while_stmt
    (28) closed_stmt -> . while_stmt_closed
    (29) closed_stmt -> . simple_stmt
    (30) closed_stmt -> . for_stmt_closed
    (31) closed_stmt -> . if_stmt_closed
    (32) open_stmt -> . while_stmt_open
    (33) open_stmt -> . for_stmt_open
    (34) open_stmt -> . if_stmt_open
    (44) do_while_stmt -> . DO closed_stmt WHILE ( expr ) ;
    (43) while_stmt_closed -> . WHILE ( opt_expr ) closed_stmt
    (45) simple_stmt -> . lval = expr ;
    (46) simple_stmt -> . expr ;
    (47) simple_stmt -> . decl
    (48) simple_stmt -> . block_stmt
    (49) simple_stmt -> . break_stmt
    (50) simple_stmt -> . continue_stmt
    (51) simple_stmt -> . return_stmt
    (52) simple_stmt -> . print_stmt
    (41) for_stmt_closed -> . for_header closed_stmt
    (36) if_stmt_closed -> . if_cond closed_stmt ELSE closed_stmt
    (42) while_stmt_open -> . WHILE ( opt_expr ) open_stmt
    (40) for_stmt_open -> . for_header open_stmt
    (37) if_stmt_open -> . if_cond closed_stmt ELSE if_stmt_open
    (38) if_stmt_open -> . if_cond stmt
    (67) lval -> . ID index
    (68) lval -> . ID
    (64) expr -> . expr1
    (8) decl -> . decl_init
    (9) decl -> . ID : type_func ;
    (10) decl -> . ID : type_array_sized ;
    (11) decl -> . ID : type_simple ;
    (57) block_stmt -> . { stmt_list }
    (56) break_stmt -> . BREAK ;
    (55) continue_stmt -> . CONTINUE ;
    (54) return_stmt -> . RETURN opt_expr ;
    (53) print_stmt -> . PRINT opt_expr_list ;
    (39) for_header -> . FOR ( opt_expr ; opt_expr ; opt_expr )
    (35) if_cond -> . IF ( expr )
    (65) expr1 -> . expr2
    (66) expr1 -> . lval = expr1
    (12) decl_init -> . ID : type_func = { opt_stmt_list }
    (13) decl_init -> . ID : type_array_sized = { opt_expr_list } ;
    (14) decl_init -> . ID : CONSTANT error
    (15) decl_init -> . ID : CONSTANT = { opt_expr_list } ;
    (16) decl_init -> . ID : CONSTANT = expr ;
    (17) decl_init -> . ID : AUTO error
    (18) decl_init -> . ID : AUTO = { opt_expr_list } ;
    (19) decl_init -> . ID : AUTO = expr ;
    (20) decl_init -> . ID : type_simple = expr ;
    (69) expr2 -> . expr3
    (70) expr2 -> . expr2 LOR expr3
    (71) expr3 -> . expr4
    (72) expr3 -> . expr3 LAND expr4
    (73) expr4 -> . expr5
    (74) expr4 -> . expr4 GE expr5
    (75) expr4 -> . expr4 GT expr5
    (76) expr4 -> . expr4 LE expr5
    (77) expr4 -> . expr4 LT expr5
    (78) expr4 -> . expr4 NE expr5
    (79) expr4 -> . expr4 EQ expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    }               reduce using rule 130 (empty -> .)
    DO              shift and go to state 21
    WHILE           shift and go to state 22
    ID              shift and go to state 68
    {               shift and go to state 19
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    RETURN          shift and go to state 35
    PRINT           shift and go to state 36
    FOR             shift and go to state 37
    IF              shift and go to state 38
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    opt_stmt_list                  shift and go to state 210
    empty                          shift and go to state 211
    stmt_list                      shift and go to state 212
    stmt                           shift and go to state 66
    closed_stmt                    shift and go to state 7
    open_stmt                      shift and go to state 8
    do_while_stmt                  shift and go to state 11
    while_stmt_closed              shift and go to state 12
    simple_stmt                    shift and go to state 13
    for_stmt_closed                shift and go to state 14
    if_stmt_closed                 shift and go to state 15
    while_stmt_open                shift and go to state 16
    for_stmt_open                  shift and go to state 17
    if_stmt_open                   shift and go to state 18
    expr                           shift and go to state 20
    lval                           shift and go to state 24
    decl                           shift and go to state 67
    block_stmt                     shift and go to state 25
    break_stmt                     shift and go to state 26
    continue_stmt                  shift and go to state 27
    return_stmt                    shift and go to state 28
    print_stmt                     shift and go to state 29
    for_header                     shift and go to state 30
    if_cond                        shift and go to state 31
    expr1                          shift and go to state 32
    decl_init                      shift and go to state 9
    expr2                          shift and go to state 39
    expr3                          shift and go to state 40
    expr4                          shift and go to state 41
    expr5                          shift and go to state 42
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 192

    (13) decl_init -> ID : type_array_sized = { . opt_expr_list } ;
    (58) opt_expr_list -> . expr_list
    (59) opt_expr_list -> . empty
    (60) expr_list -> . expr
    (61) expr_list -> . expr , expr_list
    (130) empty -> .
    (64) expr -> . expr1
    (65) expr1 -> . expr2
    (66) expr1 -> . lval = expr1
    (69) expr2 -> . expr3
    (70) expr2 -> . expr2 LOR expr3
    (67) lval -> . ID index
    (68) lval -> . ID
    (71) expr3 -> . expr4
    (72) expr3 -> . expr3 LAND expr4
    (73) expr4 -> . expr5
    (74) expr4 -> . expr4 GE expr5
    (75) expr4 -> . expr4 GT expr5
    (76) expr4 -> . expr4 LE expr5
    (77) expr4 -> . expr4 LT expr5
    (78) expr4 -> . expr4 NE expr5
    (79) expr4 -> . expr4 EQ expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    }               reduce using rule 130 (empty -> .)
    ID              shift and go to state 77
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    opt_expr_list                  shift and go to state 213
    expr_list                      shift and go to state 89
    empty                          shift and go to state 90
    expr                           shift and go to state 91
    expr1                          shift and go to state 32
    expr2                          shift and go to state 39
    lval                           shift and go to state 76
    expr3                          shift and go to state 40
    expr4                          shift and go to state 41
    expr5                          shift and go to state 42
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 193

    (20) decl_init -> ID : type_simple = expr . ;
    ;               shift and go to state 214


state 194

    (15) decl_init -> ID : CONSTANT = { . opt_expr_list } ;
    (58) opt_expr_list -> . expr_list
    (59) opt_expr_list -> . empty
    (60) expr_list -> . expr
    (61) expr_list -> . expr , expr_list
    (130) empty -> .
    (64) expr -> . expr1
    (65) expr1 -> . expr2
    (66) expr1 -> . lval = expr1
    (69) expr2 -> . expr3
    (70) expr2 -> . expr2 LOR expr3
    (67) lval -> . ID index
    (68) lval -> . ID
    (71) expr3 -> . expr4
    (72) expr3 -> . expr3 LAND expr4
    (73) expr4 -> . expr5
    (74) expr4 -> . expr4 GE expr5
    (75) expr4 -> . expr4 GT expr5
    (76) expr4 -> . expr4 LE expr5
    (77) expr4 -> . expr4 LT expr5
    (78) expr4 -> . expr4 NE expr5
    (79) expr4 -> . expr4 EQ expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    }               reduce using rule 130 (empty -> .)
    ID              shift and go to state 77
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    opt_expr_list                  shift and go to state 215
    expr_list                      shift and go to state 89
    empty                          shift and go to state 90
    expr                           shift and go to state 91
    expr1                          shift and go to state 32
    expr2                          shift and go to state 39
    lval                           shift and go to state 76
    expr3                          shift and go to state 40
    expr4                          shift and go to state 41
    expr5                          shift and go to state 42
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 195

    (16) decl_init -> ID : CONSTANT = expr . ;
    ;               shift and go to state 216


state 196

    (18) decl_init -> ID : AUTO = { . opt_expr_list } ;
    (58) opt_expr_list -> . expr_list
    (59) opt_expr_list -> . empty
    (60) expr_list -> . expr
    (61) expr_list -> . expr , expr_list
    (130) empty -> .
    (64) expr -> . expr1
    (65) expr1 -> . expr2
    (66) expr1 -> . lval = expr1
    (69) expr2 -> . expr3
    (70) expr2 -> . expr2 LOR expr3
    (67) lval -> . ID index
    (68) lval -> . ID
    (71) expr3 -> . expr4
    (72) expr3 -> . expr3 LAND expr4
    (73) expr4 -> . expr5
    (74) expr4 -> . expr4 GE expr5
    (75) expr4 -> . expr4 GT expr5
    (76) expr4 -> . expr4 LE expr5
    (77) expr4 -> . expr4 LT expr5
    (78) expr4 -> . expr4 NE expr5
    (79) expr4 -> . expr4 EQ expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    }               reduce using rule 130 (empty -> .)
    ID              shift and go to state 77
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    opt_expr_list                  shift and go to state 217
    expr_list                      shift and go to state 89
    empty                          shift and go to state 90
    expr                           shift and go to state 91
    expr1                          shift and go to state 32
    expr2                          shift and go to state 39
    lval                           shift and go to state 76
    expr3                          shift and go to state 40
    expr4                          shift and go to state 41
    expr5                          shift and go to state 42
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 197

    (19) decl_init -> ID : AUTO = expr . ;
    ;               shift and go to state 218


state 198

    (120) type_func -> FUNCTION type_array_sized ( . opt_param_list )
    (123) opt_param_list -> . param_list
    (124) opt_param_list -> . empty
    (125) param_list -> . param
    (126) param_list -> . param_list , param
    (130) empty -> .
    (127) param -> . ID : type_array_sized
    (128) param -> . ID : type_array
    (129) param -> . ID : type_simple
    )               reduce using rule 130 (empty -> .)
    ID              shift and go to state 223

    opt_param_list                 shift and go to state 219
    param_list                     shift and go to state 220
    empty                          shift and go to state 221
    param                          shift and go to state 222

state 199

    (121) type_func -> FUNCTION type_array ( . opt_param_list )
    (123) opt_param_list -> . param_list
    (124) opt_param_list -> . empty
    (125) param_list -> . param
    (126) param_list -> . param_list , param
    (130) empty -> .
    (127) param -> . ID : type_array_sized
    (128) param -> . ID : type_array
    (129) param -> . ID : type_simple
    )               reduce using rule 130 (empty -> .)
    ID              shift and go to state 223

    opt_param_list                 shift and go to state 224
    param_list                     shift and go to state 220
    empty                          shift and go to state 221
    param                          shift and go to state 222

state 200

    (122) type_func -> FUNCTION type_simple ( . opt_param_list )
    (123) opt_param_list -> . param_list
    (124) opt_param_list -> . empty
    (125) param_list -> . param
    (126) param_list -> . param_list , param
    (130) empty -> .
    (127) param -> . ID : type_array_sized
    (128) param -> . ID : type_array
    (129) param -> . ID : type_simple
    )               reduce using rule 130 (empty -> .)
    ID              shift and go to state 223

    opt_param_list                 shift and go to state 225
    param_list                     shift and go to state 220
    empty                          shift and go to state 221
    param                          shift and go to state 222

state 201

    (118) type_array -> ARRAY [ . ] type_array
    (119) type_array -> ARRAY [ . ] type_simple
    (102) index -> [ . expr ]
    (64) expr -> . expr1
    (65) expr1 -> . expr2
    (66) expr1 -> . lval = expr1
    (69) expr2 -> . expr3
    (70) expr2 -> . expr2 LOR expr3
    (67) lval -> . ID index
    (68) lval -> . ID
    (71) expr3 -> . expr4
    (72) expr3 -> . expr3 LAND expr4
    (73) expr4 -> . expr5
    (74) expr4 -> . expr4 GE expr5
    (75) expr4 -> . expr4 GT expr5
    (76) expr4 -> . expr4 LE expr5
    (77) expr4 -> . expr4 LT expr5
    (78) expr4 -> . expr4 NE expr5
    (79) expr4 -> . expr4 EQ expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    ]               shift and go to state 226
    ID              shift and go to state 77
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    expr                           shift and go to state 130
    expr1                          shift and go to state 32
    expr2                          shift and go to state 39
    lval                           shift and go to state 76
    expr3                          shift and go to state 40
    expr4                          shift and go to state 41
    expr5                          shift and go to state 42
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 202

    (116) type_array_sized -> ARRAY index type_array_sized .
    ;               reduce using rule 116 (type_array_sized -> ARRAY index type_array_sized .)
    =               reduce using rule 116 (type_array_sized -> ARRAY index type_array_sized .)
    (               reduce using rule 116 (type_array_sized -> ARRAY index type_array_sized .)
    ,               reduce using rule 116 (type_array_sized -> ARRAY index type_array_sized .)
    )               reduce using rule 116 (type_array_sized -> ARRAY index type_array_sized .)


state 203

    (117) type_array_sized -> ARRAY index type_simple .
    ;               reduce using rule 117 (type_array_sized -> ARRAY index type_simple .)
    =               reduce using rule 117 (type_array_sized -> ARRAY index type_simple .)
    (               reduce using rule 117 (type_array_sized -> ARRAY index type_simple .)
    ,               reduce using rule 117 (type_array_sized -> ARRAY index type_simple .)
    )               reduce using rule 117 (type_array_sized -> ARRAY index type_simple .)


state 204

    (44) do_while_stmt -> DO closed_stmt WHILE ( expr . ) ;
    )               shift and go to state 227


state 205

    (43) while_stmt_closed -> WHILE ( opt_expr ) . closed_stmt
    (27) closed_stmt -> . do_while_stmt
    (28) closed_stmt -> . while_stmt_closed
    (29) closed_stmt -> . simple_stmt
    (30) closed_stmt -> . for_stmt_closed
    (31) closed_stmt -> . if_stmt_closed
    (44) do_while_stmt -> . DO closed_stmt WHILE ( expr ) ;
    (43) while_stmt_closed -> . WHILE ( opt_expr ) closed_stmt
    (45) simple_stmt -> . lval = expr ;
    (46) simple_stmt -> . expr ;
    (47) simple_stmt -> . decl
    (48) simple_stmt -> . block_stmt
    (49) simple_stmt -> . break_stmt
    (50) simple_stmt -> . continue_stmt
    (51) simple_stmt -> . return_stmt
    (52) simple_stmt -> . print_stmt
    (41) for_stmt_closed -> . for_header closed_stmt
    (36) if_stmt_closed -> . if_cond closed_stmt ELSE closed_stmt
    (67) lval -> . ID index
    (68) lval -> . ID
    (64) expr -> . expr1
    (8) decl -> . decl_init
    (9) decl -> . ID : type_func ;
    (10) decl -> . ID : type_array_sized ;
    (11) decl -> . ID : type_simple ;
    (57) block_stmt -> . { stmt_list }
    (56) break_stmt -> . BREAK ;
    (55) continue_stmt -> . CONTINUE ;
    (54) return_stmt -> . RETURN opt_expr ;
    (53) print_stmt -> . PRINT opt_expr_list ;
    (39) for_header -> . FOR ( opt_expr ; opt_expr ; opt_expr )
    (35) if_cond -> . IF ( expr )
    (65) expr1 -> . expr2
    (66) expr1 -> . lval = expr1
    (12) decl_init -> . ID : type_func = { opt_stmt_list }
    (13) decl_init -> . ID : type_array_sized = { opt_expr_list } ;
    (14) decl_init -> . ID : CONSTANT error
    (15) decl_init -> . ID : CONSTANT = { opt_expr_list } ;
    (16) decl_init -> . ID : CONSTANT = expr ;
    (17) decl_init -> . ID : AUTO error
    (18) decl_init -> . ID : AUTO = { opt_expr_list } ;
    (19) decl_init -> . ID : AUTO = expr ;
    (20) decl_init -> . ID : type_simple = expr ;
    (69) expr2 -> . expr3
    (70) expr2 -> . expr2 LOR expr3
    (71) expr3 -> . expr4
    (72) expr3 -> . expr3 LAND expr4
    (73) expr4 -> . expr5
    (74) expr4 -> . expr4 GE expr5
    (75) expr4 -> . expr4 GT expr5
    (76) expr4 -> . expr4 LE expr5
    (77) expr4 -> . expr4 LT expr5
    (78) expr4 -> . expr4 NE expr5
    (79) expr4 -> . expr4 EQ expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    DO              shift and go to state 21
    WHILE           shift and go to state 71
    ID              shift and go to state 68
    {               shift and go to state 19
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    RETURN          shift and go to state 35
    PRINT           shift and go to state 36
    FOR             shift and go to state 37
    IF              shift and go to state 38
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    closed_stmt                    shift and go to state 206
    do_while_stmt                  shift and go to state 11
    while_stmt_closed              shift and go to state 12
    simple_stmt                    shift and go to state 13
    for_stmt_closed                shift and go to state 14
    if_stmt_closed                 shift and go to state 15
    expr                           shift and go to state 20
    lval                           shift and go to state 24
    decl                           shift and go to state 67
    block_stmt                     shift and go to state 25
    break_stmt                     shift and go to state 26
    continue_stmt                  shift and go to state 27
    return_stmt                    shift and go to state 28
    print_stmt                     shift and go to state 29
    for_header                     shift and go to state 72
    if_cond                        shift and go to state 73
    expr1                          shift and go to state 32
    decl_init                      shift and go to state 9
    expr2                          shift and go to state 39
    expr3                          shift and go to state 40
    expr4                          shift and go to state 41
    expr5                          shift and go to state 42
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 206

    (43) while_stmt_closed -> WHILE ( opt_expr ) closed_stmt .
    ID              reduce using rule 43 (while_stmt_closed -> WHILE ( opt_expr ) closed_stmt .)
    DO              reduce using rule 43 (while_stmt_closed -> WHILE ( opt_expr ) closed_stmt .)
    WHILE           reduce using rule 43 (while_stmt_closed -> WHILE ( opt_expr ) closed_stmt .)
    {               reduce using rule 43 (while_stmt_closed -> WHILE ( opt_expr ) closed_stmt .)
    BREAK           reduce using rule 43 (while_stmt_closed -> WHILE ( opt_expr ) closed_stmt .)
    CONTINUE        reduce using rule 43 (while_stmt_closed -> WHILE ( opt_expr ) closed_stmt .)
    RETURN          reduce using rule 43 (while_stmt_closed -> WHILE ( opt_expr ) closed_stmt .)
    PRINT           reduce using rule 43 (while_stmt_closed -> WHILE ( opt_expr ) closed_stmt .)
    FOR             reduce using rule 43 (while_stmt_closed -> WHILE ( opt_expr ) closed_stmt .)
    IF              reduce using rule 43 (while_stmt_closed -> WHILE ( opt_expr ) closed_stmt .)
    !               reduce using rule 43 (while_stmt_closed -> WHILE ( opt_expr ) closed_stmt .)
    +               reduce using rule 43 (while_stmt_closed -> WHILE ( opt_expr ) closed_stmt .)
    -               reduce using rule 43 (while_stmt_closed -> WHILE ( opt_expr ) closed_stmt .)
    DEC             reduce using rule 43 (while_stmt_closed -> WHILE ( opt_expr ) closed_stmt .)
    INC             reduce using rule 43 (while_stmt_closed -> WHILE ( opt_expr ) closed_stmt .)
    (               reduce using rule 43 (while_stmt_closed -> WHILE ( opt_expr ) closed_stmt .)
    FALSE           reduce using rule 43 (while_stmt_closed -> WHILE ( opt_expr ) closed_stmt .)
    TRUE            reduce using rule 43 (while_stmt_closed -> WHILE ( opt_expr ) closed_stmt .)
    STRING_LITERAL  reduce using rule 43 (while_stmt_closed -> WHILE ( opt_expr ) closed_stmt .)
    CHAR_LITERAL    reduce using rule 43 (while_stmt_closed -> WHILE ( opt_expr ) closed_stmt .)
    FLOAT_LITERAL   reduce using rule 43 (while_stmt_closed -> WHILE ( opt_expr ) closed_stmt .)
    INTEGER_LITERAL reduce using rule 43 (while_stmt_closed -> WHILE ( opt_expr ) closed_stmt .)
    $end            reduce using rule 43 (while_stmt_closed -> WHILE ( opt_expr ) closed_stmt .)
    }               reduce using rule 43 (while_stmt_closed -> WHILE ( opt_expr ) closed_stmt .)
    ELSE            reduce using rule 43 (while_stmt_closed -> WHILE ( opt_expr ) closed_stmt .)


state 207

    (42) while_stmt_open -> WHILE ( opt_expr ) open_stmt .
    ID              reduce using rule 42 (while_stmt_open -> WHILE ( opt_expr ) open_stmt .)
    DO              reduce using rule 42 (while_stmt_open -> WHILE ( opt_expr ) open_stmt .)
    WHILE           reduce using rule 42 (while_stmt_open -> WHILE ( opt_expr ) open_stmt .)
    {               reduce using rule 42 (while_stmt_open -> WHILE ( opt_expr ) open_stmt .)
    BREAK           reduce using rule 42 (while_stmt_open -> WHILE ( opt_expr ) open_stmt .)
    CONTINUE        reduce using rule 42 (while_stmt_open -> WHILE ( opt_expr ) open_stmt .)
    RETURN          reduce using rule 42 (while_stmt_open -> WHILE ( opt_expr ) open_stmt .)
    PRINT           reduce using rule 42 (while_stmt_open -> WHILE ( opt_expr ) open_stmt .)
    FOR             reduce using rule 42 (while_stmt_open -> WHILE ( opt_expr ) open_stmt .)
    IF              reduce using rule 42 (while_stmt_open -> WHILE ( opt_expr ) open_stmt .)
    !               reduce using rule 42 (while_stmt_open -> WHILE ( opt_expr ) open_stmt .)
    +               reduce using rule 42 (while_stmt_open -> WHILE ( opt_expr ) open_stmt .)
    -               reduce using rule 42 (while_stmt_open -> WHILE ( opt_expr ) open_stmt .)
    DEC             reduce using rule 42 (while_stmt_open -> WHILE ( opt_expr ) open_stmt .)
    INC             reduce using rule 42 (while_stmt_open -> WHILE ( opt_expr ) open_stmt .)
    (               reduce using rule 42 (while_stmt_open -> WHILE ( opt_expr ) open_stmt .)
    FALSE           reduce using rule 42 (while_stmt_open -> WHILE ( opt_expr ) open_stmt .)
    TRUE            reduce using rule 42 (while_stmt_open -> WHILE ( opt_expr ) open_stmt .)
    STRING_LITERAL  reduce using rule 42 (while_stmt_open -> WHILE ( opt_expr ) open_stmt .)
    CHAR_LITERAL    reduce using rule 42 (while_stmt_open -> WHILE ( opt_expr ) open_stmt .)
    FLOAT_LITERAL   reduce using rule 42 (while_stmt_open -> WHILE ( opt_expr ) open_stmt .)
    INTEGER_LITERAL reduce using rule 42 (while_stmt_open -> WHILE ( opt_expr ) open_stmt .)
    $end            reduce using rule 42 (while_stmt_open -> WHILE ( opt_expr ) open_stmt .)
    }               reduce using rule 42 (while_stmt_open -> WHILE ( opt_expr ) open_stmt .)


state 208

    (37) if_stmt_open -> if_cond closed_stmt . ELSE if_stmt_open
    (36) if_stmt_closed -> if_cond closed_stmt . ELSE closed_stmt
    (25) stmt -> closed_stmt .
    ELSE            shift and go to state 228
    ID              reduce using rule 25 (stmt -> closed_stmt .)
    DO              reduce using rule 25 (stmt -> closed_stmt .)
    WHILE           reduce using rule 25 (stmt -> closed_stmt .)
    {               reduce using rule 25 (stmt -> closed_stmt .)
    BREAK           reduce using rule 25 (stmt -> closed_stmt .)
    CONTINUE        reduce using rule 25 (stmt -> closed_stmt .)
    RETURN          reduce using rule 25 (stmt -> closed_stmt .)
    PRINT           reduce using rule 25 (stmt -> closed_stmt .)
    FOR             reduce using rule 25 (stmt -> closed_stmt .)
    IF              reduce using rule 25 (stmt -> closed_stmt .)
    !               reduce using rule 25 (stmt -> closed_stmt .)
    +               reduce using rule 25 (stmt -> closed_stmt .)
    -               reduce using rule 25 (stmt -> closed_stmt .)
    DEC             reduce using rule 25 (stmt -> closed_stmt .)
    INC             reduce using rule 25 (stmt -> closed_stmt .)
    (               reduce using rule 25 (stmt -> closed_stmt .)
    FALSE           reduce using rule 25 (stmt -> closed_stmt .)
    TRUE            reduce using rule 25 (stmt -> closed_stmt .)
    STRING_LITERAL  reduce using rule 25 (stmt -> closed_stmt .)
    CHAR_LITERAL    reduce using rule 25 (stmt -> closed_stmt .)
    FLOAT_LITERAL   reduce using rule 25 (stmt -> closed_stmt .)
    INTEGER_LITERAL reduce using rule 25 (stmt -> closed_stmt .)
    $end            reduce using rule 25 (stmt -> closed_stmt .)
    }               reduce using rule 25 (stmt -> closed_stmt .)


state 209

    (39) for_header -> FOR ( opt_expr ; opt_expr . ; opt_expr )
    ;               shift and go to state 229


state 210

    (12) decl_init -> ID : type_func = { opt_stmt_list . }
    }               shift and go to state 230


state 211

    (21) opt_stmt_list -> empty .
    }               reduce using rule 21 (opt_stmt_list -> empty .)


state 212

    (22) opt_stmt_list -> stmt_list .
    }               reduce using rule 22 (opt_stmt_list -> stmt_list .)


state 213

    (13) decl_init -> ID : type_array_sized = { opt_expr_list . } ;
    }               shift and go to state 231


state 214

    (20) decl_init -> ID : type_simple = expr ; .
    ID              reduce using rule 20 (decl_init -> ID : type_simple = expr ; .)
    DO              reduce using rule 20 (decl_init -> ID : type_simple = expr ; .)
    WHILE           reduce using rule 20 (decl_init -> ID : type_simple = expr ; .)
    {               reduce using rule 20 (decl_init -> ID : type_simple = expr ; .)
    BREAK           reduce using rule 20 (decl_init -> ID : type_simple = expr ; .)
    CONTINUE        reduce using rule 20 (decl_init -> ID : type_simple = expr ; .)
    RETURN          reduce using rule 20 (decl_init -> ID : type_simple = expr ; .)
    PRINT           reduce using rule 20 (decl_init -> ID : type_simple = expr ; .)
    FOR             reduce using rule 20 (decl_init -> ID : type_simple = expr ; .)
    IF              reduce using rule 20 (decl_init -> ID : type_simple = expr ; .)
    !               reduce using rule 20 (decl_init -> ID : type_simple = expr ; .)
    +               reduce using rule 20 (decl_init -> ID : type_simple = expr ; .)
    -               reduce using rule 20 (decl_init -> ID : type_simple = expr ; .)
    DEC             reduce using rule 20 (decl_init -> ID : type_simple = expr ; .)
    INC             reduce using rule 20 (decl_init -> ID : type_simple = expr ; .)
    (               reduce using rule 20 (decl_init -> ID : type_simple = expr ; .)
    FALSE           reduce using rule 20 (decl_init -> ID : type_simple = expr ; .)
    TRUE            reduce using rule 20 (decl_init -> ID : type_simple = expr ; .)
    STRING_LITERAL  reduce using rule 20 (decl_init -> ID : type_simple = expr ; .)
    CHAR_LITERAL    reduce using rule 20 (decl_init -> ID : type_simple = expr ; .)
    FLOAT_LITERAL   reduce using rule 20 (decl_init -> ID : type_simple = expr ; .)
    INTEGER_LITERAL reduce using rule 20 (decl_init -> ID : type_simple = expr ; .)
    $end            reduce using rule 20 (decl_init -> ID : type_simple = expr ; .)
    }               reduce using rule 20 (decl_init -> ID : type_simple = expr ; .)
    ELSE            reduce using rule 20 (decl_init -> ID : type_simple = expr ; .)


state 215

    (15) decl_init -> ID : CONSTANT = { opt_expr_list . } ;
    }               shift and go to state 232


state 216

    (16) decl_init -> ID : CONSTANT = expr ; .
    ID              reduce using rule 16 (decl_init -> ID : CONSTANT = expr ; .)
    DO              reduce using rule 16 (decl_init -> ID : CONSTANT = expr ; .)
    WHILE           reduce using rule 16 (decl_init -> ID : CONSTANT = expr ; .)
    {               reduce using rule 16 (decl_init -> ID : CONSTANT = expr ; .)
    BREAK           reduce using rule 16 (decl_init -> ID : CONSTANT = expr ; .)
    CONTINUE        reduce using rule 16 (decl_init -> ID : CONSTANT = expr ; .)
    RETURN          reduce using rule 16 (decl_init -> ID : CONSTANT = expr ; .)
    PRINT           reduce using rule 16 (decl_init -> ID : CONSTANT = expr ; .)
    FOR             reduce using rule 16 (decl_init -> ID : CONSTANT = expr ; .)
    IF              reduce using rule 16 (decl_init -> ID : CONSTANT = expr ; .)
    !               reduce using rule 16 (decl_init -> ID : CONSTANT = expr ; .)
    +               reduce using rule 16 (decl_init -> ID : CONSTANT = expr ; .)
    -               reduce using rule 16 (decl_init -> ID : CONSTANT = expr ; .)
    DEC             reduce using rule 16 (decl_init -> ID : CONSTANT = expr ; .)
    INC             reduce using rule 16 (decl_init -> ID : CONSTANT = expr ; .)
    (               reduce using rule 16 (decl_init -> ID : CONSTANT = expr ; .)
    FALSE           reduce using rule 16 (decl_init -> ID : CONSTANT = expr ; .)
    TRUE            reduce using rule 16 (decl_init -> ID : CONSTANT = expr ; .)
    STRING_LITERAL  reduce using rule 16 (decl_init -> ID : CONSTANT = expr ; .)
    CHAR_LITERAL    reduce using rule 16 (decl_init -> ID : CONSTANT = expr ; .)
    FLOAT_LITERAL   reduce using rule 16 (decl_init -> ID : CONSTANT = expr ; .)
    INTEGER_LITERAL reduce using rule 16 (decl_init -> ID : CONSTANT = expr ; .)
    $end            reduce using rule 16 (decl_init -> ID : CONSTANT = expr ; .)
    }               reduce using rule 16 (decl_init -> ID : CONSTANT = expr ; .)
    ELSE            reduce using rule 16 (decl_init -> ID : CONSTANT = expr ; .)


state 217

    (18) decl_init -> ID : AUTO = { opt_expr_list . } ;
    }               shift and go to state 233


state 218

    (19) decl_init -> ID : AUTO = expr ; .
    ID              reduce using rule 19 (decl_init -> ID : AUTO = expr ; .)
    DO              reduce using rule 19 (decl_init -> ID : AUTO = expr ; .)
    WHILE           reduce using rule 19 (decl_init -> ID : AUTO = expr ; .)
    {               reduce using rule 19 (decl_init -> ID : AUTO = expr ; .)
    BREAK           reduce using rule 19 (decl_init -> ID : AUTO = expr ; .)
    CONTINUE        reduce using rule 19 (decl_init -> ID : AUTO = expr ; .)
    RETURN          reduce using rule 19 (decl_init -> ID : AUTO = expr ; .)
    PRINT           reduce using rule 19 (decl_init -> ID : AUTO = expr ; .)
    FOR             reduce using rule 19 (decl_init -> ID : AUTO = expr ; .)
    IF              reduce using rule 19 (decl_init -> ID : AUTO = expr ; .)
    !               reduce using rule 19 (decl_init -> ID : AUTO = expr ; .)
    +               reduce using rule 19 (decl_init -> ID : AUTO = expr ; .)
    -               reduce using rule 19 (decl_init -> ID : AUTO = expr ; .)
    DEC             reduce using rule 19 (decl_init -> ID : AUTO = expr ; .)
    INC             reduce using rule 19 (decl_init -> ID : AUTO = expr ; .)
    (               reduce using rule 19 (decl_init -> ID : AUTO = expr ; .)
    FALSE           reduce using rule 19 (decl_init -> ID : AUTO = expr ; .)
    TRUE            reduce using rule 19 (decl_init -> ID : AUTO = expr ; .)
    STRING_LITERAL  reduce using rule 19 (decl_init -> ID : AUTO = expr ; .)
    CHAR_LITERAL    reduce using rule 19 (decl_init -> ID : AUTO = expr ; .)
    FLOAT_LITERAL   reduce using rule 19 (decl_init -> ID : AUTO = expr ; .)
    INTEGER_LITERAL reduce using rule 19 (decl_init -> ID : AUTO = expr ; .)
    $end            reduce using rule 19 (decl_init -> ID : AUTO = expr ; .)
    }               reduce using rule 19 (decl_init -> ID : AUTO = expr ; .)
    ELSE            reduce using rule 19 (decl_init -> ID : AUTO = expr ; .)


state 219

    (120) type_func -> FUNCTION type_array_sized ( opt_param_list . )
    )               shift and go to state 234


state 220

    (123) opt_param_list -> param_list .
    (126) param_list -> param_list . , param
    )               reduce using rule 123 (opt_param_list -> param_list .)
    ,               shift and go to state 235


state 221

    (124) opt_param_list -> empty .
    )               reduce using rule 124 (opt_param_list -> empty .)


state 222

    (125) param_list -> param .
    ,               reduce using rule 125 (param_list -> param .)
    )               reduce using rule 125 (param_list -> param .)


state 223

    (127) param -> ID . : type_array_sized
    (128) param -> ID . : type_array
    (129) param -> ID . : type_simple
    :               shift and go to state 236


state 224

    (121) type_func -> FUNCTION type_array ( opt_param_list . )
    )               shift and go to state 237


state 225

    (122) type_func -> FUNCTION type_simple ( opt_param_list . )
    )               shift and go to state 238


state 226

    (118) type_array -> ARRAY [ ] . type_array
    (119) type_array -> ARRAY [ ] . type_simple
    (118) type_array -> . ARRAY [ ] type_array
    (119) type_array -> . ARRAY [ ] type_simple
    (110) type_simple -> . VOID
    (111) type_simple -> . STRING
    (112) type_simple -> . CHAR
    (113) type_simple -> . BOOLEAN
    (114) type_simple -> . FLOAT
    (115) type_simple -> . INTEGER
    ARRAY           shift and go to state 239
    VOID            shift and go to state 123
    STRING          shift and go to state 124
    CHAR            shift and go to state 125
    BOOLEAN         shift and go to state 126
    FLOAT           shift and go to state 127
    INTEGER         shift and go to state 128

    type_array                     shift and go to state 240
    type_simple                    shift and go to state 241

state 227

    (44) do_while_stmt -> DO closed_stmt WHILE ( expr ) . ;
    ;               shift and go to state 242


state 228

    (37) if_stmt_open -> if_cond closed_stmt ELSE . if_stmt_open
    (36) if_stmt_closed -> if_cond closed_stmt ELSE . closed_stmt
    (37) if_stmt_open -> . if_cond closed_stmt ELSE if_stmt_open
    (38) if_stmt_open -> . if_cond stmt
    (27) closed_stmt -> . do_while_stmt
    (28) closed_stmt -> . while_stmt_closed
    (29) closed_stmt -> . simple_stmt
    (30) closed_stmt -> . for_stmt_closed
    (31) closed_stmt -> . if_stmt_closed
    (35) if_cond -> . IF ( expr )
    (44) do_while_stmt -> . DO closed_stmt WHILE ( expr ) ;
    (43) while_stmt_closed -> . WHILE ( opt_expr ) closed_stmt
    (45) simple_stmt -> . lval = expr ;
    (46) simple_stmt -> . expr ;
    (47) simple_stmt -> . decl
    (48) simple_stmt -> . block_stmt
    (49) simple_stmt -> . break_stmt
    (50) simple_stmt -> . continue_stmt
    (51) simple_stmt -> . return_stmt
    (52) simple_stmt -> . print_stmt
    (41) for_stmt_closed -> . for_header closed_stmt
    (36) if_stmt_closed -> . if_cond closed_stmt ELSE closed_stmt
    (67) lval -> . ID index
    (68) lval -> . ID
    (64) expr -> . expr1
    (8) decl -> . decl_init
    (9) decl -> . ID : type_func ;
    (10) decl -> . ID : type_array_sized ;
    (11) decl -> . ID : type_simple ;
    (57) block_stmt -> . { stmt_list }
    (56) break_stmt -> . BREAK ;
    (55) continue_stmt -> . CONTINUE ;
    (54) return_stmt -> . RETURN opt_expr ;
    (53) print_stmt -> . PRINT opt_expr_list ;
    (39) for_header -> . FOR ( opt_expr ; opt_expr ; opt_expr )
    (65) expr1 -> . expr2
    (66) expr1 -> . lval = expr1
    (12) decl_init -> . ID : type_func = { opt_stmt_list }
    (13) decl_init -> . ID : type_array_sized = { opt_expr_list } ;
    (14) decl_init -> . ID : CONSTANT error
    (15) decl_init -> . ID : CONSTANT = { opt_expr_list } ;
    (16) decl_init -> . ID : CONSTANT = expr ;
    (17) decl_init -> . ID : AUTO error
    (18) decl_init -> . ID : AUTO = { opt_expr_list } ;
    (19) decl_init -> . ID : AUTO = expr ;
    (20) decl_init -> . ID : type_simple = expr ;
    (69) expr2 -> . expr3
    (70) expr2 -> . expr2 LOR expr3
    (71) expr3 -> . expr4
    (72) expr3 -> . expr3 LAND expr4
    (73) expr4 -> . expr5
    (74) expr4 -> . expr4 GE expr5
    (75) expr4 -> . expr4 GT expr5
    (76) expr4 -> . expr4 LE expr5
    (77) expr4 -> . expr4 LT expr5
    (78) expr4 -> . expr4 NE expr5
    (79) expr4 -> . expr4 EQ expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    IF              shift and go to state 38
    DO              shift and go to state 21
    WHILE           shift and go to state 71
    ID              shift and go to state 68
    {               shift and go to state 19
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    RETURN          shift and go to state 35
    PRINT           shift and go to state 36
    FOR             shift and go to state 37
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    if_cond                        shift and go to state 185
    closed_stmt                    shift and go to state 186
    if_stmt_open                   shift and go to state 187
    do_while_stmt                  shift and go to state 11
    while_stmt_closed              shift and go to state 12
    simple_stmt                    shift and go to state 13
    for_stmt_closed                shift and go to state 14
    if_stmt_closed                 shift and go to state 15
    expr                           shift and go to state 20
    lval                           shift and go to state 24
    decl                           shift and go to state 67
    block_stmt                     shift and go to state 25
    break_stmt                     shift and go to state 26
    continue_stmt                  shift and go to state 27
    return_stmt                    shift and go to state 28
    print_stmt                     shift and go to state 29
    for_header                     shift and go to state 72
    expr1                          shift and go to state 32
    decl_init                      shift and go to state 9
    expr2                          shift and go to state 39
    expr3                          shift and go to state 40
    expr4                          shift and go to state 41
    expr5                          shift and go to state 42
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 229

    (39) for_header -> FOR ( opt_expr ; opt_expr ; . opt_expr )
    (62) opt_expr -> . expr
    (63) opt_expr -> . empty
    (64) expr -> . expr1
    (130) empty -> .
    (65) expr1 -> . expr2
    (66) expr1 -> . lval = expr1
    (69) expr2 -> . expr3
    (70) expr2 -> . expr2 LOR expr3
    (67) lval -> . ID index
    (68) lval -> . ID
    (71) expr3 -> . expr4
    (72) expr3 -> . expr3 LAND expr4
    (73) expr4 -> . expr5
    (74) expr4 -> . expr4 GE expr5
    (75) expr4 -> . expr4 GT expr5
    (76) expr4 -> . expr4 LE expr5
    (77) expr4 -> . expr4 LT expr5
    (78) expr4 -> . expr4 NE expr5
    (79) expr4 -> . expr4 EQ expr5
    (80) expr5 -> . expr6
    (81) expr5 -> . expr5 - expr6
    (82) expr5 -> . expr5 + expr6
    (83) expr6 -> . expr7
    (84) expr6 -> . expr6 % expr7
    (85) expr6 -> . expr6 / expr7
    (86) expr6 -> . expr6 * expr7
    (87) expr7 -> . expr8
    (88) expr7 -> . expr7 ^ expr8
    (89) expr8 -> . expr9
    (90) expr8 -> . ! expr8
    (91) expr8 -> . + expr8
    (92) expr8 -> . - expr8
    (93) expr9 -> . group
    (94) expr9 -> . DEC expr9
    (95) expr9 -> . expr9 DEC
    (96) expr9 -> . INC expr9
    (97) expr9 -> . expr9 INC
    (98) group -> . factor
    (99) group -> . ID index
    (100) group -> . ID ( opt_expr_list )
    (101) group -> . ( expr )
    (103) factor -> . FALSE
    (104) factor -> . TRUE
    (105) factor -> . STRING_LITERAL
    (106) factor -> . CHAR_LITERAL
    (107) factor -> . FLOAT_LITERAL
    (108) factor -> . INTEGER_LITERAL
    (109) factor -> . ID
    )               reduce using rule 130 (empty -> .)
    ID              shift and go to state 77
    !               shift and go to state 49
    +               shift and go to state 45
    -               shift and go to state 44
    DEC             shift and go to state 51
    INC             shift and go to state 52
    (               shift and go to state 23
    FALSE           shift and go to state 54
    TRUE            shift and go to state 55
    STRING_LITERAL  shift and go to state 56
    CHAR_LITERAL    shift and go to state 57
    FLOAT_LITERAL   shift and go to state 58
    INTEGER_LITERAL shift and go to state 59

    opt_expr                       shift and go to state 243
    expr                           shift and go to state 86
    empty                          shift and go to state 87
    expr1                          shift and go to state 32
    expr2                          shift and go to state 39
    lval                           shift and go to state 76
    expr3                          shift and go to state 40
    expr4                          shift and go to state 41
    expr5                          shift and go to state 42
    expr6                          shift and go to state 43
    expr7                          shift and go to state 46
    expr8                          shift and go to state 47
    expr9                          shift and go to state 48
    group                          shift and go to state 50
    factor                         shift and go to state 53

state 230

    (12) decl_init -> ID : type_func = { opt_stmt_list } .
    ID              reduce using rule 12 (decl_init -> ID : type_func = { opt_stmt_list } .)
    DO              reduce using rule 12 (decl_init -> ID : type_func = { opt_stmt_list } .)
    WHILE           reduce using rule 12 (decl_init -> ID : type_func = { opt_stmt_list } .)
    {               reduce using rule 12 (decl_init -> ID : type_func = { opt_stmt_list } .)
    BREAK           reduce using rule 12 (decl_init -> ID : type_func = { opt_stmt_list } .)
    CONTINUE        reduce using rule 12 (decl_init -> ID : type_func = { opt_stmt_list } .)
    RETURN          reduce using rule 12 (decl_init -> ID : type_func = { opt_stmt_list } .)
    PRINT           reduce using rule 12 (decl_init -> ID : type_func = { opt_stmt_list } .)
    FOR             reduce using rule 12 (decl_init -> ID : type_func = { opt_stmt_list } .)
    IF              reduce using rule 12 (decl_init -> ID : type_func = { opt_stmt_list } .)
    !               reduce using rule 12 (decl_init -> ID : type_func = { opt_stmt_list } .)
    +               reduce using rule 12 (decl_init -> ID : type_func = { opt_stmt_list } .)
    -               reduce using rule 12 (decl_init -> ID : type_func = { opt_stmt_list } .)
    DEC             reduce using rule 12 (decl_init -> ID : type_func = { opt_stmt_list } .)
    INC             reduce using rule 12 (decl_init -> ID : type_func = { opt_stmt_list } .)
    (               reduce using rule 12 (decl_init -> ID : type_func = { opt_stmt_list } .)
    FALSE           reduce using rule 12 (decl_init -> ID : type_func = { opt_stmt_list } .)
    TRUE            reduce using rule 12 (decl_init -> ID : type_func = { opt_stmt_list } .)
    STRING_LITERAL  reduce using rule 12 (decl_init -> ID : type_func = { opt_stmt_list } .)
    CHAR_LITERAL    reduce using rule 12 (decl_init -> ID : type_func = { opt_stmt_list } .)
    FLOAT_LITERAL   reduce using rule 12 (decl_init -> ID : type_func = { opt_stmt_list } .)
    INTEGER_LITERAL reduce using rule 12 (decl_init -> ID : type_func = { opt_stmt_list } .)
    $end            reduce using rule 12 (decl_init -> ID : type_func = { opt_stmt_list } .)
    }               reduce using rule 12 (decl_init -> ID : type_func = { opt_stmt_list } .)
    ELSE            reduce using rule 12 (decl_init -> ID : type_func = { opt_stmt_list } .)


state 231

    (13) decl_init -> ID : type_array_sized = { opt_expr_list } . ;
    ;               shift and go to state 244


state 232

    (15) decl_init -> ID : CONSTANT = { opt_expr_list } . ;
    ;               shift and go to state 245


state 233

    (18) decl_init -> ID : AUTO = { opt_expr_list } . ;
    ;               shift and go to state 246


state 234

    (120) type_func -> FUNCTION type_array_sized ( opt_param_list ) .
    ;               reduce using rule 120 (type_func -> FUNCTION type_array_sized ( opt_param_list ) .)
    =               reduce using rule 120 (type_func -> FUNCTION type_array_sized ( opt_param_list ) .)


state 235

    (126) param_list -> param_list , . param
    (127) param -> . ID : type_array_sized
    (128) param -> . ID : type_array
    (129) param -> . ID : type_simple
    ID              shift and go to state 223

    param                          shift and go to state 247

state 236

    (127) param -> ID : . type_array_sized
    (128) param -> ID : . type_array
    (129) param -> ID : . type_simple
    (116) type_array_sized -> . ARRAY index type_array_sized
    (117) type_array_sized -> . ARRAY index type_simple
    (118) type_array -> . ARRAY [ ] type_array
    (119) type_array -> . ARRAY [ ] type_simple
    (110) type_simple -> . VOID
    (111) type_simple -> . STRING
    (112) type_simple -> . CHAR
    (113) type_simple -> . BOOLEAN
    (114) type_simple -> . FLOAT
    (115) type_simple -> . INTEGER
    ARRAY           shift and go to state 175
    VOID            shift and go to state 123
    STRING          shift and go to state 124
    CHAR            shift and go to state 125
    BOOLEAN         shift and go to state 126
    FLOAT           shift and go to state 127
    INTEGER         shift and go to state 128

    type_array_sized               shift and go to state 248
    type_array                     shift and go to state 249
    type_simple                    shift and go to state 250

state 237

    (121) type_func -> FUNCTION type_array ( opt_param_list ) .
    ;               reduce using rule 121 (type_func -> FUNCTION type_array ( opt_param_list ) .)
    =               reduce using rule 121 (type_func -> FUNCTION type_array ( opt_param_list ) .)


state 238

    (122) type_func -> FUNCTION type_simple ( opt_param_list ) .
    ;               reduce using rule 122 (type_func -> FUNCTION type_simple ( opt_param_list ) .)
    =               reduce using rule 122 (type_func -> FUNCTION type_simple ( opt_param_list ) .)


state 239

    (118) type_array -> ARRAY . [ ] type_array
    (119) type_array -> ARRAY . [ ] type_simple
    [               shift and go to state 251


state 240

    (118) type_array -> ARRAY [ ] type_array .
    (               reduce using rule 118 (type_array -> ARRAY [ ] type_array .)
    ,               reduce using rule 118 (type_array -> ARRAY [ ] type_array .)
    )               reduce using rule 118 (type_array -> ARRAY [ ] type_array .)


state 241

    (119) type_array -> ARRAY [ ] type_simple .
    (               reduce using rule 119 (type_array -> ARRAY [ ] type_simple .)
    ,               reduce using rule 119 (type_array -> ARRAY [ ] type_simple .)
    )               reduce using rule 119 (type_array -> ARRAY [ ] type_simple .)


state 242

    (44) do_while_stmt -> DO closed_stmt WHILE ( expr ) ; .
    ID              reduce using rule 44 (do_while_stmt -> DO closed_stmt WHILE ( expr ) ; .)
    DO              reduce using rule 44 (do_while_stmt -> DO closed_stmt WHILE ( expr ) ; .)
    WHILE           reduce using rule 44 (do_while_stmt -> DO closed_stmt WHILE ( expr ) ; .)
    {               reduce using rule 44 (do_while_stmt -> DO closed_stmt WHILE ( expr ) ; .)
    BREAK           reduce using rule 44 (do_while_stmt -> DO closed_stmt WHILE ( expr ) ; .)
    CONTINUE        reduce using rule 44 (do_while_stmt -> DO closed_stmt WHILE ( expr ) ; .)
    RETURN          reduce using rule 44 (do_while_stmt -> DO closed_stmt WHILE ( expr ) ; .)
    PRINT           reduce using rule 44 (do_while_stmt -> DO closed_stmt WHILE ( expr ) ; .)
    FOR             reduce using rule 44 (do_while_stmt -> DO closed_stmt WHILE ( expr ) ; .)
    IF              reduce using rule 44 (do_while_stmt -> DO closed_stmt WHILE ( expr ) ; .)
    !               reduce using rule 44 (do_while_stmt -> DO closed_stmt WHILE ( expr ) ; .)
    +               reduce using rule 44 (do_while_stmt -> DO closed_stmt WHILE ( expr ) ; .)
    -               reduce using rule 44 (do_while_stmt -> DO closed_stmt WHILE ( expr ) ; .)
    DEC             reduce using rule 44 (do_while_stmt -> DO closed_stmt WHILE ( expr ) ; .)
    INC             reduce using rule 44 (do_while_stmt -> DO closed_stmt WHILE ( expr ) ; .)
    (               reduce using rule 44 (do_while_stmt -> DO closed_stmt WHILE ( expr ) ; .)
    FALSE           reduce using rule 44 (do_while_stmt -> DO closed_stmt WHILE ( expr ) ; .)
    TRUE            reduce using rule 44 (do_while_stmt -> DO closed_stmt WHILE ( expr ) ; .)
    STRING_LITERAL  reduce using rule 44 (do_while_stmt -> DO closed_stmt WHILE ( expr ) ; .)
    CHAR_LITERAL    reduce using rule 44 (do_while_stmt -> DO closed_stmt WHILE ( expr ) ; .)
    FLOAT_LITERAL   reduce using rule 44 (do_while_stmt -> DO closed_stmt WHILE ( expr ) ; .)
    INTEGER_LITERAL reduce using rule 44 (do_while_stmt -> DO closed_stmt WHILE ( expr ) ; .)
    $end            reduce using rule 44 (do_while_stmt -> DO closed_stmt WHILE ( expr ) ; .)
    }               reduce using rule 44 (do_while_stmt -> DO closed_stmt WHILE ( expr ) ; .)
    ELSE            reduce using rule 44 (do_while_stmt -> DO closed_stmt WHILE ( expr ) ; .)


state 243

    (39) for_header -> FOR ( opt_expr ; opt_expr ; opt_expr . )
    )               shift and go to state 252


state 244

    (13) decl_init -> ID : type_array_sized = { opt_expr_list } ; .
    ID              reduce using rule 13 (decl_init -> ID : type_array_sized = { opt_expr_list } ; .)
    DO              reduce using rule 13 (decl_init -> ID : type_array_sized = { opt_expr_list } ; .)
    WHILE           reduce using rule 13 (decl_init -> ID : type_array_sized = { opt_expr_list } ; .)
    {               reduce using rule 13 (decl_init -> ID : type_array_sized = { opt_expr_list } ; .)
    BREAK           reduce using rule 13 (decl_init -> ID : type_array_sized = { opt_expr_list } ; .)
    CONTINUE        reduce using rule 13 (decl_init -> ID : type_array_sized = { opt_expr_list } ; .)
    RETURN          reduce using rule 13 (decl_init -> ID : type_array_sized = { opt_expr_list } ; .)
    PRINT           reduce using rule 13 (decl_init -> ID : type_array_sized = { opt_expr_list } ; .)
    FOR             reduce using rule 13 (decl_init -> ID : type_array_sized = { opt_expr_list } ; .)
    IF              reduce using rule 13 (decl_init -> ID : type_array_sized = { opt_expr_list } ; .)
    !               reduce using rule 13 (decl_init -> ID : type_array_sized = { opt_expr_list } ; .)
    +               reduce using rule 13 (decl_init -> ID : type_array_sized = { opt_expr_list } ; .)
    -               reduce using rule 13 (decl_init -> ID : type_array_sized = { opt_expr_list } ; .)
    DEC             reduce using rule 13 (decl_init -> ID : type_array_sized = { opt_expr_list } ; .)
    INC             reduce using rule 13 (decl_init -> ID : type_array_sized = { opt_expr_list } ; .)
    (               reduce using rule 13 (decl_init -> ID : type_array_sized = { opt_expr_list } ; .)
    FALSE           reduce using rule 13 (decl_init -> ID : type_array_sized = { opt_expr_list } ; .)
    TRUE            reduce using rule 13 (decl_init -> ID : type_array_sized = { opt_expr_list } ; .)
    STRING_LITERAL  reduce using rule 13 (decl_init -> ID : type_array_sized = { opt_expr_list } ; .)
    CHAR_LITERAL    reduce using rule 13 (decl_init -> ID : type_array_sized = { opt_expr_list } ; .)
    FLOAT_LITERAL   reduce using rule 13 (decl_init -> ID : type_array_sized = { opt_expr_list } ; .)
    INTEGER_LITERAL reduce using rule 13 (decl_init -> ID : type_array_sized = { opt_expr_list } ; .)
    $end            reduce using rule 13 (decl_init -> ID : type_array_sized = { opt_expr_list } ; .)
    }               reduce using rule 13 (decl_init -> ID : type_array_sized = { opt_expr_list } ; .)
    ELSE            reduce using rule 13 (decl_init -> ID : type_array_sized = { opt_expr_list } ; .)


state 245

    (15) decl_init -> ID : CONSTANT = { opt_expr_list } ; .
    ID              reduce using rule 15 (decl_init -> ID : CONSTANT = { opt_expr_list } ; .)
    DO              reduce using rule 15 (decl_init -> ID : CONSTANT = { opt_expr_list } ; .)
    WHILE           reduce using rule 15 (decl_init -> ID : CONSTANT = { opt_expr_list } ; .)
    {               reduce using rule 15 (decl_init -> ID : CONSTANT = { opt_expr_list } ; .)
    BREAK           reduce using rule 15 (decl_init -> ID : CONSTANT = { opt_expr_list } ; .)
    CONTINUE        reduce using rule 15 (decl_init -> ID : CONSTANT = { opt_expr_list } ; .)
    RETURN          reduce using rule 15 (decl_init -> ID : CONSTANT = { opt_expr_list } ; .)
    PRINT           reduce using rule 15 (decl_init -> ID : CONSTANT = { opt_expr_list } ; .)
    FOR             reduce using rule 15 (decl_init -> ID : CONSTANT = { opt_expr_list } ; .)
    IF              reduce using rule 15 (decl_init -> ID : CONSTANT = { opt_expr_list } ; .)
    !               reduce using rule 15 (decl_init -> ID : CONSTANT = { opt_expr_list } ; .)
    +               reduce using rule 15 (decl_init -> ID : CONSTANT = { opt_expr_list } ; .)
    -               reduce using rule 15 (decl_init -> ID : CONSTANT = { opt_expr_list } ; .)
    DEC             reduce using rule 15 (decl_init -> ID : CONSTANT = { opt_expr_list } ; .)
    INC             reduce using rule 15 (decl_init -> ID : CONSTANT = { opt_expr_list } ; .)
    (               reduce using rule 15 (decl_init -> ID : CONSTANT = { opt_expr_list } ; .)
    FALSE           reduce using rule 15 (decl_init -> ID : CONSTANT = { opt_expr_list } ; .)
    TRUE            reduce using rule 15 (decl_init -> ID : CONSTANT = { opt_expr_list } ; .)
    STRING_LITERAL  reduce using rule 15 (decl_init -> ID : CONSTANT = { opt_expr_list } ; .)
    CHAR_LITERAL    reduce using rule 15 (decl_init -> ID : CONSTANT = { opt_expr_list } ; .)
    FLOAT_LITERAL   reduce using rule 15 (decl_init -> ID : CONSTANT = { opt_expr_list } ; .)
    INTEGER_LITERAL reduce using rule 15 (decl_init -> ID : CONSTANT = { opt_expr_list } ; .)
    $end            reduce using rule 15 (decl_init -> ID : CONSTANT = { opt_expr_list } ; .)
    }               reduce using rule 15 (decl_init -> ID : CONSTANT = { opt_expr_list } ; .)
    ELSE            reduce using rule 15 (decl_init -> ID : CONSTANT = { opt_expr_list } ; .)


state 246

    (18) decl_init -> ID : AUTO = { opt_expr_list } ; .
    ID              reduce using rule 18 (decl_init -> ID : AUTO = { opt_expr_list } ; .)
    DO              reduce using rule 18 (decl_init -> ID : AUTO = { opt_expr_list } ; .)
    WHILE           reduce using rule 18 (decl_init -> ID : AUTO = { opt_expr_list } ; .)
    {               reduce using rule 18 (decl_init -> ID : AUTO = { opt_expr_list } ; .)
    BREAK           reduce using rule 18 (decl_init -> ID : AUTO = { opt_expr_list } ; .)
    CONTINUE        reduce using rule 18 (decl_init -> ID : AUTO = { opt_expr_list } ; .)
    RETURN          reduce using rule 18 (decl_init -> ID : AUTO = { opt_expr_list } ; .)
    PRINT           reduce using rule 18 (decl_init -> ID : AUTO = { opt_expr_list } ; .)
    FOR             reduce using rule 18 (decl_init -> ID : AUTO = { opt_expr_list } ; .)
    IF              reduce using rule 18 (decl_init -> ID : AUTO = { opt_expr_list } ; .)
    !               reduce using rule 18 (decl_init -> ID : AUTO = { opt_expr_list } ; .)
    +               reduce using rule 18 (decl_init -> ID : AUTO = { opt_expr_list } ; .)
    -               reduce using rule 18 (decl_init -> ID : AUTO = { opt_expr_list } ; .)
    DEC             reduce using rule 18 (decl_init -> ID : AUTO = { opt_expr_list } ; .)
    INC             reduce using rule 18 (decl_init -> ID : AUTO = { opt_expr_list } ; .)
    (               reduce using rule 18 (decl_init -> ID : AUTO = { opt_expr_list } ; .)
    FALSE           reduce using rule 18 (decl_init -> ID : AUTO = { opt_expr_list } ; .)
    TRUE            reduce using rule 18 (decl_init -> ID : AUTO = { opt_expr_list } ; .)
    STRING_LITERAL  reduce using rule 18 (decl_init -> ID : AUTO = { opt_expr_list } ; .)
    CHAR_LITERAL    reduce using rule 18 (decl_init -> ID : AUTO = { opt_expr_list } ; .)
    FLOAT_LITERAL   reduce using rule 18 (decl_init -> ID : AUTO = { opt_expr_list } ; .)
    INTEGER_LITERAL reduce using rule 18 (decl_init -> ID : AUTO = { opt_expr_list } ; .)
    $end            reduce using rule 18 (decl_init -> ID : AUTO = { opt_expr_list } ; .)
    }               reduce using rule 18 (decl_init -> ID : AUTO = { opt_expr_list } ; .)
    ELSE            reduce using rule 18 (decl_init -> ID : AUTO = { opt_expr_list } ; .)


state 247

    (126) param_list -> param_list , param .
    ,               reduce using rule 126 (param_list -> param_list , param .)
    )               reduce using rule 126 (param_list -> param_list , param .)


state 248

    (127) param -> ID : type_array_sized .
    ,               reduce using rule 127 (param -> ID : type_array_sized .)
    )               reduce using rule 127 (param -> ID : type_array_sized .)


state 249

    (128) param -> ID : type_array .
    ,               reduce using rule 128 (param -> ID : type_array .)
    )               reduce using rule 128 (param -> ID : type_array .)


state 250

    (129) param -> ID : type_simple .
    ,               reduce using rule 129 (param -> ID : type_simple .)
    )               reduce using rule 129 (param -> ID : type_simple .)


state 251

    (118) type_array -> ARRAY [ . ] type_array
    (119) type_array -> ARRAY [ . ] type_simple
    ]               shift and go to state 226


state 252

    (39) for_header -> FOR ( opt_expr ; opt_expr ; opt_expr ) .
    DO              reduce using rule 39 (for_header -> FOR ( opt_expr ; opt_expr ; opt_expr ) .)
    WHILE           reduce using rule 39 (for_header -> FOR ( opt_expr ; opt_expr ; opt_expr ) .)
    ID              reduce using rule 39 (for_header -> FOR ( opt_expr ; opt_expr ; opt_expr ) .)
    {               reduce using rule 39 (for_header -> FOR ( opt_expr ; opt_expr ; opt_expr ) .)
    BREAK           reduce using rule 39 (for_header -> FOR ( opt_expr ; opt_expr ; opt_expr ) .)
    CONTINUE        reduce using rule 39 (for_header -> FOR ( opt_expr ; opt_expr ; opt_expr ) .)
    RETURN          reduce using rule 39 (for_header -> FOR ( opt_expr ; opt_expr ; opt_expr ) .)
    PRINT           reduce using rule 39 (for_header -> FOR ( opt_expr ; opt_expr ; opt_expr ) .)
    FOR             reduce using rule 39 (for_header -> FOR ( opt_expr ; opt_expr ; opt_expr ) .)
    IF              reduce using rule 39 (for_header -> FOR ( opt_expr ; opt_expr ; opt_expr ) .)
    !               reduce using rule 39 (for_header -> FOR ( opt_expr ; opt_expr ; opt_expr ) .)
    +               reduce using rule 39 (for_header -> FOR ( opt_expr ; opt_expr ; opt_expr ) .)
    -               reduce using rule 39 (for_header -> FOR ( opt_expr ; opt_expr ; opt_expr ) .)
    DEC             reduce using rule 39 (for_header -> FOR ( opt_expr ; opt_expr ; opt_expr ) .)
    INC             reduce using rule 39 (for_header -> FOR ( opt_expr ; opt_expr ; opt_expr ) .)
    (               reduce using rule 39 (for_header -> FOR ( opt_expr ; opt_expr ; opt_expr ) .)
    FALSE           reduce using rule 39 (for_header -> FOR ( opt_expr ; opt_expr ; opt_expr ) .)
    TRUE            reduce using rule 39 (for_header -> FOR ( opt_expr ; opt_expr ; opt_expr ) .)
    STRING_LITERAL  reduce using rule 39 (for_header -> FOR ( opt_expr ; opt_expr ; opt_expr ) .)
    CHAR_LITERAL    reduce using rule 39 (for_header -> FOR ( opt_expr ; opt_expr ; opt_expr ) .)
    FLOAT_LITERAL   reduce using rule 39 (for_header -> FOR ( opt_expr ; opt_expr ; opt_expr ) .)
    INTEGER_LITERAL reduce using rule 39 (for_header -> FOR ( opt_expr ; opt_expr ; opt_expr ) .)


Conflicts:

shift/reduce conflict for DEC in state 114 resolved as shift
shift/reduce conflict for INC in state 114 resolved as shift
shift/reduce conflict for DEC in state 115 resolved as shift
shift/reduce conflict for INC in state 115 resolved as shift
reduce/reduce conflict in state 6 resolved using rule global_item -> decl
rejected rule (simple_stmt -> decl) in state 6
reduce/reduce conflict in state 140 resolved using rule expr -> expr1
rejected rule (expr1 -> lval = expr1) in state 140